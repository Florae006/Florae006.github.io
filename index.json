[{"categories":["在前端搬砖的日子里"],"content":"一篇用于从零开始，基于原生H5C3JS制作的购物车页面","date":"2024-07-06","objectID":"/posts/testcart/","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/"},{"categories":["在前端搬砖的日子里"],"content":" 前言 这篇文章用于2024年蓝旭暑期项目前的培训作业教学，目的是从零开始构建一个购物车页面，以此来熟悉原生前端三件套。o((\u003eω\u003c ))o ","date":"2024-07-06","objectID":"/posts/testcart/:0:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#"},{"categories":["在前端搬砖的日子里"],"content":" 需求分析功能要求： 全选、单选联动逻辑（包括依次选中所有物品时自动勾选全选按钮、勾选全选时勾选所 有单选、取消全选后取消所有选中等）、结算小项总价以及整体总价。 展示商品图片、名称、价格、数量等基础信息。 体现分页展示购物车内商品内容。 可以对购物车内商品进行增删改，即改变数量、结算商品、删除商品（结合分页显示数 目合理调整）等。 美观的页面效果。 加分功能 实现在购物车页面查找商品的功能。 自己写一个弹出提示框，在删除商品、结算商品等行为后与用户进行确认交互。 ","date":"2024-07-06","objectID":"/posts/testcart/:0:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#需求分析"},{"categories":["在前端搬砖的日子里"],"content":" 页面布局","date":"2024-07-06","objectID":"/posts/testcart/:0:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#页面布局"},{"categories":["在前端搬砖的日子里"],"content":" 整体布局整个购物车页面有三个主要功能：列表、结算、分页。 购物车页面的布局主要分为两部分：购物车列表和结算栏。 购物车列表是购物车页面的主体部分，用于展示用户购物车中的商品信息，我们将整个列表设计在整个页面的中部，在顶部设计一个nav用于展示购物车的标题，以及作为之后的路由跳转的位置，这个nav设计成吸顶。 中间主体部分是购物车列表，用于展示用户购物车中的商品信息。 底部我设计为结算栏，用于展示用户当前选中的总价，以及结算按钮。 分页的位置我设计在购物车列表之上，并且把它设计成向下滑动时吸顶的设计，这样用户在浏览商品时可以随时翻页。 于是整体的设计如下： \u003cbody\u003e \u003cdiv class=\"shell\"\u003e \u003cnav\u003e {/* 用来设计路由栏 */} \u003cimg class=\"nav-item\" src=\"https://www.coca-cola.com/content/dam/onexp/cn/zh/logos/coke-header.png\" alt=\"\"\u003e \u003cdiv class=\"nav-item\"\u003e购物车\u003c/div\u003e \u003cdiv class=\"nav-item\"\u003e订单\u003c/div\u003e \u003cdiv class=\"nav-item\"\u003e我的\u003c/div\u003e \u003c/nav\u003e \u003cmain\u003e \u003cdiv class=\"title-div\"\u003e \u003cdiv class=\"title\"\u003e当前选中1样商品\u003c/div\u003e \u003cdiv class=\"pagination\"\u003e \u003cdiv class=\"page\"\u003e1\u003c/div\u003e {/* 页码 */} \u003cdiv class=\"page\"\u003en\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"cart-item\"\u003e {/* 详细的购物车内商品信息 */} \u003c/div\u003e \u003cdiv class=\"cart-item\"\u003e {/* 详细的购物车内商品信息 */} \u003c/div\u003e {/* .... */} \u003c/div\u003e \u003c/main\u003e \u003cfooter\u003e \u003cdiv class=\"sum-foot\"\u003e {/* 展示全选按钮和结算信息 */} \u003c/div\u003e \u003c/footer\u003e \u003c/div\u003e \u003c/body\u003e 关于吸顶和吸底的设计 设计吸顶和吸底的时候，我们可以使用position: sticky属性，这个属性可以让元素在滚动到特定位置时固定在页面上，这样可以让用户在浏览页面时更加方便。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#整体布局"},{"categories":["在前端搬砖的日子里"],"content":" 购物车列表设计购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成这些卡片。 这是我设计的一个商品卡片的结构： \u003cdiv class=\"cart-item\"\u003e \u003cinput type=\"radio\"\u003e {/* 单选按钮 */} \u003cimg src=\"\" alt=\"\"\u003e {/* 商品图片 */} \u003cdiv class=\"item-info\"\u003e \u003ch2\u003e{/* 商品名称 */}\u003c/h2\u003e \u003cdiv class=\"info\"\u003e \u003cdiv class=\"desp\"\u003e {/* 商品描述 */} \u003c/div\u003e \u003cdiv class=\"detail\"\u003e \u003cdiv class=\"price\"\u003e{/* 价格 */}\u003c/div\u003e \u003cdiv class=\"quantity\"\u003e {/* 数量 */} \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbutton class=\"del-btn\"\u003e删除\u003c/button\u003e \u003c/div\u003e 添加完CSS样式后，我们可以得到一个商品卡片的效果： 这是我的CSS样式： .cart-item { height: fit-content; width: 80%; margin-bottom: 1rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.25); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 0.666667px solid rgba(255, 255, 255, 0.18); box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; -webkit-box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; border-radius: 12px; -webkit-border-radius: 12px; display: flex; flex-direction: row; justify-content: space-between; } .cart-item input[type=\"radio\"] { margin-top: 1rem; margin-right: 1rem; cursor: pointer; width: 1.5rem; } .cart-item img { width: 160px; height: 160px; border-radius: 12px; -webkit-border-radius: 12px; box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; } .cart-item .item-info { flex: 1; display: flex; flex-direction: column; justify-content: center; /* align-items: center; */ margin-left: 1rem; } .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; margin: 0 1rem; background-color: #dddddd94; border-radius: 12px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: flex; flex-direction: column; justify-content: space-around; padding: 0.5rem; .price { font-size: large; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } .quantity { font-size: medium; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } } } .cart-item .del-btn { background-color: #f8f9fa; border: none; color: red; font-size: large; font-weight: bold; cursor: pointer; margin-top: 1rem; } .cart-item .del-btn:hover { color: #007bff; } CSS解释像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。 我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按照这个顺序，我将他们横向排列，分别占据不同的比例。 在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧 在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。 其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。 .div { display: flex; justify-content: center; align-items: center; } justify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，align-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要通过不断调整margin来实现的布局。具体区别可以在这里和这里在线演示。 我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。 商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。 在flex布局中让内部元素占据不同的比例 上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性来控制元素。 例如上面的代码中，我通过flex: 3和flex: 1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样： .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; display: flex; flex-direction: column; justify-content: space-around; .price { span { flex: 1; } } .quantity { span { flex: 1; } } } } 图标库相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font awesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。 在线工具推荐有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：https://lingdaima.com/ ，可以帮助你快速调整出好看的CSS样式。 当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝) 这里是整体设计完Html结构和CSS之后的效果： 这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:1","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#购物车列表设计"},{"categories":["在前端搬砖的日子里"],"content":" 购物车列表设计购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成这些卡片。 这是我设计的一个商品卡片的结构： {/* 单选按钮 */} {/* 商品图片 */} {/* 商品名称 */} {/* 商品描述 */} {/* 价格 */} {/* 数量 */} 删除 添加完CSS样式后，我们可以得到一个商品卡片的效果： 这是我的CSS样式： .cart-item { height: fit-content; width: 80%; margin-bottom: 1rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.25); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 0.666667px solid rgba(255, 255, 255, 0.18); box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; -webkit-box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; border-radius: 12px; -webkit-border-radius: 12px; display: flex; flex-direction: row; justify-content: space-between; } .cart-item input[type=\"radio\"] { margin-top: 1rem; margin-right: 1rem; cursor: pointer; width: 1.5rem; } .cart-item img { width: 160px; height: 160px; border-radius: 12px; -webkit-border-radius: 12px; box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; } .cart-item .item-info { flex: 1; display: flex; flex-direction: column; justify-content: center; /* align-items: center; */ margin-left: 1rem; } .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; margin: 0 1rem; background-color: #dddddd94; border-radius: 12px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: flex; flex-direction: column; justify-content: space-around; padding: 0.5rem; .price { font-size: large; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } .quantity { font-size: medium; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } } } .cart-item .del-btn { background-color: #f8f9fa; border: none; color: red; font-size: large; font-weight: bold; cursor: pointer; margin-top: 1rem; } .cart-item .del-btn:hover { color: #007bff; } CSS解释像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。 我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按照这个顺序，我将他们横向排列，分别占据不同的比例。 在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧 在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。 其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。 .div { display: flex; justify-content: center; align-items: center; } justify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，align-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要通过不断调整margin来实现的布局。具体区别可以在这里和这里在线演示。 我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。 商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。 在flex布局中让内部元素占据不同的比例 上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性来控制元素。 例如上面的代码中，我通过flex: 3和flex: 1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样： .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; display: flex; flex-direction: column; justify-content: space-around; .price { span { flex: 1; } } .quantity { span { flex: 1; } } } } 图标库相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font awesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。 在线工具推荐有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：https://lingdaima.com/ ，可以帮助你快速调整出好看的CSS样式。 当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝) 这里是整体设计完Html结构和CSS之后的效果： 这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:1","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#css解释"},{"categories":["在前端搬砖的日子里"],"content":" 购物车列表设计购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成这些卡片。 这是我设计的一个商品卡片的结构： {/* 单选按钮 */} {/* 商品图片 */} {/* 商品名称 */} {/* 商品描述 */} {/* 价格 */} {/* 数量 */} 删除 添加完CSS样式后，我们可以得到一个商品卡片的效果： 这是我的CSS样式： .cart-item { height: fit-content; width: 80%; margin-bottom: 1rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.25); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 0.666667px solid rgba(255, 255, 255, 0.18); box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; -webkit-box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; border-radius: 12px; -webkit-border-radius: 12px; display: flex; flex-direction: row; justify-content: space-between; } .cart-item input[type=\"radio\"] { margin-top: 1rem; margin-right: 1rem; cursor: pointer; width: 1.5rem; } .cart-item img { width: 160px; height: 160px; border-radius: 12px; -webkit-border-radius: 12px; box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; } .cart-item .item-info { flex: 1; display: flex; flex-direction: column; justify-content: center; /* align-items: center; */ margin-left: 1rem; } .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; margin: 0 1rem; background-color: #dddddd94; border-radius: 12px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: flex; flex-direction: column; justify-content: space-around; padding: 0.5rem; .price { font-size: large; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } .quantity { font-size: medium; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } } } .cart-item .del-btn { background-color: #f8f9fa; border: none; color: red; font-size: large; font-weight: bold; cursor: pointer; margin-top: 1rem; } .cart-item .del-btn:hover { color: #007bff; } CSS解释像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。 我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按照这个顺序，我将他们横向排列，分别占据不同的比例。 在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧 在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。 其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。 .div { display: flex; justify-content: center; align-items: center; } justify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，align-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要通过不断调整margin来实现的布局。具体区别可以在这里和这里在线演示。 我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。 商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。 在flex布局中让内部元素占据不同的比例 上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性来控制元素。 例如上面的代码中，我通过flex: 3和flex: 1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样： .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; display: flex; flex-direction: column; justify-content: space-around; .price { span { flex: 1; } } .quantity { span { flex: 1; } } } } 图标库相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font awesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。 在线工具推荐有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：https://lingdaima.com/ ，可以帮助你快速调整出好看的CSS样式。 当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝) 这里是整体设计完Html结构和CSS之后的效果： 这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:1","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#图标库"},{"categories":["在前端搬砖的日子里"],"content":" 购物车列表设计购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成这些卡片。 这是我设计的一个商品卡片的结构： {/* 单选按钮 */} {/* 商品图片 */} {/* 商品名称 */} {/* 商品描述 */} {/* 价格 */} {/* 数量 */} 删除 添加完CSS样式后，我们可以得到一个商品卡片的效果： 这是我的CSS样式： .cart-item { height: fit-content; width: 80%; margin-bottom: 1rem; padding: 1rem; background-color: rgba(255, 255, 255, 0.25); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 0.666667px solid rgba(255, 255, 255, 0.18); box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; -webkit-box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; border-radius: 12px; -webkit-border-radius: 12px; display: flex; flex-direction: row; justify-content: space-between; } .cart-item input[type=\"radio\"] { margin-top: 1rem; margin-right: 1rem; cursor: pointer; width: 1.5rem; } .cart-item img { width: 160px; height: 160px; border-radius: 12px; -webkit-border-radius: 12px; box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px; } .cart-item .item-info { flex: 1; display: flex; flex-direction: column; justify-content: center; /* align-items: center; */ margin-left: 1rem; } .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; margin: 0 1rem; background-color: #dddddd94; border-radius: 12px; backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); display: flex; flex-direction: column; justify-content: space-around; padding: 0.5rem; .price { font-size: large; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } .quantity { font-size: medium; font-weight: bold; display: flex; span { flex: 1; display: flex; justify-content: space-around; align-items: center; } } } } .cart-item .del-btn { background-color: #f8f9fa; border: none; color: red; font-size: large; font-weight: bold; cursor: pointer; margin-top: 1rem; } .cart-item .del-btn:hover { color: #007bff; } CSS解释像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。 我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按照这个顺序，我将他们横向排列，分别占据不同的比例。 在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧 在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。 其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。 .div { display: flex; justify-content: center; align-items: center; } justify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，align-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要通过不断调整margin来实现的布局。具体区别可以在这里和这里在线演示。 我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。 商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。 在flex布局中让内部元素占据不同的比例 上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性来控制元素。 例如上面的代码中，我通过flex: 3和flex: 1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样： .cart-item .info { display: flex; flex-direction: row; justify-content: space-between; .desp { flex: 3; } .detail { flex: 1; display: flex; flex-direction: column; justify-content: space-around; .price { span { flex: 1; } } .quantity { span { flex: 1; } } } } 图标库相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font awesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。 在线工具推荐有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：https://lingdaima.com/ ，可以帮助你快速调整出好看的CSS样式。 当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝) 这里是整体设计完Html结构和CSS之后的效果： 这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:1","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#在线工具推荐"},{"categories":["在前端搬砖的日子里"],"content":" JavaScript逻辑我比较习惯在设计完页面之后再写JavaScript逻辑，这样可以更好的理清思路，而且不需要总是再次调整Html和CSS。在设计完页面之后，我们通过让这个页面不再是一个静态的页面，而是一个可以动态交互的页面。 通过本地json来获得数据和渲染数据 由于这个只是用于前端学习的小项目，我们没有接口，不过在生成应用中，页面的数据是来自后端传递而来的（往往是一个json），所以在这个项目中，我们可以通过本地的json文件来模拟后端返回的数据，这样可以更好的模拟真实的购物车页面，同时也可以更好的理解前后端的交互。 引入json文件的方法是通过fetch方法，这是一个异步方法，我们可以通过这个方法来获取json文件，然后通过json()方法来解析json文件。 就像这样： fetch('data.json') .then(response =\u003e response.json()) .then(data =\u003e console.log(data)); ","date":"2024-07-06","objectID":"/posts/testcart/:0:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#javascript逻辑"},{"categories":["在前端搬砖的日子里"],"content":" JS逻辑为了方便管理数据，我将数据保存在一个全局变量中，这样可以更好的操作数据，下文的代码中，我会使用这些全局变量来操作数据。 var goods = []; // 当前页的商品列表 var totItems = 0; // 总商品数 var curPage = 1; // 当前页码 var totPages = 1; // 总页数 var selectTotal = 0; // 选中商品总数 var curSelectGoods = []; // 选中的商品列表 var selectAllStatus = false; // 是否全选 ","date":"2024-07-06","objectID":"/posts/testcart/:1:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#js逻辑"},{"categories":["在前端搬砖的日子里"],"content":" 数据获取与渲染首先我们需要通过fetch方法来获取json文件，然后通过json()方法来解析json文件，这样我们就可以得到一个json对象，这个对象就是我们的商品信息。 fetch('data.json') .then(response =\u003e response.json()) .then(data =\u003e { console.log(data); render(data); }); 获取数据之后，我们设置全局变量来保存当前的数据状态，然后将数据渲染到页面上，就像这样： const renderCartList = () =\u003e { const goodsContainer = document.querySelector('#container'); goodsContainer.innerHTML = ''; if (goods.length === 0 \u0026\u0026 totItems !== 0) { // 如果购物车本页没有商品（通过删除删空的情况或意外情况），应该重新请求数据，初始化购物车 initGoods(); } else if (totItems === 0) { // 如果购物车没有商品，应该显示空购物车 goodsContainer.innerHTML = '\u003cdiv class=\"empty-cart\"\u003e购物车为空`(*\u003e﹏\u003c*)′\u003c/div\u003e'; return; } for (let i = 0; i \u003c goods.length; i++) { const good = goods[i]; const cartItem = document.createElement('div'); cartItem.classList.add('cart-item'); cartItem.setAttribute('id', \"item-\" + good[\"id\"]); cartItem.innerHTML = `\u003cinput type=\"checkbox\" onClick=\"selectGood(${good[\"id\"]})\"\u003e \u003cimg src=\"${good[\"image\"]}\" alt=\"\"\u003e \u003cdiv class=\"item-info\"\u003e \u003ch2\u003e商品名称：${good[\"name\"]}\u003c/h2\u003e \u003cdiv class=\"info\"\u003e \u003cdiv class=\"desp\"\u003e 商品描述：\u003cspan\u003e${good[\"description\"]}\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"detail\"\u003e \u003cdiv class=\"price\"\u003e单价：\u003cspan\u003e\u003ci class=\"fa-solid fa-yen-sign\"\u003e\u003c/i\u003e \u003cspan\u003e${good[\"price\"].toFixed(2)}\u003c/span\u003e \u003c/span\u003e\u003c/div\u003e \u003cdiv class=\"price\"\u003e小计：\u003cspan\u003e\u003ci class=\"fa-solid fa-yen-sign\"\u003e\u003c/i\u003e \u003cspan class=\"tot-price\"\u003e${(good[\"price\"] * good[\"quantity\"]).toFixed(2)}\u003c/span\u003e \u003c/span\u003e\u003c/div\u003e \u003cdiv class=\"quantity\"\u003e 数量： \u003cspan class=\"count\"\u003e \u003ci class=\"fa-solid fa-circle-minus\" onClick=\"changeQuantity(${good[\"id\"]}, -1)\"\u003e\u003c/i\u003e \u003cspan\u003e${good[\"quantity\"]}\u003c/span\u003e \u003ci class=\"fa-solid fa-circle-plus\" onClick=\"changeQuantity(${good[\"id\"]}, 1)\"\u003e\u003c/i\u003e \u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cbutton class=\"del-btn\" onClick=\"delItem(${good[\"id\"]})\"\u003e删除\u003c/button\u003e`; goodsContainer.appendChild(cartItem); } } 注意到，在上述代码中，我为每一个cart-item添加了一个唯一的id属性，这个属性是用于标识每一个商品的，这样我们在之后的操作中可以通过这个id属性来找到对应的商品。 关于唯一标识符 在实际的项目中，我们往往需要为每一个商品添加一个唯一的标识符，这个标识符可以是商品的id，也可以是其他的唯一标识符，这样可以更好的操作商品，例如删除商品、修改商品数量等。 过滤错误数据 在实际的项目中，我们往往会遇到一些错误的数据，例如商品数量为负数或者小数、商品价格为负数等，这些数据是不符合实际的，我们需要在获取数据之后对这些数据进行过滤，这样可以保证数据的正确性。 如果数据量比较大，我们也会选择使用filter方法来过滤数据。 图片加载失败时 在实际的项目中，我们往往会遇到一些图片加载失败的情况，这时候我们可以通过onerror事件来监听图片加载失败的情况，然后通过一些方法来处理这种情况，例如显示一个默认图片、显示一个提示信息等。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:1","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#数据获取与渲染"},{"categories":["在前端搬砖的日子里"],"content":" 改变商品数量修改商品数量是通过点击+和-按钮来实现的，我们可以通过onClick事件来监听这两个按钮的点击事件，然后通过changeQuantity函数来改变商品的数量。 在修改商品数量的时候，我们需要注意一些边界条件，例如商品数量不能为负数，商品数量不能超过库存（本篇的demo没有考虑这个库存上限）等，考虑到加操作和减操作的逻辑是一样的，我们可以通过传入一个参数来判断是加还是减，以减少代码的重复。 以下是我的changeQuantity函数： const changeQuantity = (id, cnt) =\u003e { const item = document.querySelector('#item-' + id); const count = item.querySelector('.count span'); const price = item.querySelector('.tot-price'); const quantity = parseInt(count.innerHTML); if (quantity + cnt \u003c= 0) { delItem(id); return; } count.innerHTML = quantity + cnt; price.innerHTML = (parseFloat(price.innerHTML) + cnt * goods.find(good =\u003e good[\"id\"] === id)[\"price\"]).toFixed(2); // 这里应该发送请求修改数据，这里只是模拟，直接修改 goods = goods.map(good =\u003e { if (good[\"id\"] === id) { good[\"quantity\"] = quantity + cnt; } return good; }); if (curSelectGoods.find(good =\u003e good[\"id\"] === id)) { selectTotal += cnt; curSelectGoods = curSelectGoods.map(good =\u003e { if (good[\"id\"] === id) { good[\"price\"] = parseFloat(price.innerHTML); } return good; }); updateTotalCount(); // 更新总价 } } ","date":"2024-07-06","objectID":"/posts/testcart/:1:2","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#改变商品数量"},{"categories":["在前端搬砖的日子里"],"content":" 删除商品删除商品是通过点击删除按钮来实现的，我们可以通过onClick事件来监听删除按钮的点击事件，然后通过delItem函数来删除商品。 在删除商品的时候，我们需要注意一些边界条件，例如删除商品后本页购物车为空，或者删除商品后购物车的商品数量减少等。 以下是我的delItem函数： const delItem = (id) =\u003e { const item = document.querySelector('#item-' + id); item.remove(); // 这里应该发送请求删除数据，这里只是模拟，直接删除 goods = goods.filter(good =\u003e good[\"id\"] !== id); renderCartList(); if (curSelectGoods.find(good =\u003e good[\"id\"] === id)) { selectTotal -= parseInt(item.querySelector('.count span').innerHTML); curSelectGoods = curSelectGoods.filter(good =\u003e good[\"id\"] !== id); updateTotalCount(); } } ","date":"2024-07-06","objectID":"/posts/testcart/:1:3","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#删除商品"},{"categories":["在前端搬砖的日子里"],"content":" 选中商品选中商品可以分为两种情况：全选和单选。全选的状态会影响到单选的状态，单选的状态也会影响到全选的状态，在考虑全选和单选的逻辑的时候，我们需要多角度考虑。 在对单个商品进行选中的时候，我们可以通过onClick事件来监听单选按钮的点击事件，然后通过selectGood函数来选中商品，选中商品时，我们要考虑的有：选中商品的总价、选中商品的数量、全选按钮的状态等。 以下是我的selectGood函数： const selectGood = (id) =\u003e { const item = document.querySelector('#item-' + id); const checkbox = item.querySelector('input[type=\"checkbox\"]'); const price = item.querySelector('.tot-price'); const quantity = item.querySelector('.count span'); if(checkbox.checked) { selectTotal += parseInt(quantity.innerHTML); curSelectGoods.push({ id: id, price: parseFloat(price.innerHTML) }); updateTotalCount(); } else { selectTotal -= parseInt(quantity.innerHTML); curSelectGoods = curSelectGoods.filter(good =\u003e good[\"id\"] !== id); updateTotalCount(); } if(curSelectGoods.length === goods.length) { selectAllStatus = true; const selectAll = document.querySelector('#select-all'); const icon = selectAll.querySelector('i'); icon.classList.remove('fa-regular'); icon.classList.add('fa-solid'); } else { selectAllStatus = false; const selectAll = document.querySelector('#select-all'); const icon = selectAll.querySelector('i'); icon.classList.remove('fa-solid'); icon.classList.add('fa-regular'); } } 在全选的时候，我们可以通过通过selectAll函数来全选商品，全选商品时，我们要考虑的有：选中商品的总价、选中商品的数量、单选按钮的状态等。 以下是我的selectAll函数： const setSelectAll = () =\u003e { const selectAll = document.querySelector('#select-all'); selectAll.addEventListener('click', () =\u003e { const items = document.querySelectorAll('.cart-item'); if (!selectAllStatus) { selectTotal = 0; curSelectGoods = []; for (let i = 0; i \u003c items.length; i++) { const item = items[i]; item.querySelector('input[type=\"checkbox\"]').checked = true; selectTotal += parseInt(item.querySelector('.count span').innerHTML); curSelectGoods.push({ id: parseInt(item.getAttribute('id').split('-')[1]), price: parseFloat(item.querySelector('.tot-price').innerHTML) }); } const icon = selectAll.querySelector('i'); icon.classList.remove('fa-regular'); icon.classList.add('fa-solid'); } else { for (let i = 0; i \u003c items.length; i++) { items[i].querySelector('input[type=\"checkbox\"]').checked = false; } selectTotal = 0; curSelectGoods = []; const icon = selectAll.querySelector('i'); icon.classList.remove('fa-solid'); icon.classList.add('fa-regular'); } updateTotalCount(); selectAllStatus = !selectAllStatus; }); } ","date":"2024-07-06","objectID":"/posts/testcart/:1:4","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#选中商品"},{"categories":["在前端搬砖的日子里"],"content":" 更新总价我们在结算的时候需要计算当前选中的商品的总价，这个总价依赖于选中的商品数量和价格，我们可以通过updateTotalCount函数来更新总价，并在需要的时候调用这个函数。 以下是我的updateTotalCount函数： const updateTotalCount = () =\u003e { const curSelectBox = document.querySelector('#cur-select'); if (selectTotal) { curSelectBox.innerHTML = selectTotal; } else { curSelectBox.innerHTML = 0; } const totPriceBox = document.querySelector('#sum'); if (curSelectGoods.length) { totPriceBox.innerHTML = curSelectGoods.reduce((acc, cur) =\u003e acc + cur[\"price\"], 0).toFixed(2); } else { totPriceBox.innerHTML = 0; } } ","date":"2024-07-06","objectID":"/posts/testcart/:1:5","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#更新总价"},{"categories":["在前端搬砖的日子里"],"content":" 分页设计分页是通过点击页码来切换商品列表的，我们可以通过onClick事件来监听页码的点击事件，然后通过changePage函数来切换商品列表。 标准的分页设计中，每次点击页码时，我们都会重新请求数据，然后重新渲染页面，这样可以保证数据的实时性，这里我只是模拟了这个过程，实际的项目中，我们会通过后端来获取数据。 由于总页数是不确定的，所以我们依然是通过全局变量来保存当前的页码和总页数，并且在切换页码的时候，我们需要考虑一些边界条件，例如页码不能为负数，页码不能超过总页数等。 以下是我的initPagnation和changePagnation函数： const changePage = (e) =\u003e { changePagnation(e.target.innerHTML); // 按照正常的分页逻辑，这里应该重新请求数据，这里只是模拟，所以直接取数据 changeCartList(); } const initPagnation = () =\u003e { const pagination = document.querySelector('#pagination'); pagination.innerHTML = ''; for (let i = 0; i \u003c= totPages + 1; i++) { if (i === 0) { const prev = document.createElement('i'); prev.classList.add('fa-solid', 'fa-chevron-left', 'page-prev'); if (curPage === 1) { prev.disabled = true; } prev.addEventListener('click', () =\u003e { if (curPage \u003e 1) { changePagnation(curPage - 1); } }); pagination.appendChild(prev); continue; } else if (i === totPages + 1) { const next = document.createElement('i'); next.classList.add('fa-solid', 'fa-chevron-right', 'page-next'); if (curPage === totPages) { next.disabled = true; } next.addEventListener('click', () =\u003e { if (curPage \u003c totPages) { changePagnation(curPage + 1); } }); pagination.appendChild(next); continue; } const page = document.createElement('div'); page.innerHTML = i; page.classList.add('page'); if (i === curPage) { page.classList.add('active-page'); } page.addEventListener('click', changePage); pagination.appendChild(page); } } const changePagnation = (pageNo) =\u003e { const page = document.querySelector('.active-page'); page.classList.remove('active-page'); const pageArr = document.querySelectorAll('.page'); curPage = parseInt(pageNo); pageArr[curPage - 1].classList.add('active-page'); changeCartList(); } 我这里的分页设计的比较简单，一共只根据json数据设计了5页，在实际项目中，分页的数目是不确定，而且有可能非常多，在设计分页功能的时候，最好的方法是增加一个...按钮，点击这个按钮可以展开更多的页码，以及增加一个跳转按钮，可以跳转到指定的页码，方便用户查找。 ","date":"2024-07-06","objectID":"/posts/testcart/:1:6","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#分页设计"},{"categories":["在前端搬砖的日子里"],"content":" 结算结算逻辑比较简单，依然是考虑为空等边界条件。 以下是我的setPay函数： const setPay = () =\u003e { const payBtn = document.querySelector('#pay'); payBtn.addEventListener('click', () =\u003e { if (curSelectGoods.length === 0) { alert('请选择商品后结算'); return; } // 这里应该发送请求支付，这里只是模拟，直接删除 goods = goods.filter(good =\u003e !curSelectGoods.find(select =\u003e select[\"id\"] === good[\"id\"])); curSelectGoods = []; selectTotal = 0; updateTotalCount(); if (goods.length === 0) { initGoods(); } else { renderCartList(); } alert('支付成功'); }); } ","date":"2024-07-06","objectID":"/posts/testcart/:1:7","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#结算"},{"categories":["在前端搬砖的日子里"],"content":" 消息提示框在删除商品、结算商品等行为后，我们可以通过一个弹出提示框来与用户进行确认交互，并且可以自定义消息弹出框的类型，这样可以提高用户体验。 以下是我的alert函数： const alert = (msg, type) =\u003e { const alertBox = document.createElement('div'); alertBox.classList.add('alert-box'); alertBox.innerHTML = msg; if (type === 'success') { alertBox.classList.add('alert-success'); } else if (type === 'error') { alertBox.classList.add('alert-error'); } document.body.appendChild(alertBox); setTimeout(() =\u003e { alertBox.style.display = 'none'; }, 2000); } {/* 结合上面的支付函数就可以写成下面这样 */} const setPay = () =\u003e { const payBtn = document.querySelector('#pay'); payBtn.addEventListener('click', () =\u003e { if (curSelectGoods.length === 0) { alert('请选择商品后结算', 'error'); return; } // 这里应该发送请求支付，这里只是模拟，直接删除 goods = goods.filter(good =\u003e !curSelectGoods.find(select =\u003e select[\"id\"] === good[\"id\"])); curSelectGoods = []; selectTotal = 0; updateTotalCount(); if (goods.length === 0) { initGoods(); } else { renderCartList(); } alert('支付成功', 'success'); }); } ","date":"2024-07-06","objectID":"/posts/testcart/:2:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#消息提示框"},{"categories":["在前端搬砖的日子里"],"content":" 查找功能在本项目中，一页只有6个商品，感觉查找功能不是很必要，不过假如在一些项目中，一页有很多商品，比如不是基于分页获取数据，而是一次性获取所有数据或者是利用瀑布流加载数据，这时候查找功能就显得很重要了。 查找功能的实现其实就是一个filter，我们设计一个简单的搜索功能： const setSearch = () =\u003e { // 回车搜索 const searchInput = document.querySelector('#search-input'); searchInput.addEventListener('keydown', (e) =\u003e { if (e.keyCode === 13) { search(); } }); } const search = () =\u003e { const searchInput = document.querySelector('#search-input'); const keyword = searchInput.value; fetch('cart.json') .then(response =\u003e response.json()) .then(data =\u003e { console.log(data); goods = data.pages[curPage - 1][\"items\"].filter(good =\u003e good[\"name\"].includes(keyword)); renderCartList(); } ); } 搜索框的设计 \u003cdiv class=\"search-bar\"\u003e \u003cinput type=\"text\" placeholder=\"Search\" id=\"search-input\"\u003e \u003c/div\u003e .search-bar { height: 40px; display: flex; width: 100%; max-width: 400px; padding-left: 16px; input { width: 100%; height: 100%; border: none; outline: none; background-color: var(--search-bg); border-radius: 4px; font-family: var(--body-font); font-size: 15px; font-weight: 500; \u0026::placeholder { font-family: var(--body-font); color: var(--inactive-color); font-size: 15px; font-weight: 500; } } } 这样我们就可以通过输入关键字来查找商品了。 ","date":"2024-07-06","objectID":"/posts/testcart/:3:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#查找功能"},{"categories":["在前端搬砖的日子里"],"content":" 仓库地址这个项目的源码我已经上传到我的gitee上，大家可以自行下载，地址在这里：https://gitee.com/florae00/bluemsun2024。 ","date":"2024-07-06","objectID":"/posts/testcart/:4:0","series":[],"tags":["前端"],"title":"购物车页面制作教程（包含分页设计）","uri":"/posts/testcart/#仓库地址"},{"categories":["我们需要更多的鱼"],"content":" 前言本篇记录利用github action实现自动化构建和部署的过程。 本站除了部署在github page上，还部署在本人的服务器上，懒惰的ddl直到现在才去上手实验，因此利用在github action中实现两种部署方式。 ","date":"2024-07-05","objectID":"/posts/github_action/:1:0","series":[],"tags":["Github Action","CI/CD"],"title":"Github Action实践","uri":"/posts/github_action/#前言"},{"categories":["我们需要更多的鱼"],"content":" Github ActionGithub Action是Github提供的持续集成服务，可以在代码仓库中配置workflow，实现自动化构建、测试、部署等功能。 有一些术语需要了解： Workflow：一个workflow由一个或多个job组成，可以在不同的操作系统环境中运行。 Job：一个job由一系列step组成，可以在同一个runner上运行。 Step：一个step由一个或多个action组成，可以在同一个runner上运行。 Action：一个action是一个独立的任务，可以在不同的runner上运行。 ","date":"2024-07-05","objectID":"/posts/github_action/:2:0","series":[],"tags":["Github Action","CI/CD"],"title":"Github Action实践","uri":"/posts/github_action/#github-action"},{"categories":["我们需要更多的鱼"],"content":" 配置这里我使用的是github action自带的SSH Deploy action，使用ssh链接远程服务器，将代码部署到服务器上。使用方法可以参考这里。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:0","series":[],"tags":["Github Action","CI/CD"],"title":"Github Action实践","uri":"/posts/github_action/#配置"},{"categories":["我们需要更多的鱼"],"content":" 1. 创建SSH Key并添加到github secrets首先需要在服务器上生成一个SSH Key，用于github action登录服务器。 ssh-keygen -m PEM -t rsa -b 4096 key的生成过程中会提示输入密码，可以不输入，直接回车，默认保存在/root/.ssh目录下（这个可能不同的服务器环境会有区别，具体的默认位置在生成ssh-key的时候命令行有提示。 生成的key包含一个私钥id_rsa和一个公钥id_rsa.pub，私钥保存在本地，我们需要将公钥添加到服务器的/root/.ssh/authorized_keys文件中。 cat ./id_rsa.pub \u003e\u003e /root/.ssh/authorized_keys 考虑到我们并不想把私钥暴露在github公开仓库上，我们需要将私钥id_rsa添加到github的secrets中。 在仓库的Settings-\u003eSecurity-\u003eSecrets and variables-\u003eActions中，选择New repository secret，添加一个SSH_PRIVATE_KEY，将私钥内容粘贴进去。 再新建三个secrets，分别是REMOTE_HOST、REMOTE_USER、REMOTE_TARGET，分别对应服务器的地址、用户名、目标路径。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:1","series":[],"tags":["Github Action","CI/CD"],"title":"Github Action实践","uri":"/posts/github_action/#1-创建ssh-key并添加到github-secrets"},{"categories":["我们需要更多的鱼"],"content":" 2. 创建workflow在代码仓库的.github/workflows目录下创建一个.yml文件，文件名可以自定义，如deploy.yml。 一个库可以有多个workflow，github只要发现.github/workflows目录下有.yml文件，就会自动运行workflow。 内容可以参考如下： name: Deploy # 触发条件 on: push: branches: [ main ] workflow_dispatch: # 手动触发 jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install Node.js uses: actions/setup-node@v3 with: node-version: '16.x' - name: ssh deploy uses: easingthemes/ssh-deploy@v5.0.3 with: SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }} ARGS: \"-rlgoDzvc -i\" SOURCE: \"\" REMOTE_HOST: ${{ secrets.REMOTE_HOST }} REMOTE_USER: ${{ secrets.REMOTE_USER }} TARGET: ${{ secrets.REMOTE_TARGET }} 向github仓库push代码之后，我们在Actions选项卡中可以看到workflow的运行情况。假如运行失败，可以点进去查看具体的错误信息，进行调试。 之后每次push到main分支或者手动触发workflow，github action就会自动运行workflow，将代码部署到服务器上。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:2","series":[],"tags":["Github Action","CI/CD"],"title":"Github Action实践","uri":"/posts/github_action/#2-创建workflow"},{"categories":["在学算法的日子里"],"content":" 阿巴阿巴 啊，省赛，怎么两个月过去了才整理题解，这一定是在复习（确信 GYM地址：2024吉林省赛 题目顺序按照从易到难排序。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:0:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#"},{"categories":["在学算法的日子里"],"content":" I. The Easiest Problem","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#i-the-easiest-problem"},{"categories":["在学算法的日子里"],"content":" 题意数一数 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:1","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve() { string s = \"Scan the QR code to sign in now.\"; ll cnt = 0; for (auto c : s) { if (c \u003c= 'z' \u0026\u0026 c \u003e= 'a')cnt++; } cout \u003c\u003c cnt \u003c\u003c endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; // cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:2","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码"},{"categories":["在学算法的日子里"],"content":" L. Recharge","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#l-recharge"},{"categories":["在学算法的日子里"],"content":" 题意有$x$次获得$1$格能量的机会，$y$次获得$2$格能量的机会，充满一个电池需要$k$格能量，溢出的能量会被浪费，问最多能充满多少电池。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:1","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve() { ll k, x, y;cin \u003e\u003e k \u003e\u003e x \u003e\u003e y; if (k == 1) { cout \u003c\u003c x + y \u003c\u003c \"\\n\";return; } ll ans = 0; if (k \u0026 1) { ll yi = k / 2; if (x \u003c= y / yi) { ans += x; y -= x * yi; x = 0; ans += y / (yi + 1); } else { ans += y / yi; x -= (y / yi); y -= (y / yi) * yi; if (y * 2 + x \u003e= k) { ans += 1;x -= (k - 2 * y);y = 0; } ans += x / k; } } else { ll tot = x + 2 * y; ans = tot / k; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:2","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-1"},{"categories":["在学算法的日子里"],"content":" G. Platform Game","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#g-platform-game"},{"categories":["在学算法的日子里"],"content":" 题意在二维平面中有$n$个平台，每个平台有一个高度$h_i$，以及一个左端点$l_i$和右端点$r_i$。机器人从$(x,y)$出发，保持向右前进，如果遇到平台端点则会垂直下落，问机器人最终的落点。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:1","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-2"},{"categories":["在学算法的日子里"],"content":" 思路排序题，按照高度从高到低、左端点从小到大排序，遍历平台，如果机器人在平台上则更新机器人的位置。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:2","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct PLAT { ll l, r, y; operator\u003c(const PLAT\u0026 P)const { if (y == P.y)return l \u003c P.l; return y \u003e P.y; } }; void solve() { ll n;cin \u003e\u003e n; vector\u003cPLAT\u003eplats; for (ll i = 0;i \u003c n;i++) { ll l, r, y;cin \u003e\u003e l \u003e\u003e r \u003e\u003e y; plats.push_back({ l,r,y }); } sort(plats.begin(), plats.end()); ll sx, sy;cin \u003e\u003e sx \u003e\u003e sy; for (auto p : plats) { if (p.l \u003c sx \u0026\u0026 p.r \u003e= sx \u0026\u0026 p.y \u003c sy) { sy = p.y; sx = p.r; } } cout \u003c\u003c sx \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:3","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-2"},{"categories":["在学算法的日子里"],"content":" D. Parallel Lines","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#d-parallel-lines"},{"categories":["在学算法的日子里"],"content":" 题意二维平面上有$k$条平行线，这些直线上有$n$个点，已知每条直线上至少有$2$个点。现在给出$n$个点，找出这$k$条平行线（用点表示）。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:1","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-3"},{"categories":["在学算法的日子里"],"content":" 数据范围$2 \\leq n \\leq 10^4$ $1 \\leq k \\leq \\min(50, \\frac{n}{2})$ ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:2","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路注意$k$的范围，$k$最多为$50$，可以枚举$k$来选择平行线的斜率，对于$k$条平行线，当我选择了$k+1$个点时，这$k+1$个点中必然至少有两个点之间的斜率是$k$条平行线的斜率。 确定斜率$k_i$之后，我们分别计算过每个点斜率为$k_i$的直线在$y$轴上的截距，并计数相同截距的点的数目，注意垂直于$x$轴的情况。 只有同时符产生截距数目恰好为$k$，且每个截距的点数目至少为$2$时，我们才找到了所要的$k$条平行线。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:3","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; struct Point { ll x, y; }; void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cPoint\u003epoints(n); map\u003cll, vector\u003cll\u003e\u003erx; for (ll i = 0;i \u003c n;i++) { cin \u003e\u003e points[i].x \u003e\u003e points[i].y; rx[points[i].x].push_back(i + 1); } if (rx.size() == k) { bool f = true; for (auto i : rx) { if (i.second.size() \u003c 2) { f = false;break; } } if (f) { for (auto i : rx) { cout \u003c\u003c i.second.size() \u003c\u003c \" \"; for (auto j : i.second) { cout \u003c\u003c j \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return; } } ll b = 1000000; map\u003cll, bool\u003empk; for (ll i = 0;i \u003c k + 1;i++) { for (ll j = i + 1;j \u003c k + 1;j++) { ll px = points[i].x, py = points[i].y, qx = points[j].x, qy = points[j].y; if (px == qx) { continue; } ld ki = 1.0 * (py - qy) / (px - qx); ll kk = (ll)(ki * b); if (mpk.count(kk) == 0)mpk[kk] = true; } } for (auto kk : mpk) { ld ki = 1.0 * kk.first / b; map\u003cll, vector\u003cll\u003e\u003ecnt; for (ll i = 0;i \u003c n;i++) { ll x = points[i].x, y = points[i].y; ld bi = y - ki * x; ll bb = (ll)(bi * b); cnt[bb].push_back(i + 1); if (cnt.size() \u003e k)break; } if (cnt.size() == k) { bool f = true; for (auto i : cnt) { if (i.second.size() \u003c 2) { f = false;break; } } if (!f)continue; for (auto i : cnt) { cout \u003c\u003c i.second.size() \u003c\u003c \" \"; for (auto j : i.second) { cout \u003c\u003c j \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return; } } } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:4","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-3"},{"categories":["在学算法的日子里"],"content":" E. Connected Components","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:0","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#e-connected-components"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个王国，编号从$1$到$n$，每个王国有两个属性值$a_i$和$b_i$，如果两个王国的属性值满足$a_i - a_j \\leq i - j \\leq b_i - b_j$或$a_j - a_i \\leq j - i \\leq b_j - b_i$，则这两个王国是相连的。问有多少个连通块。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:1","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-4"},{"categories":["在学算法的日子里"],"content":" 数据范围$1 \\leq n \\leq 10^6$ ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:2","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:3","series":[],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路-2"},{"categories":["在学习计算机系统的日子里"],"content":"记录CS-APP Datalab实验过程","date":"2024-07-04","objectID":"/posts/datalab/","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/"},{"categories":["在学习计算机系统的日子里"],"content":" 0. before start实验需要的材料在这里：CSAPP Datalab 将datalab-handout.tar下载复制到计划用来实验的目录下，解压： tar xvf datalab-handout.tar 解压之后，可以看到文件中包含这些： 其中bit.c是包含13个编程题中每个题的骨架。实验要求是使用没有任何循环或条件语句，以及有限的c算术和逻辑运算符来完成其中每个函数的内容，只能使用如下8个运算符： ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e ","date":"2024-07-04","objectID":"/posts/datalab/:1:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#0-before-start"},{"categories":["在学习计算机系统的日子里"],"content":" 测评在btest文件夹中，包含了一个测试程序，可以用来测试我们的实现是否正确。我们可以通过make命令编译btest，然后运行： # 编译并运行 make \u0026\u0026 ./btest # 对某个函数进行单元测试 make \u0026\u0026 ./btest -f bitXnor # 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推 make \u0026\u0026 ./btest -f bitXnor -1 7 -2 0xf dlc：用于检查我们的实现是否符合实验要求： ./dlc bits.c 接下来，按照难度从易到难，我们依次完成实验 ","date":"2024-07-04","objectID":"/posts/datalab/:1:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#测评"},{"categories":["在学习计算机系统的日子里"],"content":" 1. bitXor异或等价于不是同0且不是同1。 ","date":"2024-07-04","objectID":"/posts/datalab/:2:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#1-bitxor"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~x\u0026~y)\u0026~(x\u0026y); } ","date":"2024-07-04","objectID":"/posts/datalab/:2:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码"},{"categories":["在学习计算机系统的日子里"],"content":" 2. tmin获得对2补码的最小int值。在C中，int是32位的，所以补码的最小值就是符号位为1，其余位为0的值，对0x1左移31位即可。 ","date":"2024-07-04","objectID":"/posts/datalab/:3:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#2-tmin"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } ","date":"2024-07-04","objectID":"/posts/datalab/:3:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-1"},{"categories":["在学习计算机系统的日子里"],"content":" 3. isTmax判断$x$是否是int的最大整数。最大整数tmax应该为0x7fffffff。 题目提示不允许使用移位操作。 注意到： $$ Tmax=0x7fffffff,Tmin=0x80000000\\\\ so,that:Tmax=\\sim Tmin,Tmax+1 = Tmin\\\\ -Tmin = \\sim Tmin + 1 = Tmax + 1 = Tmin\\\\ so,that:\\\\ -(\\sim Tmax) = Tmax + 1 = \\sim Tmax\\\\ $$ 也就是说，假如~x的相反数与~x相等，则满足x=Tmax。 注意除了Tmax拥有这个性质，当x=-1时： $$ x=0xffffffff\\\\ \\sim x=0x00000000\\\\ -(\\sim x)=\\sim (\\sim x)+1 = x+1 = 0x00000000 $$ 也满足这个上述特点，需要排除。 ","date":"2024-07-04","objectID":"/posts/datalab/:4:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#3-istmax"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !!(~x)\u0026!((~x)^(x+1)); } 提示 注意返回值是int型的，所以需要使用!!将结果转换为0或1。 ","date":"2024-07-04","objectID":"/posts/datalab/:4:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-2"},{"categories":["在学习计算机系统的日子里"],"content":" 4. allOddBits当$x$中所有奇数位都为$1$时返回true。 奇数位都为$1$的数形如： $$ x=0b1x_{30}1x_{28}1…1x_{2}1x_{0} $$ 思路是构造偶数位都为$1$的掩码0x55555555，再与$x$按位取或，若能构造出0xffffffff则复合要求。 由于实验要求不允许使用长度超过8位的常量，所以通过移位操作来构造掩码。 ","date":"2024-07-04","objectID":"/posts/datalab/:5:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#4-alloddbits"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int mask = 0x55 + (0x55 \u003c\u003c 8); mask = mask + (mask \u003c\u003c 16); return !(~(mask | x)); } ","date":"2024-07-04","objectID":"/posts/datalab/:5:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-3"},{"categories":["在学习计算机系统的日子里"],"content":" 5. negate返回$x$的相反数。 这个操作在第三个实验里其实已经使用过了。 $$ -x=\\sim x + 1 $$ ","date":"2024-07-04","objectID":"/posts/datalab/:6:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#5-negate"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:6:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-4"},{"categories":["在学习计算机系统的日子里"],"content":" 6. isAsciDigit判断$x$是否是ASCII码0~9中的某一个，即判断$0x30\\leq x\\leq 0x39$。 注意到$0x30\\sim 0x39$的低4位从$0000\\sim 1001$，低5~8位为$0011$，可以分别判断。 在满足低5~8位为$0011$的前提下，若倒数第4位为0则符合要求，若倒数第4位为1则需判断是否为$1000$或$1001$，即中间2位是否是0。 ","date":"2024-07-04","objectID":"/posts/datalab/:7:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#6-isascidigit"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isAsciiDigit - return 1 if 0x30 \u003c= x \u003c= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { int f3 = !((x \u003e\u003e 4) ^ 3); int f0t9 =!! (!(x \u0026 8) + !(x \u0026 6)); return f3 \u0026 f0t9; } ","date":"2024-07-04","objectID":"/posts/datalab/:7:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-5"},{"categories":["在学习计算机系统的日子里"],"content":" 7. conditional实现出w =( x ? y : z)的条件判断。 感觉在上个题就实现了，上题相当于对一个二进制数$x=x_4 x_3 x_2 x_1$，是否满足$(x_4 == 1)?(x \u0026 6 == 0):1$。 判断$x$通过!!x获得0/1，再通过按位取反+1分别获得0x00000000和0xffffffff，再与$y$和$z$按位或并相加，获得结果。 ","date":"2024-07-04","objectID":"/posts/datalab/:8:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#7-conditional"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { int f = !!x; int mask = ~f + 1; return (y \u0026 mask) + (z \u0026 ~mask); } ","date":"2024-07-04","objectID":"/posts/datalab/:8:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-6"},{"categories":["在学习计算机系统的日子里"],"content":" 8. isLessOrEqual判断是否符合$x\\leq y$的关系。 首先比较符号位，若符号位相同，则判断$x-y\\leq 0$是否成立。减号可以由按位取反+1获得相反数，再相加实现。 ","date":"2024-07-04","objectID":"/posts/datalab/:9:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#8-islessorequal"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int fx = x \u003e\u003e 31; int fy = y \u003e\u003e 31; int f = fx ^ fy; int z = x + ~y + 1; return !!((f \u0026 fx) | ((!f) \u0026 ((!z) | z \u003e\u003e 31))); } ","date":"2024-07-04","objectID":"/posts/datalab/:9:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-7"},{"categories":["在学习计算机系统的日子里"],"content":" 9. logicalNeg实现逻辑取反，$x$非0返回0，$x$为0返回1。 通过取反+1获得相反数，如果x是0，其相反数与x拥有相同的符号位0，否则在x和其相反数两个数之间一定会有至少一个符号位为1。 在Tmin = 0x80000000中也一致，-Tmin = ~Tmin + 1 = 0x7fffffff + 1 = 0x80000000。 ","date":"2024-07-04","objectID":"/posts/datalab/:10:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#9-logicalneg"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { return (((~x + 1) | x) \u003e\u003e 31) + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:10:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-8"},{"categories":["在学习计算机系统的日子里"],"content":" 10. howManyBits计算出表示$x$​需要的最少补码位数。 $$ 0=0b0,1bit\\\\ 1=0b01,2bits\\\\ -1=0b1,1bit\\\\ 2=0b010,3bits\\\\ -2=0b10,2bits\\\\ 3=0b011,3bits\\\\ -3=0b101,3bits $$ 如果是正数的话x补码形如：0x00001...，所需补码位数是从左向右第一个1的位置在+1（符号位），负数的话x补码形如：0x11110...，取反之后是0x00001...，所需位数是从左向右第一个1的位置+1。 不能通过循环来从左向右找，尝试二分找第一个1的位置。 int型有32位，逐渐二分为16、8、4、2、1位。 $$ \\begin{aligned} \u0026x = 0b0001,1…,….,….,….,….,….,….\\\\ loop1:\u0026 !!(x»16)=1,b16=16\\\\ \u0026\\text{高16位存在1，则可以舍去低16位，将x右移16位}\\\\ \u0026x = x»16=0b0001,1…,…,…\\\\ loop2:\u0026… \\end{aligned} $$ 最后统计完毕之后要+1符号位。 ","date":"2024-07-04","objectID":"/posts/datalab/:11:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#10-howmanybits"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { int f = !!(x \u003e\u003e 31); f = ~f + 1; x = (x \u0026 ~f) + (~x \u0026 f); int b16 = (!!(x \u003e\u003e 16)) \u003c\u003c 4; x = x \u003e\u003e b16; int b8 = (!!(x \u003e\u003e 8)) \u003c\u003c 3; x = x \u003e\u003e b8; int b4 = (!!(x \u003e\u003e 4)) \u003c\u003c 2; x = x \u003e\u003e b4; int b2 = (!!(x \u003e\u003e 2)) \u003c\u003c 1; x = x \u003e\u003e b2; int b1 = !!(x \u003e\u003e 1); x = x \u003e\u003e b1; return b16 + b8 + b4 + b2 + b1 + x + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:11:1","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-9"},{"categories":["在学习计算机系统的日子里"],"content":" 11. floatScale2","date":"2024-07-04","objectID":"/posts/datalab/:12:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#11-floatscale2"},{"categories":["在学习计算机系统的日子里"],"content":" 12. floatFloat2Int","date":"2024-07-04","objectID":"/posts/datalab/:13:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#12-floatfloat2int"},{"categories":["在学习计算机系统的日子里"],"content":" 13. floatPower2","date":"2024-07-04","objectID":"/posts/datalab/:14:0","series":[],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#13-floatpower2"},{"categories":[],"content":" 更新日志 2024.7.4 计划有变，换成DoIt主题，正在优化搬运中… 2024.7.3 更换主题为LoveIt，正在优化搬运中… 评论区支持上传图片功能，但是请勿上传违规图片，否则会被删除。 已设置评论回复邮件提醒，欢迎留言哦~ 2023.11.28 建站，初次上传 ","date":"2024-07-04","objectID":"/comments/:0:0","series":[],"tags":[],"title":"留言板","uri":"/comments/#更新日志"},{"categories":[],"content":" 留言板 ","date":"2024-07-04","objectID":"/comments/:0:0","series":[],"tags":[],"title":"留言板","uri":"/comments/#留言板"},{"categories":[],"content":"友链 挂挂","date":"2024-07-04","objectID":"/links/","series":[],"tags":[],"title":"友達です！","uri":"/links/"},{"categories":[],"content":" 友人 思想犯 一个活的相对失败的 CSer Windlinxy 测试岗牛马的失败生活 DODOLA-github.io ddlの初始域名自链接 CCLMSY💫 Never forget nor regret.⭐️ YorkWu's Blog ddl:一个很强的学长QwQ！！ 无双 ddl:是很强的陈老师！ Roses NENU 唯一懂 C++ 的人 Echo 的小窝 漂泊于互联网中的小窝 KAMIASUKA’s Blog Patience is key in life 幻雪的博客 腐烂于花海，致死于所爱 UTTN 我要当长毛文艺b ✨️✨️ 本站友链信息： name: DODOLA url: https://dodolalorc.cn/ avatar: https://dodolalorc.cn/img/dodola.png bio: Wit beyond measure is man’s greatest treasure. ✨️✨️ 申请友链信息格式： name: #名称 url: #链接 avatar: #头像 bio: #站点描述 ","date":"2024-07-04","objectID":"/links/:1:0","series":[],"tags":[],"title":"友達です！","uri":"/links/#友人"},{"categories":[],"content":" 🎇🎇 友链申请要求 QwQ🎉 本站支持交换友链，在您提出申请之前，请将本站添加至友链 🏵️ 为了保障本站用户，本站仅支持个人网站的友链申请 🍧 申请本站友链需要拥有独立域名（非免费域名），建议开启全站 HTTPS 💐 友链中的链接信息需要保证可以正常访问哦 🍖 站内文章能持续更新，没有太多广告 🎴 感谢您对本站的支持，如果您已经满足上述要求，请在下方评论区提交友链申请~~~ ","date":"2024-07-04","objectID":"/links/:1:1","series":[],"tags":[],"title":"友達です！","uri":"/links/#-友链申请要求-qwq"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 一篇学习 MutationObserver 的文章 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:0:0","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 背景今天调整新主题的时候，在重新设计友链样式的时候想保留原本的随机背景颜色，之前数量少的时候似乎不太明显，现在本地测试发觉加载太慢了。于是上网寻找解决思路，找到了 MutationObserver 这个 API，于是就学习了一下//此处记录一下学习过程。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:1:0","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#背景"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 需求分析我有不知数量的div元素，每个div元素都有一个class名为friend-link-div，我需要在每个单个的div元素被加载完成的同时，对它设置一个随机的背景颜色。而不是等待整个页面或窗口加载完毕 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:2:0","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#需求分析"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 想法分析","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:0","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#想法分析"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" window.onload和'DOMContentLoaded'的问题原本的实现代码： window.onload=function () { const randomHex = () =\u003e `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 0.5)`; var friendArr=document.getElementsByClassName(\"friend-div\"),temp=[]; for(var i=0;i\u003cfriendArr.length;i++){ friendArr[i].style.background=randomHex(); } } 原本的思路就是简单的在页面加载完成后，获取所有的友链元素，然后给每个元素设置一个随机的背景颜色。但是这样的实现方式有一个问题，就是当友链数量较多的时候，会导致页面加载变慢，因为每次都要重新计算随机颜色，并且在等待本页面加载的时候，友链的背景颜色是白色的，这样会导致页面的视觉体验不好。 在网上询问得到的另一个思路是用document.addEventListener('DOMContentLoaded', function() {})，但是这个方法也是等待整个页面加载完毕后才会执行，观察发现还是挺慢的…所以也不适合。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:1","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#windowonload和domcontentloaded的问题"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 仅利用CSS实现随机色彩的思路还有一个仅利用CSS实现随机色彩的思路，该思路是在CSS中定义一个颜色数组，然后通过nth-child选择器来实现，但是这样的实现方式有一个问题，就是颜色的数量是固定的，而且颜色的选择是有规律的，不是真正的随机颜色。 不过还是展示一下如何伪随机实现： .friend-link-div:nth-child(1) { background: #f00; } .friend-link-div:nth-child(2) { background: #0f0; } .friend-link-div:nth-child(3) { background: #00f; } .friend-link-div:nth-child(4) { background: #ff0; } ... 搭配scss的话可以这样写： $colors: #f00, #0f0, #00f, #ff0, #f0f, #0ff, #000, #fff; @for $i from 1 through length($colors) { .friend-link-div:nth-child(#{$i}) { background: nth($colors, $i); } } 于是放弃window.onload和'DOMContentLoaded'，以及CSS的伪随机实现方法。改用 MutationObserver 来实现。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:2","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#仅利用css实现随机色彩的思路"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 解决思路使用MutationObserver API来观察DOM的变化，并在新的盒子被添加到DOM中时应用背景色更改。这样，每当有新的盒子被添加到页面上时，你就可以立即更改它的背景，而不需要等待其他内容加载完成。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:0","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#解决思路"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 代码 // 定义一个生成随机背景色的函数 const randomHex = () =\u003e `rgba(${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, 0.5)`; // 遍历所有已经存在的盒子，为每个盒子设置随机背景色 document.querySelectorAll('.friend-link-div').forEach(div =\u003e { div.style.background = randomHex(); }); // 定义一个回调函数，用于处理每当DOM树中添加新节点时的操作 const callback = function (mutationsList, observer) { for (const mutation of mutationsList) { if (mutation.type === 'childList' \u0026\u0026 mutation.addedNodes.length \u003e 0) { mutation.addedNodes.forEach(node =\u003e { // 检查是否为目标盒子节点 if (node.nodeType === 1 \u0026\u0026 node.classList.contains('friend-link-div')) { // 更改背景色 node.style.background = randomHex(); } }); } } }; // 创建MutationObserver实例 const observer = new MutationObserver(callback); // 配置观察选项：观察子节点的添加 const config = { childList: true, subtree: true }; // 选择要观察变化的DOM节点（在这个例子中，是body，但你可以根据需要更改） const targetNode = document.body; // 启动观察 observer.observe(targetNode, config); ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:1","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#代码"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 关于用于hugo主题的一些Tips有的时候DOM初始化时已经存在一些盒子，因此我们需要在初始化时为这些盒子设置随机背景色。然后，我们创建一个MutationObserver实例，并配置它以观察DOM树中的子节点添加。最后，我们选择要观察变化的DOM节点（在这个例子中是body，但你可以根据需要更改），并启动观察。 假如直接将js插入到friend.html中，打开控制台会发现该段js被渲染了好多次，这是因为hugo的模板渲染机制导致的，所以我们需要将js放在整个大页面的js中，这样就不会出现重复渲染的问题了。 一个合适的地方是在layouts/partials/footer.html中，这样就可以保证在整个页面加载完毯后再执行这段js。 不过直接放在footer.html中也会有一个问题，就是我们只需要在友链页面加载这段js，而不是每个页面都加载，所以我们可以在footer.html中加入一个判断条件，判断当前页面是否是友链页面，如果是则加载这段js。 可以在content/links.md中加入一个isLink字段，然后在footer.html中判断是否为友链页面，如果是则加载这段js。 {{ if .Params.isLink }} \u003cscript\u003e // 代码 \u003c/script\u003e {{ end }} 假如不想每次都把新增的js直接写在footer.html等地方中，可以在static/js/文件夹下新建一个js文件，然后在footer.html中引入这个js文件。 {{ if .Params.isLink }} \u003cscript src=\"/js/_extended/friend-link.js\"\u003e\u003c/script\u003e {{ end }} 另注：githubPage是jekyll模板似乎不能识别下划线开头的文件，所以有需要的话可以把_extended改成其他名字。 完成！现在，每当新的friend-link-div盒子被添加到DOM中时，它的背景颜色将立即更改为随机颜色。 可以在本站的友链页面查看效果：友链 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:2","series":[],"tags":[],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#关于用于hugo主题的一些tips"},{"categories":["关于Hugo的一些设置"],"content":" 一篇私有配置图床，给twikoo评论插件添加图片功能的文章。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:0:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#"},{"categories":["关于Hugo的一些设置"],"content":" 背景背景：最近回想起来本站的twikoo评论尚未配置过图床，所以此前评论区不能上传图片，这篇就记录一下twikoo官方推荐的lsky-pro私有部署图床。 选用的图床是兰空图床👉lsky-org/lsky-pro: ☁️兰空图床(Lsky Pro) - Your photo album on the cloud. (github.com) 文档：Lsky Pro 服务器环境： 宝塔面板 8.0.6 PHP 8.0.26 MySQL 5.7.43 Nginx 1.22.1 要注意版本哦( ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:1:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#背景"},{"categories":["关于Hugo的一些设置"],"content":" 添加站点进入宝塔后，在左侧网站导航页内点击添加站点，新建一个网站，配置如图： ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:2:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#添加站点"},{"categories":["关于Hugo的一些设置"],"content":" 配置站点在Releases · lsky-org/lsky-pro (github.com)选择Assets中的第一个.zip下载下来。定位到上述创建的站点的根目录(/www/wwwroot/img.dodolalorc.cn)下，将解压后的文件放在该目录下。 将程序所在目录的所有文件夹、子文件夹、文件的权限，用户组和所有者改为 www，权限改为 0755 回到网站导航页，点击刚刚创建的站点，进行如下修改： 网站目录下，将网站目录中的路径后添加/public，并保存 Nginx需要设置伪静态，点击伪静态，添加如下代码并保存： location / { try_files $uri $uri/ /index.php?$query_string; } 在SSL中，申请Let's Encrypt证书，申请成功并安装保存之后，在证书页开启强制HTTPS ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:3:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#配置站点"},{"categories":["关于Hugo的一些设置"],"content":" PHP扩展+禁用函数根据文档所提示的安装要求，我们需要添加两个扩展：Fileinfo PHP 扩展和Imagick 拓展。 在宝塔软件商店内搜索使用的PHP，点击管理，在安装扩展中选择下载fileinfo和imagemagick扩展。 在禁用函数页面，删除exec、shell_exec、readlink、symlink、putenv、getenv、chmod、chown、fileperms 函数。 若由于可用内存小于1G，没有安装上fileinfo，可以在软件商店搜索找到Linux工具箱，在工具箱中的Swap/虚拟内存中添加Swap，设置为1024MB并确定，重试即可。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:4:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#php扩展禁用函数"},{"categories":["关于Hugo的一些设置"],"content":" 安装程序在完成上述内容后，访问站点，显示符合要求之后，点击下一步，填写配置后进行安装。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:5:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#安装程序"},{"categories":["关于Hugo的一些设置"],"content":" 获取token在站点的仪表盘页，点击接口，复制接口URL。 在这个网站Getman.cn，按照这个格式填写： { \"email\": \"管理员邮箱\", \"password\":\"管理员密码\" } ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:6:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#获取token"},{"categories":["关于Hugo的一些设置"],"content":" 配置Twikoo获取到token后，在twikoo管理页，IMAGE_CDN 配置图床首页 URL 地址（注意不要加尾随斜杠），IMAGE_CDN_TOKEN填入刚刚获取的token。 保存后，即可上传图片。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:7:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#配置twikoo"},{"categories":["在前端搬砖的日子里"],"content":" Vue3+Vite+Svg以前使用Svg的时候会图简单直接将内容巨长的Svg代码粘贴在项目中，结果导致需要用Svg图标的部分代码巨长，今天写项目又需要使用Svg了，于是想着对其进行封装。 ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:0:0","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#vue3vitesvg"},{"categories":["在前端搬砖的日子里"],"content":" 插件安装使用vite-plugin-svg-icons插件。 安装： npm i vite-plugin-svg-icons -D 在src/assets/下新建icon文件夹，这个文件夹下存放我们以后要用的.svg文件。 ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:0","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#插件安装"},{"categories":["在前端搬砖的日子里"],"content":" 配置vite.config.ts import {createSvgIconsPlugin} from 'vite-plugin-svg-icons'; export default defineConfig({ //... plugins:[ //... createSvgIconsPlugin({ iconDirs:[ // 自己的svg存放目录 path.resolve(process.cwd(),'src/assets/icon'), ], symbolId:'icon-[name]', // 设置symbol的id }) ] }) ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:1","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#配置viteconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 在main.ts中加入： import 'virtual:svg-icons-register'; ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:2","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#在maints中加入"},{"categories":["在前端搬砖的日子里"],"content":" 封装SvgIcon组件在src/components/新建SvgIcon文件夹，在其中新建index.vue，内容： \u003cscript lang=\"ts\" setup\u003e const props = defineProps({ name: { type: String, required: true }, color: { type: String, default: '#ccc' }, width: { type: String, default: '1em' }, height: { type: String, default: '1em' }, }); const symbleId = `#icon-${props.name}`; \u003c/script\u003e \u003ctemplate\u003e \u003csvg aria-hidden=\"true\" class=\"svg-icon\" :width=\"width\" :height=\"height\"\u003e \u003cuse :xlink:href=\"symbleId\" :fill=\"color\" /\u003e \u003c/svg\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 之后就能在页面使用svg啦。 \u003ctemplate\u003e \u003cSvgIcon name=\"dashboard\" color=\"red\" width=\"50px\" height=\"50px\"/\u003e \u003c/template\u003e ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:3","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#封装svgicon组件"},{"categories":["在学算法的日子里"],"content":" 线段树介绍 线段树是一棵二叉树，每个节点维护一个区间内$[l,r]$的信息 左子树区间维护$[l,\\lfloor \\frac{l+r}{2} \\rfloor]$的信息，右子树维护$[\\lfloor \\frac{l+r}{2} \\rfloor+1,r]$的信息 节点信息可以由两个子节点合并得到 任意一个区间会被分为线段树上$O(\\log n)$个节点 线段树可以在$O(\\log N)$的时间复杂度内实现单点修改、区间修改、**区间查询（区间求和/区间最大值/区间最小值）**等操作。 线段树一般解决类似这样的问题： 已知一个数列，你需要进行下面几种操作： 将某区间每一个数加上 $k$。（修改） 求出某区间每一个数的和。（查询） 将某区间的每个数修改为$x$。（修改） 求某区间的最大值/最小值。（查询） ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:0","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树介绍"},{"categories":["在学算法的日子里"],"content":" 建树 实现递归实现 struct segTreeNode { ll d = 0ll, lazy = 0ll; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); // 左边 build(m + 1, r, (p \u003c\u003c 1) | 1); // 右边 tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#建树"},{"categories":["在学算法的日子里"],"content":" 建树 实现递归实现 struct segTreeNode { ll d = 0ll, lazy = 0ll; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); // 左边 build(m + 1, r, (p \u003c\u003c 1) | 1); // 右边 tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现"},{"categories":["在学算法的日子里"],"content":" 查询\u0026修改\u0026求值","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:0","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#查询修改求值"},{"categories":["在学算法的日子里"],"content":" 区间查询进行区间查询的时候，区间和节点区间的关系有三种可能： 当前要查询的区间与正在询问的区间没有交集，返回空 当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值 当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况 实现 ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#区间查询"},{"categories":["在学算法的日子里"],"content":" 区间查询进行区间查询的时候，区间和节点区间的关系有三种可能： 当前要查询的区间与正在询问的区间没有交集，返回空 当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值 当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况 实现 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-1"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (cr\u003cl || cl\u003er)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (cr\u003cl || cl\u003er)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#区间修改懒标记"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-2"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#参考"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#思考"},{"categories":["在学算法的日子里"],"content":" 例题1（两种懒标记）P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 操作 1： 格式：1 x y k 含义：将区间$[x,y]$内每个数乘上k 操作 2： 格式：2 x y k 含义：将区间$[x,y]$ 内每个数加上k 操作 3： 格式：3 x y 含义：输出区间 $[x,y]$ 内每个数的和对m取模所得的结果 这题需要考虑两种修改值的操作之间的相互影响。 每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递 判断时应该先乘后加 参考 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板2：实现区间加+乘、求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazyPlus, lazyTime; /*TIP:在开结构体vector时已有初始值会使所有初始值塞入程序，会导致编译时间过长+内存溢出*/ bool used; // 标记是否修改过 }; ll mo; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { tree[p].lazyTime = 1ll; if (l == r) { tree[p].d = a[l] % mo; return; } int mid = l + ((r - l) \u003e\u003e 1); build(l, mid, p \u003c\u003c 1); build(mid + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void pd(int cl, int cr, int p) { int l = p \u003c\u003c 1; int r = (p \u003c\u003c 1) | 1; // 先乘后加 if (tree[p].lazyTime != 1ll) { tree[l].lazyTime *= tree[p].lazyTime; tree[r].lazyTime *= tree[p].lazyTime; tree[l].lazyTime %= mo; tree[r].lazyTime %= mo; // 对子节点懒标记乘 tree[l].lazyPlus *= tree[p].lazyTime; tree[r].lazyPlus *= tree[p].lazyTime; tree[l].lazyPlus %= mo; tree[r].lazyPlus %= mo; // 对子节点数值乘 tree[l].d *= tree[p].lazyTime; tree[r].d *= tree[p].lazyTime; tree[l].d %= mo; tree[r].d %= mo; tree[p].lazyTime = 1ll; } int mid = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazyPlus) { tree[l].d += tree[p].lazyPlus * (mid - cl + 1); tree[l].d %= mo; tree[r].d += tree[p].lazyPlus * (cr - mid); tree[r].d %= mo; tree[l].lazyPlus += tree[p].lazyPlus; tree[l].lazyPlus %= mo; tree[r].lazyPlus += tree[p].lazyPlus; tree[r].lazyPlus %= mo; tree[p].lazyPlus = 0ll; } } void updateTime(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都乘上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].lazyTime *= x; tree[p].lazyTime %= mo; tree[p].lazyPlus *= x; tree[p].lazyPlus %= mo; tree[p].d *= x; tree[p].d %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updateTime(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updateTime(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].d %= mo; tree[p].lazyPlus += x; tree[p].lazyPlus %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updatePlus(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int mid = cl + ((cr - cl) \u003e\u003e 1); pd(cl, cr, p); ll sum = 0ll; if (mid \u003e= l) sum += getsum(l, r, cl, mid, p \u003c\u003c 1); sum %= mo; if (mid \u003c r) sum += getsum(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1); return sum % mo; } void solve() { int n, q;cin \u003e\u003e n \u003e\u003e q \u003e\u003e mo; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (q--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updateTime(x, y, 1, n, 1, k); } else if (op == 2) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updatePlus(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:3","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#例题1两种懒标记"},{"categories":["在学算法的日子里"],"content":" 例题1（两种懒标记）P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 操作 1： 格式：1 x y k 含义：将区间$[x,y]$内每个数乘上k 操作 2： 格式：2 x y k 含义：将区间$[x,y]$ 内每个数加上k 操作 3： 格式：3 x y 含义：输出区间 $[x,y]$ 内每个数的和对m取模所得的结果 这题需要考虑两种修改值的操作之间的相互影响。 每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递 判断时应该先乘后加 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板2：实现区间加+乘、求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazyPlus, lazyTime; /*TIP:在开结构体vector时已有初始值会使所有初始值塞入程序，会导致编译时间过长+内存溢出*/ bool used; // 标记是否修改过 }; ll mo; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { tree[p].lazyTime = 1ll; if (l == r) { tree[p].d = a[l] % mo; return; } int mid = l + ((r - l) \u003e\u003e 1); build(l, mid, p \u003c\u003c 1); build(mid + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void pd(int cl, int cr, int p) { int l = p \u003c\u003c 1; int r = (p \u003c\u003c 1) | 1; // 先乘后加 if (tree[p].lazyTime != 1ll) { tree[l].lazyTime *= tree[p].lazyTime; tree[r].lazyTime *= tree[p].lazyTime; tree[l].lazyTime %= mo; tree[r].lazyTime %= mo; // 对子节点懒标记乘 tree[l].lazyPlus *= tree[p].lazyTime; tree[r].lazyPlus *= tree[p].lazyTime; tree[l].lazyPlus %= mo; tree[r].lazyPlus %= mo; // 对子节点数值乘 tree[l].d *= tree[p].lazyTime; tree[r].d *= tree[p].lazyTime; tree[l].d %= mo; tree[r].d %= mo; tree[p].lazyTime = 1ll; } int mid = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazyPlus) { tree[l].d += tree[p].lazyPlus * (mid - cl + 1); tree[l].d %= mo; tree[r].d += tree[p].lazyPlus * (cr - mid); tree[r].d %= mo; tree[l].lazyPlus += tree[p].lazyPlus; tree[l].lazyPlus %= mo; tree[r].lazyPlus += tree[p].lazyPlus; tree[r].lazyPlus %= mo; tree[p].lazyPlus = 0ll; } } void updateTime(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都乘上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].lazyTime *= x; tree[p].lazyTime %= mo; tree[p].lazyPlus *= x; tree[p].lazyPlus %= mo; tree[p].d *= x; tree[p].d %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updateTime(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updateTime(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].d %= mo; tree[p].lazyPlus += x; tree[p].lazyPlus %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updatePlus(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int mid = cl + ((cr - cl) \u003e\u003e 1); pd(cl, cr, p); ll sum = 0ll; if (mid \u003e= l) sum += getsum(l, r, cl, mid, p \u003c\u003c 1); sum %= mo; if (mid \u003c r) sum += getsum(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1); return sum % mo; } void solve() { int n, q;cin \u003e\u003e n \u003e\u003e q \u003e\u003e mo; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (q--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updateTime(x, y, 1, n, 1, k); } else if (op == 2) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updatePlus(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:3","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#参考-1"},{"categories":["在学算法的日子里"],"content":" 动态开点一般来说，线段树处理的范围在$[1,n]$，$n$一般是$1e5$的大小。 如果我们想处理负数的范围，或者是$n$达到$1e9$的数量级时，我们就需要可以动态开点的线段树。 线段树我们一般开到$4n$的大小是充足的，为了节省空间以及直接建立全树的时间，我们也可以对线段树动态开点，也就是只有当我们需要用到某些节点的时候，才去创造它。 比如，我们已经一个节点表示$[11,16]$的相关数据，我们需要修改$[13,15]$上的信息，我们就创造$[11,13]$和$[14,16]$的节点，并继续递归创建节点，直到这个线段树可以完全表示到已被修改的信息。 ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:3:0","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#动态开点"},{"categories":["在学算法的日子里"],"content":" 实现 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxv = 8e6; // 一般有多大开多大 /* 线段树模板3：动态开点技巧 */ struct segTreeNode { ll d, lazy; int lson, rson; // 记录左右子的下标 }; vector\u003csegTreeNode\u003etree(maxv); int tot = 1; // 总节点数 void update(int cl, int cr, int\u0026 p, ll addnum) { if (!p)p = ++tot; tree[p].d += addnum * (cr - cl + 1); tree[p].lazy += addnum; } void pushdown(int p, int cl, int cr) { // 节点p没有左右子时给它开点。 if (cr - cl + 1 \u003c= 1)return; int mid = (cr + cl - 1) \u003e\u003e 1; update(cl, mid, tree[p].lson, tree[p].lazy); update(mid + 1, cr, tree[p].rson, tree[p].lazy); tree[p].lazy = 0; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]里每个数加x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += x * (cr - cl + 1); tree[p].lazy += x; return; } pushdown(p, cl, cr); int mid = (cl + cr - 1) \u003e\u003e 1; if (mid \u003e= l)updatePlus(l, r, cl, mid, tree[p].lson, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, tree[p].rson, x); int ls = tree[p].lson, rs = tree[p].rs; tree[p].d = tree[ls].d + tree[rs].d; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; pushdown(p, cl, cr); int mid = (cl + cr - 1) / 2; // 可以处理区间两端是负数的情况 ll sum = 0ll; sum += getsum(l, r, cl, mid, tree[p].lson); sum += getsum(l, r, mid + 1, cr, tree[p].rson); return sum; } void solve() { ll n, q;cin \u003e\u003e n \u003e\u003e q; while (q--) { ll l, r, k;cin \u003e\u003e l \u003e\u003e r \u003e\u003e k; if(k==1){} } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:3:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-3"},{"categories":["在学算法的日子里"],"content":" 线段树合并与分裂","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:0","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树合并与分裂"},{"categories":["在学算法的日子里"],"content":" 线段树合并线段树合并通过递归实现，需要有合并操作的线段树需要使用动态开点的技巧。 将线段树a和b合并，从1号点开始递归，若递归到某个节点为空，直接返回另一个树上的对应节点；若递归到叶子节点，我们合并两棵树上的对应节点。 void pushup(int a) { int ls = tree[a].lson, rs = tree[a].rson; tree[a].d = tree[ls].d + tree[rs].d; } int merge(int a, int b, int l, int r) { if (!a)return b; if (!b)return a; if (l == r) { // do sth return a; } int mid = (l + r) \u003e\u003e 1; tree[a].lson = merge(tree[a].lson, tree[b].lson, l, mid); tree[a].rson = merge(tree[a].rson, tree[b].rson, mid + 1, r); pushup(a); return a; } 模板题：[P4556 Vani有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:1","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树合并"},{"categories":["在学算法的日子里"],"content":" 线段树分裂线段树分裂是线段树合并的逆过程。 线段树分裂只适用于有序的序列，无序的序列是没有意义的，常用在动态开点的权值线段树上。 当分裂和合并都存在时，要注意回收节点，以免分裂时会出现节点重复/占用的问题。 当$[s,t]$与$[l,r]$有交集时开新节点 当$[s,t]$包含于$[l,r]$时，直接将当前节点接到新的树下面，把旧边断开。 void pushup(int a) { int ls = tree[a].lson, rs = tree[a].rson; tree[a].d = tree[ls].d + tree[rs].d; } void split(int\u0026 p, int\u0026 q, int s, int t, int l, int r) { // 从[s,t]的线段树中分裂出区间是[l,r]的线段树 if (t \u003c l || r \u003c s) return; if (!p) return; if (l \u003c= s \u0026\u0026 t \u003c= r) { q = p; p = 0; return; } if (!q) q = ++tot; int m = s + t \u003e\u003e 1; if (l \u003c= m) split(tree[p].lson, tree[p].rson, s, m, l, r); if (m \u003c r) split(tree[p].lson, tree[p].rson, m + 1, t, l, r); pushup(p); pushup(q); } 模板题：P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:2","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树分裂"},{"categories":["在学算法的日子里"],"content":" 练习题一览一些模板题/测测你的板子(! P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Problem - 5306 (hdu.edu.cn) [P4556 Vani有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P4097 【模板】李超线段树 / HEOI2013] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3391 【模板】文艺平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:5:0","series":null,"tags":["算法","数据结构","模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#练习题一览"},{"categories":["在学算法的日子里"],"content":" A-Shuffle Party","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#a-shuffle-party"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，起初是$a_i=i$ 对操作swap(k)： 设$d$是不等于$k$本身的$k$的最大除数，然后交换元素$a_d$和$a_k$。 按顺序对每一个$i=2,3,..,n$进行$swap(i)$之后，找出$1$在数组中的位置。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，起初是$a_i=i$ 对操作swap(k)： 设$d$是不等于$k$本身的$k$的最大除数，然后交换元素$a_d$和$a_k$。 按顺序对每一个$i=2,3,..,n$进行$swap(i)$之后，找出$1$在数组中的位置。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路简单模拟之后可以发现，$a_1=1$最后会挪到不大于$n$的最大2的次幂处。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { vector\u003cll\u003ep; ll x = 1; while (x \u003c= 1e9) { p.push_back(x); x *= 2; } int t;cin \u003e\u003e t; while(t--){ ll n;cin \u003e\u003e n; ll ans = upper_bound(p.begin(), p.end(), n) - p.begin(); cout \u003c\u003c p[ans - 1] \u003c\u003c endl; } } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Binary Path","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#b-binary-path"},{"categories":["在学算法的日子里"],"content":" 题意一个$2\\times n$网格，网格充满$0,1$，找一条从$(1,1)$走到$(2,n)$的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤2\\times 10^5)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意一个$2\\times n$网格，网格充满$0,1$，找一条从$(1,1)$走到$(2,n)$的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤2\\times 10^5)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路路径的组成是第一行的前部分+第二行的后部分，长度是$n+1$。对从第一行到第二行的转折的位置进行枚举，假设往后一位可以获得字典序更小的则重新计数，若相同则累计路径数，若不同则代表没有更好的路径。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cstring\u003es(2); cin \u003e\u003e s[0] \u003e\u003e s[1]; string st = s[0] + s[1]; ll cnt = 1; ll ix = 2; for (int i = 2;i + n - 2 \u003c 2 * n - 1;i++) { ll j = i + n - 2;//[i,j] if (st[i - 1] == '0' \u0026\u0026 st[j] == '1') { cnt = 1; ix = i; } else if (st[i - 1] == st[j]) { cnt++; } else { break; } } string res = st.substr(0, ix) + st.substr(ix + n - 1); string res1 = s[0][0] + s[1]; if (res1 \u003c res)res = res1; cout \u003c\u003c res \u003c\u003c '\\n'; cout \u003c\u003c cnt \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Bitwise Operation Wizard","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#c-bitwise-operation-wizard"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 对一个神秘序列$p_0,p_1,…,p_{n-1}$（是${0,1,…,n-1}$的排列组合）。我们通过询问需要获得$p_i\\oplus p_j$最大的一个$(i,j)$对。 每次询问任意索引$(a,b,c,d)$评审团计算$x=(p_a|p_b)$和$y=(p_c|p_d)$，并告知是$x\\lt y,x\\gt y$还是$x=y$。最多使用$3n$个查询。 数据范围$t(1≤t≤1000)$ $n(2≤n≤10^4)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 对一个神秘序列$p_0,p_1,…,p_{n-1}$（是${0,1,…,n-1}$的排列组合）。我们通过询问需要获得$p_i\\oplus p_j$最大的一个$(i,j)$对。 每次询问任意索引$(a,b,c,d)$评审团计算$x=(p_a|p_b)$和$y=(p_c|p_d)$，并告知是$x\\lt y,x\\gt y$还是$x=y$。最多使用$3n$个查询。 数据范围$t(1≤t≤1000)$ $n(2≤n≤10^4)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路先两两比较找到最大的数，再找到与最大的数异或的结果最大的另一个数。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 char r; char ask(int a, int b, int c, int d) { cout \u003c\u003c \"? \" \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ' \u003c\u003c d \u003c\u003c endl; cin \u003e\u003e r; return r; } void solve() { int n;cin \u003e\u003e n; int pm = 0; // 找n-1 for (int i = 1;i \u003c n;i++) { if (ask(pm, pm, i, i) == '\u003c') { pm = i; } } // 另一个数pn：与pm取或大于pm的最小值 int pn = 0; for (int i = 1;i \u003c n;i++) { ask(pm, i, pm, pn); if (r == '\u003e') { pn = i; } else if (r == '=' \u0026\u0026 ask(i, i, pn, pn) == '\u003c') { pn = i; } } cout \u003c\u003c \"! \" \u003c\u003c pm \u003c\u003c \" \" \u003c\u003c pn \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Too Min Too Max","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#a-too-min-too-max"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，找到索引$(i,j,k,l)$使得$|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|$最大的值。 数据范围$t(1≤t≤500)$ $n(4≤n≤100)$​ $a_i(-10^6\\le a_i\\le 10^6)$ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，找到索引$(i,j,k,l)$使得$|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|$最大的值。 数据范围$t(1≤t≤500)$ $n(4≤n≤100)$​ $a_i(-10^6\\le a_i\\le 10^6)$ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路选则最大的两个数和最小的两个数，结果为最大-最小+次大-最小+最大-次小+次大-次小。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) cin \u003e\u003e a[i]; sort(a.begin(), a.end()); cout \u003c\u003c a[n - 1] - a[0] + a[n - 2] - a[0] + a[n - 1] - a[1] + a[n - 2] - a[1] \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Yet Another Coin Problem","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#b-yet-another-coin-problem"},{"categories":["在学算法的日子里"],"content":" 题意有一些5种不同面值的金币，面值有：$1,3,6,10,15$。找到使用金币数目最少的组合方式达到数值为$n$的组合。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有一些5种不同面值的金币，面值有：$1,3,6,10,15$。找到使用金币数目最少的组合方式达到数值为$n$的组合。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路打表。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ep = { 0, 1,2,1,2,3,1,2,3,2,1, 2,2,2,3,1,2,3,2,3,2, 2,3,3,3,2,3,3,3,4,2 }; ll ans = n / 15 + p[n % 15]; if (n / 15 \u003e 0) ans = min(ans, n / 15 - 1 + p[n % 15 + 15]); cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Find a Mine","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#c-find-a-mine"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 $n\\times m$的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。 数据范围$t(1≤t≤3\\times 10^3)$ $n,m (2≤n≤10^8,2\\le m\\le 10^8)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 $n\\times m$的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。 数据范围$t(1≤t≤3\\times 10^3)$ $n,m (2≤n≤10^8,2\\le m\\le 10^8)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路第一次询问可以获得一条斜线，斜线上至少有一个地雷。 第二次询问可能可以找到正好一个交点，这个交点可能正好是地雷或者是两个地雷的行列序号的组合。再做第三次询问，得到两个交点至少有一个是地雷。第四次询问即可排除。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 bool f = false; int ask(int x, int y) { cout \u003c\u003c \"? \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; int res;cin \u003e\u003e res; if (res == 0) { cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; f = true; } return res; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; f = false; int x1 = ask(1, 1); if (f) { return; } int x2 = ask(1, m); if (f) { return; } int x3 = ask(n, 1); if (f) { return; } int x, y; if (x2 + x3 == n + m - 2) { // 同一条斜线 y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; return; } else if ((n + m - x2 - x3) % 2 != 0) { // 有一个交点 if ((x1 + x2 - m + 1) % 2 == 0) { x = (x1 + x2 - m + 1) / 2; y = x1 - x; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; } else { y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } return; } y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; if (x \u003c 1 || x \u003e n || y \u003c 1 || y \u003e m) { f = true; } if (!f) { int x4 = ask(x, y); if (f) { return; } } x = (x1 + x2 - m + 1) / 2; y = x1 - x; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Entertainment in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#a-entertainment-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个字符串进行两种操作： 将字符串反转 将该字符串反转后接在原串的后面。 可以进行任意次上述操作，获得字典序最小的字符串。 数据范围$t(1≤t≤500)$ $n(2≤n≤10^9)$​ $s(1\\le |s|\\le 100)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个字符串进行两种操作： 将字符串反转 将该字符串反转后接在原串的后面。 可以进行任意次上述操作，获得字典序最小的字符串。 数据范围$t(1≤t≤500)$ $n(2≤n≤10^9)$​ $s(1\\le |s|\\le 100)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路对比反转前后的字符串字典序大小，再决定是操作1还是操作2 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; string s;cin \u003e\u003e s; string t = s; reverse(t.begin(), t.end()); if (s \u003e t) { cout \u003c\u003c t \u003c\u003c s \u003c\u003c endl; } else { cout \u003c\u003c s \u003c\u003c endl; } } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Informatics in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#b-informatics-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意$MEX$：不属于该数组的最小非负整数。 对一个数组分成$k$个子段，要求每段的$MEX$都等于相同的数。 找到这样的子段分法，或者报告不存在合法的分法。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$​ $a_i(0\\le a_i\\lt n)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意$MEX$：不属于该数组的最小非负整数。 对一个数组分成$k$个子段，要求每段的$MEX$都等于相同的数。 找到这样的子段分法，或者报告不存在合法的分法。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$​ $a_i(0\\le a_i\\lt n)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路假设$MEX=2$，则分成$k$段的方式为前$k-1$段只要都出现过$0,1$就进行分段，最后一段保证含$0,1$和达到第$n$个数。 确定$MEX$：遍历数组$a$，找到最小的没有出现过的数（该数不大于$n$），该数即为$MEX$。 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 // MEX:不属于该数组的最小非负整数 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); vector\u003cbool\u003eck(n + 1, false); for (int i = 1;i \u003c= n;i++) { ll x;cin \u003e\u003e x; a[i] = x; ck[x] = true; } bool f = false; int y = -1; for (int i = 0;i \u003c n;i++) { if (ck[i] == false) { y = i; f = true; break; } } if (!f) { cout \u003c\u003c -1 \u003c\u003c endl; return; } // MEX=y // cout \u003c\u003c y \u003c\u003c endl; if (y == 0) { cout \u003c\u003c n \u003c\u003c endl; for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c i \u003c\u003c endl; } return; } int p = 1; int cnt = 0; vector\u003cpair\u003cint, int\u003e\u003eans; vector\u003cbool\u003ehs(y, false); vector\u003cbool\u003ehsf(y, false); for (int i = 1;i \u003c= n;i++) { if (a[i] \u003c y \u0026\u0026 !hs[a[i]]) { hs[a[i]] = true; cnt++; } if (cnt == y) { ans.push_back({ p, i }); p = i + 1; cnt = 0; // 会不会Tle hs = hsf; } } if (ans.size() == 1) { cout \u003c\u003c -1 \u003c\u003c endl; return; } cout \u003c\u003c ans.size() \u003c\u003c endl; for (int i = 0;i \u003c ans.size();i++) { if (i != ans.size() - 1) cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c ans[i].second \u003c\u003c endl; else { cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c n \u003c\u003c endl; } } } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" D-Exam in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#d-exam-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意有一个集合$s$。 找到满足$0\\le x\\le y\\le c$且$x+y$和$y-x$均不包含在集合$s$中的整数对$(x,y)$的个数。 数据范围$t(1≤t≤2\\times 10^4)$ $n(1≤n≤3\\times 10^5)$​ $c(1\\le c\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个集合$s$。 找到满足$0\\le x\\le y\\le c$且$x+y$和$y-x$均不包含在集合$s$中的整数对$(x,y)$的个数。 数据范围$t(1≤t≤2\\times 10^4)$ $n(1≤n≤3\\times 10^5)$​ $c(1\\le c\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路容斥。 合格的整数对=满足$x+y\\in s$+满足$y-x\\in s$-既满足$x+y\\in s$又满足$y-x\\in s$。 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, c;cin \u003e\u003e n \u003e\u003e c; ll tot = (c + 1) * (c + 2) / 2; ll cnt0 = 0, cnt1 = 0; for (ll i = 0;i \u003c n;i++) { ll x;cin \u003e\u003e x; tot -= x / 2 + 1; tot -= c + 1 - x; if (x \u0026 1)cnt1++; else cnt0++; } tot += (cnt0 + 1) * cnt0 / 2 + cnt1 * (cnt1 + 1) / 2; cout \u003c\u003c tot \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Rudolf and the Ticket","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#a-rudolf-and-the-ticket"},{"categories":["在学算法的日子里"],"content":" 题意左边口袋有一些面值为$b_1,b_2,b_3,…,b_n$的硬币，右边有一些面值为$c_1,c_2,c_3,…,c_m$的硬币，问有多少个$(f,s)$可以使得$b_f+c_s\\le k$成立 数据范围$t(1≤t≤100)$ $n,m(1≤n,m≤100)$ $k(1\\le k\\le 2000)$ $b_i,c_i(1\\le b_i,c_i\\le 1000)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意左边口袋有一些面值为$b_1,b_2,b_3,…,b_n$的硬币，右边有一些面值为$c_1,c_2,c_3,…,c_m$的硬币，问有多少个$(f,s)$可以使得$b_f+c_s\\le k$成立 数据范围$t(1≤t≤100)$ $n,m(1≤n,m≤100)$ $k(1\\le k\\le 2000)$ $b_i,c_i(1\\le b_i,c_i\\le 1000)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路双层循环遍历 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, k;cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; vector\u003cll\u003eb(n), c(m); for (ll i = 0; i \u003c n; i++) cin \u003e\u003e b[i]; for (ll i = 0; i \u003c m; i++) cin \u003e\u003e c[i]; ll ans = 0; sort(b.begin(), b.end()); sort(c.begin(), c.end()); for (ll i = 0;i \u003c n;i++) { for (ll j = 0;j \u003c m;j++) { if (b[i] + c[j] \u003c= k) { ans++; } else { break; } } } cout\u003c\u003cans\u003c\u003cendl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Rudolf and 121","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#b-rudolf-and-121"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个数组执行如下操作： 选中一个索引$i(2\\le i\\le n-1)$： $a_{i-1}=a_{i-1}-1$ $a_i=a_i-2$ $a_{i+1}=a_{i+1}-1$​ 询问是否可以通过这个运算使得所有元素变为0 数据范围$t(1≤t≤10^4)$ $n(3≤n≤2\\times 10^5)$​ $a_i(0\\leq a_i\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个数组执行如下操作： 选中一个索引$i(2\\le i\\le n-1)$： $a_{i-1}=a_{i-1}-1$ $a_i=a_i-2$ $a_{i+1}=a_{i+1}-1$​ 询问是否可以通过这个运算使得所有元素变为0 数据范围$t(1≤t≤10^4)$ $n(3≤n≤2\\times 10^5)$​ $a_i(0\\leq a_i\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路从左向右遍历，若有大于0的数则对其进行置零，且更新其后一位和两位的数值，直到出现负数或无法执行为止。检查操作后的$a$数组是否符合要求 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (ll i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } for (ll i = 0;i \u003c n;i++) { if (a[i] \u003c 0) { cout \u003c\u003c \"NO\\n\"; return; } if (a[i] \u003e 0) { if(i+2\u003cn){ a[i + 1] -= 2 * a[i]; a[i + 2] -= a[i]; a[i] = 0; } else { cout \u003c\u003c \"NO\\n\";return; } } } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Rudolf and the Ugly String","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#c-rudolf-and-the-ugly-string"},{"categories":["在学算法的日子里"],"content":" 题意对字符串$s$，询问至少需要多少次删除字符的操作可以使得字符串中没有子段$map$和$pie$。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^6)$​ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意对字符串$s$，询问至少需要多少次删除字符的操作可以使得字符串中没有子段$map$和$pie$。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^6)$​ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路先查询子段$mapie$的数量，并删去字符$p$，再对剩下的字符串中存在的$map$和$pie$进行计数。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int p = s.find(\"mapie\"); ll cnt = 0; while (p != -1) { s[p + 2] = 'x'; p = s.find(\"mapie\", p + 1); cnt++; } p = s.find(\"map\"); while (p != -1) { s[p + 2] = 'x'; p = s.find(\"map\", p + 1); cnt++; } p = s.find(\"pie\"); while (p != -1) { s[p] = 'x'; p = s.find(\"pie\", p + 1); cnt++; } cout \u003c\u003c cnt \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Rudolf and the Ball Game","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#d-rudolf-and-the-ball-game"},{"categories":["在学算法的日子里"],"content":" 题意扔球游戏，$n$个人围成一圈，每次球可以选择顺时针或逆时针传球$r_i(1\\le r_i \\le n-1)$个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤1000,1\\le m\\le 1000)$ $x(1\\le x\\le n)$​ $r_i(1\\le r_i\\le n-1)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意扔球游戏，$n$个人围成一圈，每次球可以选择顺时针或逆时针传球$r_i(1\\le r_i \\le n-1)$个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤1000,1\\le m\\le 1000)$ $x(1\\le x\\le n)$​ $r_i(1\\le r_i\\le n-1)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路按题意模拟即可，每次记录球的所有可能位置，并更新。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, x;cin \u003e\u003e n \u003e\u003e m \u003e\u003e x; set\u003cll\u003exi; xi.insert(x); for (ll i = 0;i \u003c m;i++) { ll r;string c;cin \u003e\u003e r \u003e\u003e c; if (c == \"?\") { set\u003cll\u003eyi; for (auto j : xi) { ll b1 = (j + r) % n, b2 = (j - r + n) % n; if (b1 == 0) b1 = n; if (b2 == 0) b2 = n; yi.insert(b1);yi.insert(b2); } xi = yi; } else if (c == \"1\") { set\u003cll\u003eyi; for (auto j : xi) { ll b1 = (j - r + n) % n; if (b1 == 0) b1 = n; yi.insert(b1); } xi = yi; } else { set\u003cll\u003eyi; for (auto j : xi) { ll b2 = (j + r) % n; if (b2 == 0) b2 = n; yi.insert(b2); } xi = yi; } } cout \u003c\u003c xi.size() \u003c\u003c endl; for (auto i : xi) { cout \u003c\u003c i \u003c\u003c \" \"; }cout \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Rudolf and k Bridges","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#e-rudolf-and-k-bridges"},{"categories":["在学算法的日子里"],"content":" 题意需要在一条河上建桥，每个位置建立桥墩的花费是$a_{i,j}+1$，$a_{i+j}$是到水面的深度。桥要求宽为$k$，任意两个桥墩的距离不能超过$d$，桥的首尾都需要有支架。 数据范围$t(1≤t≤1000)$ $n,k(1≤k\\le n≤100)$​ $m(3\\le m\\le 2\\times 10^5)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意需要在一条河上建桥，每个位置建立桥墩的花费是$a_{i,j}+1$，$a_{i+j}$是到水面的深度。桥要求宽为$k$，任意两个桥墩的距离不能超过$d$，桥的首尾都需要有支架。 数据范围$t(1≤t≤1000)$ $n,k(1≤k\\le n≤100)$​ $m(3\\le m\\le 2\\times 10^5)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路对每一行进行DP，可以获得每一行建桥的最小花费。再对其求前缀和，找到总花费最小的连续$k$段。 进行DP状态转移时，需要优先选中距离不大于$d$的桥墩点中，花费最小的桥墩。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, k, d; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k \u003e\u003e d; vector\u003cvector\u003cll\u003e\u003ea(n, vector\u003cll\u003e(m)); for (ll i = 0;i \u003c n;i++) { for (ll j = 0;j \u003c m;j++) { cin \u003e\u003e a[i][j]; a[i][j] += 1; } } // 每行dp vector\u003cll\u003espd(n, 0); for (ll ni = 0;ni \u003c n;ni++) { vector\u003cll\u003edp(m, 0); for (ll i = 0;i \u003c m;i++) { dp[i] = a[ni][i]; } // 维护前d个值中的最小值 queue\u003cll\u003eq1; deque\u003cll\u003eqmin; q1.push(dp[0]); qmin.push_back(dp[0]); for (ll i = 1;i \u003c m;i++) { if (i == 1) dp[i] += dp[0]; else { ll mn = qmin.front(); dp[i] = mn + dp[i]; } if (q1.size() == d + 1) { if (q1.front() == qmin.front()) { qmin.pop_front(); } q1.pop(); } q1.push(dp[i]); while (!qmin.empty() \u0026\u0026 dp[i] \u003c qmin.back()) { qmin.pop_back(); } qmin.push_back(dp[i]); } spd[ni] = dp[m - 1]; } vector\u003cll\u003esum(n + 1, 0); sum[0] = 0; for (ll i = 1;i \u003c= n;i++) { sum[i] = sum[i - 1] + spd[i - 1]; } ll ans = sum[k]; for (ll i = k;i \u003c= n;i++) { ans = min(ans, sum[i] - sum[i - k]); } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-4"},{"categories":["关于Hugo的一些设置"],"content":"最近研究英文的官方文档发现了HUGO官方给渲染Mermaid提供了思路（!原来Hugo可以支持这种渲染），此处做笔记记录，算作是另一种方式。 上一篇指路： 官方文档指路Diagrams | Hugo (gohugo.io) ","date":"2024-03-10","objectID":"/posts/mermaid_js_2/:0:0","series":null,"tags":["Hugo","Mermaid"],"title":"另一种为hugo渲染Mermaid绘图的方式","uri":"/posts/mermaid_js_2/#"},{"categories":["关于Hugo的一些设置"],"content":" 新建html我们在路径layouts/_default/_markup/下新建render-codeblock-mermaid.html，并在其中填入 \u003cpre class=\"mermaid\"\u003e {{- .Inner | safeHTML }} \u003c/pre\u003e {{ .Page.Store.Set \"hasMermaid\" true }} ","date":"2024-03-10","objectID":"/posts/mermaid_js_2/:1:0","series":null,"tags":["Hugo","Mermaid"],"title":"另一种为hugo渲染Mermaid绘图的方式","uri":"/posts/mermaid_js_2/#新建html"},{"categories":["关于Hugo的一些设置"],"content":" 引入在路径layouts/_default/下的single.html中加入下面部分的代码： {{ if .Store.Get \"hasMermaid\" }} \u003cscript type=\"module\"\u003e import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); \u003c/script\u003e {{ end }} 设置之后应该就可以直接使用渲染啦~（ps:之前的方法依然是有效的 ","date":"2024-03-10","objectID":"/posts/mermaid_js_2/:2:0","series":null,"tags":["Hugo","Mermaid"],"title":"另一种为hugo渲染Mermaid绘图的方式","uri":"/posts/mermaid_js_2/#引入"},{"categories":["在前端搬砖的日子里"],"content":" 创建项目 npm create vite@latest dodola -- --template vue-ts cd dodola npm install npm run dev 转到根目录下后 ","date":"2024-03-10","objectID":"/posts/vuemod/:1:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#创建项目"},{"categories":["在前端搬砖的日子里"],"content":" 规范目录 ├── dist/ └── src/ ├── api │ └── ... // 抽取出API请求 ├── assets/ // 静态资源目录 ├── common/ // 通用类库目录 ├── components/ // 公共组件目录 ├── routers/ // 路由配置目录 ├── store/ // pinia 状态管理目录 ├── index.ts // 导出 store 的地方 ├── home.ts // 模块 └── user.ts // 模块 ├── style/ // 通用 CSS 目录 ├── utils/ // 工具函数目录 ├── views/ // 页面组件目录 ├── App.vue ├── main.ts ├── vite-env.d.ts ├── index.html ├── tsconfig.json // TypeScript 配置文件 ├── vite.config.ts // Vite 配置文件 └── package.json ","date":"2024-03-10","objectID":"/posts/vuemod/:1:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#规范目录"},{"categories":["在前端搬砖的日子里"],"content":" path模板+代理在vite.config.ts中，设置@指向src、服务器启动端口、打包路径、代理等等设置 先进行path模板的安装： npm i @types/node -D 如果需要使用代理的话，可以先下载： npm i @vitejs/plugin-basic-ssl -D 或者这个： npm i vite-plugin-mkcert -D 这两个二选一即可 ","date":"2024-03-10","objectID":"/posts/vuemod/:2:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#path模板代理"},{"categories":["在前端搬砖的日子里"],"content":" 集成工具","date":"2024-03-10","objectID":"/posts/vuemod/:3:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#集成工具"},{"categories":["在前端搬砖的日子里"],"content":" Vue Router 4.x npm i vue-router@4 ","date":"2024-03-10","objectID":"/posts/vuemod/:3:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#vue-router-4x"},{"categories":["在前端搬砖的日子里"],"content":" 集成状态管理工具Pinia npm i pinia ","date":"2024-03-10","objectID":"/posts/vuemod/:3:2","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#集成状态管理工具pinia"},{"categories":["在前端搬砖的日子里"],"content":" Axios npm i axios ","date":"2024-03-10","objectID":"/posts/vuemod/:4:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#axios"},{"categories":["在前端搬砖的日子里"],"content":" CSS预编译器 Stylus/Sass/Less使用CSS预编译器Stylus 安装(按序选择就好) npm i stylus -D # or npm i sass -D npm i less -D ","date":"2024-03-10","objectID":"/posts/vuemod/:4:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#css预编译器-stylussassless"},{"categories":["在前端搬砖的日子里"],"content":" 自动引入插件通过插件 unplugin-vue-components 和 unplugin-auto-import 实现组件自动按需导入（推荐！） npm i @varlet/import-resolver unplugin-vue-components unplugin-auto-import -D ","date":"2024-03-10","objectID":"/posts/vuemod/:5:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#自动引入插件"},{"categories":["在前端搬砖的日子里"],"content":" 移动端适配","date":"2024-03-10","objectID":"/posts/vuemod/:6:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#移动端适配"},{"categories":["在前端搬砖的日子里"],"content":" postcss 插件 npm i postcss-px-to-viewport -D postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } 组件库设计基于 375px 宽度设计稿，推荐使用 postcss 插件将 px 单位转换成 vmin 单位从而实现移动端适配。 在 webpack/vite 项目根路径下创建 postcss.config.js 并做如下配置之后 375px -\u003e 100vmin。 ","date":"2024-03-10","objectID":"/posts/vuemod/:6:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#postcss-插件"},{"categories":["在前端搬砖的日子里"],"content":" 桌面端适配 npm i @varlet/touch-emulator ","date":"2024-03-10","objectID":"/posts/vuemod/:7:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#桌面端适配"},{"categories":["在前端搬砖的日子里"],"content":" 组件库","date":"2024-03-10","objectID":"/posts/vuemod/:8:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#组件库"},{"categories":["在前端搬砖的日子里"],"content":" Element Plus npm install element-plus --save ","date":"2024-03-10","objectID":"/posts/vuemod/:8:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#element-plus"},{"categories":["在前端搬砖的日子里"],"content":" varlet npm i @varlet/ui -S VsCode 插件市场搜索： varlet-vscode-extension。 ","date":"2024-03-10","objectID":"/posts/vuemod/:8:2","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#varlet"},{"categories":["在前端搬砖的日子里"],"content":" Arco.design npm install --save-dev @arco-design/web-vue ","date":"2024-03-10","objectID":"/posts/vuemod/:8:3","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#arcodesign"},{"categories":["在前端搬砖的日子里"],"content":" Naive UI npm i -D naive-ui ","date":"2024-03-10","objectID":"/posts/vuemod/:8:4","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#naive-ui"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#配置文件示例"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#tsconfigjson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#tsconfignodejson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#viteconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#postcssconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#packagejson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#vite-envdts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#maints"},{"categories":["在学算法的日子里"],"content":" 试着用计算机来解决几何问题吧(●’◡’●) ","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#"},{"categories":["在学算法的日子里"],"content":" 前置知识 几何基础 平面直角坐标系 极坐标与极坐标系 向量（向量积） ","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#前置知识"},{"categories":["在学算法的日子里"],"content":" 二维计算几何基础","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#二维计算几何基础"},{"categories":["在学算法的日子里"],"content":" 图形的表示","date":"2024-03-09","objectID":"/posts/geometry/:1:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#图形的表示"},{"categories":["在学算法的日子里"],"content":" 点与线的表示例图： typedef double ld; typedef pair\u003cld, ld\u003e pld; typedef pair\u003cll, ll\u003e pll; struct point { ld x, y; point operator+(const point\u0026 p) const { // 加 return { x + p.x, y + p.y }; } point operator-(const point\u0026 p) const { // 减 return { x - p.x, y - p.y }; } point operator*(const ld p) const { // 数乘 return { x * p, y * p }; } point operator/(const ld p) const { // 除 return { x / p, y / p }; } }; struct line { point s, t; }; point A(1, 0), B(3, 1), delta = B - A; line l(A, B); ","date":"2024-03-09","objectID":"/posts/geometry/:1:1","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#点与线的表示"},{"categories":["在学算法的日子里"],"content":" 距离与旋转例图： ld sqr(ld x) { return x * x; } struct point { ... point rotate(ld t)const { return { x * cos(t) - y * sin(t), x * sin(t) + y * cos(t) }; } point rot90()const { return { -y,x }; } point unit()const { return *this / sqrt(sqr(x) + sqr(y)); } }; ld dis(const point\u0026 a, const point\u0026 b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } point C = A + (B - A).rot90(); 向量旋转解析设$\\vec{a}=(x,y)$，倾角为$\\theta$，长度为$l=\\sqrt{x^2+y^2}$。则$x=l\\cos{\\theta},y=l\\sin{\\theta}$，顺时针旋转后得到$\\vec{b}=(l\\cos{\\theta+\\alpha},l\\sin{\\theta+\\alpha})$​。 三角恒等变化： $$ \\vec{b}=(\\cos{(\\theta+\\alpha)}l,\\sin{(\\theta+\\alpha)}l) $$ $$ =(l(\\cos{\\theta}\\cos{\\alpha-sin{\\theta}sin{\\alpha}}),l(\\sin{\\theta}\\cos{\\alpha}+\\sin{\\alpha}\\cos{\\theta})) $$ $$ =(x \\cos{\\alpha-y \\sin{\\alpha},y \\cos{\\alpha}+x \\sin{\\alpha}}) $$ ","date":"2024-03-09","objectID":"/posts/geometry/:1:2","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#距离与旋转"},{"categories":["在学算法的日子里"],"content":" 距离与旋转例图： ld sqr(ld x) { return x * x; } struct point { ... point rotate(ld t)const { return { x * cos(t) - y * sin(t), x * sin(t) + y * cos(t) }; } point rot90()const { return { -y,x }; } point unit()const { return *this / sqrt(sqr(x) + sqr(y)); } }; ld dis(const point\u0026 a, const point\u0026 b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } point C = A + (B - A).rot90(); 向量旋转解析设$\\vec{a}=(x,y)$，倾角为$\\theta$，长度为$l=\\sqrt{x^2+y^2}$。则$x=l\\cos{\\theta},y=l\\sin{\\theta}$，顺时针旋转后得到$\\vec{b}=(l\\cos{\\theta+\\alpha},l\\sin{\\theta+\\alpha})$​。 三角恒等变化： $$ \\vec{b}=(\\cos{(\\theta+\\alpha)}l,\\sin{(\\theta+\\alpha)}l) $$ $$ =(l(\\cos{\\theta}\\cos{\\alpha-sin{\\theta}sin{\\alpha}}),l(\\sin{\\theta}\\cos{\\alpha}+\\sin{\\alpha}\\cos{\\theta})) $$ $$ =(x \\cos{\\alpha-y \\sin{\\alpha},y \\cos{\\alpha}+x \\sin{\\alpha}}) $$ ","date":"2024-03-09","objectID":"/posts/geometry/:1:2","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#向量旋转解析"},{"categories":["在学算法的日子里"],"content":" 点积与叉积例图： ld dot(const point\u0026 a, const point\u0026 b) { return a.x * b.x + a.y * b.y; } ld det(const point\u0026 a, const point\u0026 b) { return a.x * b.y - a.y * b.x; } 点积：也叫数量积、内积。几何意义是一个向量在另一个向量上的投影再乘第二个向量的模长，是一个实数，有交换律。 若同向($\\theta = 0°$)，为模长之积。 若锐角($\\theta \\lt 90°$)，数量积为正 若直角($\\theta = 90°$)，数量积为0 若钝角($\\theta \\gt 90°$)，数量积为负 若反向($\\theta = 180°$)，为模长之积的相反数 叉积：也叫外积，几何意义是两向量围成的平面四边形的面积。是一个向量，其方向$\\vec{a}\\times \\vec{b}$：用右手从$\\vec{a}$沿着不大于平角的方向向$\\vec{b}$​旋转，拇指方向是外积的方向。没有交换律。 若平行，外积为$\\vec{0}$ 共起点后，对于$\\vec{a}\\times \\vec{b}$，若$\\vec{a}$在$\\vec{b}$的右侧，外积为正，否则外积为负（以纸面为参考，$\\vec{a}$往$\\vec{b}$是逆时针为正，顺时针为负） 由向量外积可以判断两向量的旋转关系、方便求出点到直线的距离。适用于凸包和旋转卡壳。 观察两个式子： 投影：$dot=|A||B|\\cosθ$ 面积：$det=|A||B|\\sinθ$ 可以发现点积与叉积的正负由角度决定，故根据点积和叉积的正负，可以判断向量夹角的象限。 const ld eps = 1e-8; int sgn(ld x) { if (fabs(x) \u003c eps) return 0; return x \u003c 0 ? -1 : 1; } bool turn_left(const point\u0026 a, const point\u0026 b, const point\u0026 c) { return sgn(det(b - a, c - a)) \u003e 0; } bool same_dir(const line\u0026 a, const line\u0026 b) { return sgn(det(b.t - b.s, a.t - a.s)) == 0 \u0026\u0026 sgn(dot(b.t - b.s, a.t - a.s)) \u003e 0; } ","date":"2024-03-09","objectID":"/posts/geometry/:1:3","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#点积与叉积"},{"categories":["在学算法的日子里"],"content":" 判等判交求交","date":"2024-03-09","objectID":"/posts/geometry/:2:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#判等判交求交"},{"categories":["在学算法的日子里"],"content":" 浮点数等于零注意浮点数的精度误差，一般用sgn()来实现相等判断 const ld eps = 1e-8; int sgn(ld x) { if (fabs(x) \u003c eps) return 0; return x \u003c 0 ? -1 : 1; } ","date":"2024-03-09","objectID":"/posts/geometry/:2:1","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#浮点数等于零"},{"categories":["在学算法的日子里"],"content":" 点判等也是一样要注意精度捏 friend bool operator==(const point\u0026 a, const point\u0026 b) { return sgn(a.x - b.x) == 0 \u0026\u0026 sgn(a.y - b.y) == 0; } ","date":"2024-03-09","objectID":"/posts/geometry/:2:2","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#点判等"},{"categories":["在学算法的日子里"],"content":" 点在线段上点在线段上有两个要求： 点在直线上：叉积判断共线 点在两端点上：点积判断方向 bool point_on_segment(const point\u0026 a, const line\u0026 l) { // 叉乘为0，点积小于0;l:BC, a:A BA?//AC return sgn(det(a - l.s, l.t - a)) == 0 \u0026\u0026 sgn(dot(a - l.s, l.t - a)) \u003e= 0; } 叉乘为0则共线(0°或180°) 注意：可能需要处理线段退化的情况：线段退化时直接调用会返回true。 线段退化情况在调用之前自行判断。 ","date":"2024-03-09","objectID":"/posts/geometry/:2:3","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#点在线段上"},{"categories":["在学算法的日子里"],"content":" 线段判交线段有交的两种情况： 一条线段的端点在另一条线段上。 互相严格跨立。 第一种使用point_on_segment()处理； 第二种用叉积判断角度异号。 // l:AB, c:C, d:D;ABxAC * ABxAD \u003c 0,表明旋转方向不同(两点在线段两侧) bool two_side(const point\u0026 c, const point\u0026 d, const line\u0026 l) { return sgn(det(l.t - l.s, c - l.s)) * sgn(det(l.t - l.s, d - l.s)) \u003c 0; } bool inter_judge(const line\u0026 a, const line\u0026 b) { if (point_on_segment(a.s, b) || point_on_segment(a.t, b) || point_on_segment(b.s, a) || point_on_segment(b.t, a)) return true; return two_side(a.s, a.t, b) \u0026\u0026 two_side(b.s, b.t, a); } 几种测试情况思考： ","date":"2024-03-09","objectID":"/posts/geometry/:2:4","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#线段判交"},{"categories":["在学算法的日子里"],"content":" 直线求交求两条直线的交点 直线和直线的位置关系有三种： 平行 有一个交点 重合(共线) 判断位置关系思路： if(平行) { if(过同一个点) { return 两只直线重合; } else { return 两直线平行; } } else { return 两直线相交; } 判断平行(包括重合)：叉积是否为0 bool parallel_judge(const line\u0026 a, const line\u0026 b) { return sgn(det(a.t - a.s, b.t - b.s)) == 0 } 判断共线：平行且交换端点后也平行 bool collinear_judge(const line\u0026 a, const line\u0026 b) { return parallel_judge(a, b) \u0026\u0026 sgn(det(a.t - a.s, b.t - a.s)) == 0; } 两直线相交求交点使用面积计算等高三角形底边的比例求交点。 注意：这里使用了除法，除法会导致精度严重下降(通常epsilon就是为了克服除法的误差而引入的) 这里$△ABC$与$△ABD$共底，面积之比（叉积之比）即为CK与KD的长度之比。则： 对$K(k_x,k_y),C(c_x,c_y),D(d_x,d_y)$，有： $$ CK=\\frac{u}{u+v}CD $$ so：K是CD的一个定比分点。 point line_intersect(const line\u0026 a, const line\u0026 b) { ld u = det(a.t - a.s, b.s - a.s); ld v = det(a.t - a.s, b.t - a.s); return (b.s * v + b.t * u) / (v + u); } ","date":"2024-03-09","objectID":"/posts/geometry/:2:5","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#直线求交"},{"categories":["在学算法的日子里"],"content":" 直线求交求两条直线的交点 直线和直线的位置关系有三种： 平行 有一个交点 重合(共线) 判断位置关系思路： if(平行) { if(过同一个点) { return 两只直线重合; } else { return 两直线平行; } } else { return 两直线相交; } 判断平行(包括重合)：叉积是否为0 bool parallel_judge(const line\u0026 a, const line\u0026 b) { return sgn(det(a.t - a.s, b.t - b.s)) == 0 } 判断共线：平行且交换端点后也平行 bool collinear_judge(const line\u0026 a, const line\u0026 b) { return parallel_judge(a, b) \u0026\u0026 sgn(det(a.t - a.s, b.t - a.s)) == 0; } 两直线相交求交点使用面积计算等高三角形底边的比例求交点。 注意：这里使用了除法，除法会导致精度严重下降(通常epsilon就是为了克服除法的误差而引入的) 这里$△ABC$与$△ABD$共底，面积之比（叉积之比）即为CK与KD的长度之比。则： 对$K(k_x,k_y),C(c_x,c_y),D(d_x,d_y)$，有： $$ CK=\\frac{u}{u+v}CD $$ so：K是CD的一个定比分点。 point line_intersect(const line\u0026 a, const line\u0026 b) { ld u = det(a.t - a.s, b.s - a.s); ld v = det(a.t - a.s, b.t - a.s); return (b.s * v + b.t * u) / (v + u); } ","date":"2024-03-09","objectID":"/posts/geometry/:2:5","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#判断位置关系"},{"categories":["在学算法的日子里"],"content":" 直线求交求两条直线的交点 直线和直线的位置关系有三种： 平行 有一个交点 重合(共线) 判断位置关系思路： if(平行) { if(过同一个点) { return 两只直线重合; } else { return 两直线平行; } } else { return 两直线相交; } 判断平行(包括重合)：叉积是否为0 bool parallel_judge(const line\u0026 a, const line\u0026 b) { return sgn(det(a.t - a.s, b.t - b.s)) == 0 } 判断共线：平行且交换端点后也平行 bool collinear_judge(const line\u0026 a, const line\u0026 b) { return parallel_judge(a, b) \u0026\u0026 sgn(det(a.t - a.s, b.t - a.s)) == 0; } 两直线相交求交点使用面积计算等高三角形底边的比例求交点。 注意：这里使用了除法，除法会导致精度严重下降(通常epsilon就是为了克服除法的误差而引入的) 这里$△ABC$与$△ABD$共底，面积之比（叉积之比）即为CK与KD的长度之比。则： 对$K(k_x,k_y),C(c_x,c_y),D(d_x,d_y)$，有： $$ CK=\\frac{u}{u+v}CD $$ so：K是CD的一个定比分点。 point line_intersect(const line\u0026 a, const line\u0026 b) { ld u = det(a.t - a.s, b.s - a.s); ld v = det(a.t - a.s, b.t - a.s); return (b.s * v + b.t * u) / (v + u); } ","date":"2024-03-09","objectID":"/posts/geometry/:2:5","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#两直线相交求交点"},{"categories":["在学算法的日子里"],"content":" 射线求交（留思考两条射线之间的位置关系： 平行（不重合） 共线同向（部分重合或完全重合） 共线反向且不重合 共线反向且部分重合 相交 求交点两条射线如果有相交交点的话（情况5），这个交点一定是两条射线所在直线的交点，用前文的方法求即可。 判断相交对于射线来说，若有交点，则交点一定在两条射线所在直线上，射线可以看作其所在直线的一部分，那么只要判断这个交点是否同时在两条射线的延长线方向即可。 ","date":"2024-03-09","objectID":"/posts/geometry/:2:6","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#射线求交留思考"},{"categories":["在学算法的日子里"],"content":" 射线求交（留思考两条射线之间的位置关系： 平行（不重合） 共线同向（部分重合或完全重合） 共线反向且不重合 共线反向且部分重合 相交 求交点两条射线如果有相交交点的话（情况5），这个交点一定是两条射线所在直线的交点，用前文的方法求即可。 判断相交对于射线来说，若有交点，则交点一定在两条射线所在直线上，射线可以看作其所在直线的一部分，那么只要判断这个交点是否同时在两条射线的延长线方向即可。 ","date":"2024-03-09","objectID":"/posts/geometry/:2:6","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#求交点"},{"categories":["在学算法的日子里"],"content":" 射线求交（留思考两条射线之间的位置关系： 平行（不重合） 共线同向（部分重合或完全重合） 共线反向且不重合 共线反向且部分重合 相交 求交点两条射线如果有相交交点的话（情况5），这个交点一定是两条射线所在直线的交点，用前文的方法求即可。 判断相交对于射线来说，若有交点，则交点一定在两条射线所在直线上，射线可以看作其所在直线的一部分，那么只要判断这个交点是否同时在两条射线的延长线方向即可。 ","date":"2024-03-09","objectID":"/posts/geometry/:2:6","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#判断相交"},{"categories":["在学算法的日子里"],"content":" 距离","date":"2024-03-09","objectID":"/posts/geometry/:3:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#距离"},{"categories":["在学算法的日子里"],"content":" 点到线段距离点到线短距离有两种情况： 垂线段长度 到某个端点的距离 注意线段退化问题 ld point_to_line(const point\u0026 p, const line\u0026 l) { if (sgn(dis(l.s, l.t)) == 0) // 线段退化为点 return dis(p, l.s); return fabs(det(p - l.s, l.t - l.s)) / dis(l.s, l.t); } ld point_to_segment(const point\u0026 p, const line\u0026 l) { if (sgn(dot(p - l.s, l.t - l.s)) \u003c 0) return dis(p, l.s); if (sgn(dot(p - l.t, l.s - l.t)) \u003c 0) return dis(p, l.t); return point_to_line(p, l); } ","date":"2024-03-09","objectID":"/posts/geometry/:3:1","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#点到线段距离"},{"categories":["在学算法的日子里"],"content":" 凸包能包含所有给定点的最小凸多边形的叫做凸包 凸多边形：每个内角在$[0,\\pi)$内的简单多边形；如果允许非严格则是$[0,\\pi]$ 或者，点集所有可能的带权平均点集合为凸包。 ","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#凸包"},{"categories":["在学算法的日子里"],"content":" 求凸包有两种求法：Graham算法和Andrew算法，两种算法的时间复杂度都是$O(n\\log n)$。区别在于对点的排序方式不同。 ","date":"2024-03-09","objectID":"/posts/geometry/:1:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#求凸包"},{"categories":["在学算法的日子里"],"content":" Andrew算法对点的排序方法：按照$x$为第一关键字，$y$为第二关键字，对点集进行排序，排序完成后，易知：第1个点和第n个点一定在凸包点集里。 可以分别求出下凸壳和上凸壳，求上下两半时也不会互相影响。 算法：用栈来维护在凸包上的点 逆时针先求下凸壳：第1个点和第2个先入栈，当加入更多点时，设栈中的倒数第二个点为$A$，最后一个点为$B$，新加入的点为$C$，若$B$在$\\vec{AC}$的左边(或在线上)，则将$B$弹出，令$C$入栈。 接下来依然是逆时针求上凸壳，上述求下凸包时，最后入栈的点一定是$n$号点，在加入$n-1$​号点后，我们继续上一步的一模一样的操作：判断旧点和新向量的位置关系再做取舍。 注意，求上凸壳的时候依然是遍历到1号点，此时会有首尾相同，点重复的问题。 模版代码： vector\u003cpoint\u003eAndrew(vector\u003cpoint\u003e\u0026 p) { sort(p.begin(), p.end(), [](const point\u0026 a, const point\u0026 b) { return a.x == b.x ? a.y \u003c b.y : a.x \u003c b.x; }); vector\u003cpoint\u003e res; for (int i = 0; i \u003c p.size(); i++) { // 下凸壳 while (res.size() \u003e 1 \u0026\u0026 sgn(det(res.back() - res[res.size() - 2], p[i] - res[res.size() - 2])) \u003c= 0) res.pop_back(); res.push_back(p[i]); } int k = res.size(); for (int i = p.size() - 2; i \u003e= 0; i--) { // 上凸壳 while (res.size() \u003e k \u0026\u0026 sgn(det(res.back() - res[res.size() - 2], p[i] - res[res.size() - 2])) \u003c= 0) res.pop_back(); res.push_back(p[i]); } res.pop_back(); // 删除重复的点,即首尾相同 return res; } 凸包的周长：($k$为凸包中点的个数) $$ C=\\sum_{i=0}^{i=k-1}dis(p_{i},p_{(i+1) \\mod{k}}) $$ ld convex_perimeter(vector\u003cpoint\u003e\u0026 p) { ld res = 0; for (int i = 0; i \u003c p.size(); i++) res += dis(p[i], p[(i + 1) % p.size()]); return res; } ","date":"2024-03-09","objectID":"/posts/geometry/:1:1","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#andrew算法"},{"categories":["在学算法的日子里"],"content":" Graham算法取左下角的点为基准，对其余点进行逆时针排序。 由于其他点相对于基准点在$[0,\\pi )$的半平面内，因此可以直接使用叉积排序 不要使用atan2：当值域很大时，精度难以区分相近的点 注意处理极角序相同的点：按照到基准点的距离从小到大排序。 用一根细线尝试绕过所有点。 需要弹出不满足凸性的点 使用单调栈实现 bool turn_left(const point\u0026 a, const point\u0026 b, const point\u0026 c) { return sgn(det(b - a, c - a)) \u003e 0; } vector\u003cpoint\u003e Graham(vector\u003cpoint\u003e\u0026 p) { point base = *min_element(p.begin(), p.end(), [](const point\u0026 a, const point\u0026 b) { return a.y == b.y ? a.x \u003c b.x : a.y \u003c b.y; }); sort(p.begin(), p.end(), [\u0026](const point\u0026 u, const point\u0026 v) { int s = sgn(det(u - base, v - base)); if (s)return s \u003e 0; return sgn(dis(u, base) - dis(v, base)) \u003c 0; }); vector\u003cpoint\u003eres; for (auto i : p) { while (res.size() \u003e 1 \u0026\u0026 !turn_left(res[res.size() - 2], res.back(), i)) res.pop_back(); res.push_back(i); } return res; } ","date":"2024-03-09","objectID":"/posts/geometry/:1:2","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#graham算法"},{"categories":["在学算法的日子里"],"content":" 两种算法相比Graham不够好：相对较慢，容易写错 相对较慢：排序需要计算$O(n\\log n)$次叉积。 任意写错：细节比较多，任意出现挂边界的情况。 Andrew算法扫描两遍计算出上下凸壳，通常在效率和实现上相比Graham有优势。 凸包典题： [P2742 USACO5.1] 圈奶牛Fencing the Cows /【模板】二维凸包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P3829 SHOI2012] 信用卡凸包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-09","objectID":"/posts/geometry/:1:3","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#两种算法相比"},{"categories":["在学算法的日子里"],"content":" 三分二分要求单调性，最基本的应用是求一个单调函数的零点。 三分是二分的变种，它的基本用途是求单峰函数的极值点。 三分的原理：以求极大值为例。每次对一个区间$[l,r]$求三等分点$lp$和$rp$： 如果$f(lp)\\lt f(rp)$，说明极大值一定在$[lp,r]$内取到，因为如果在$[0,lp]$内，那$rp$一定处于单调下降的区间内，它的函数值不可能大于$f(lp)$，于是我们令$l=lp$ 如果$f(lp)\\gt f(rp)$，同理，极大值一定在$[l,rp]$内取到，令$r=rp$ 这样进行下去，直到$fabs(l-r)\\lt eps$​为止，如果是求极小值，只需要把处于判断处的大于小于互换。 ld three_section_max(ld l, ld r, function\u003cld(ld)\u003e f) { while (r - l \u003e eps) { ld m1 = l + (r - l) / 3; ld m2 = r - (r - l) / 3; if (f(m1) \u003c f(m2)) { l = m1; } else { r = m2; } } return f(l); } // 三分求极小值 ld three_section_min(ld l, ld r, function\u003cld(ld)\u003e f) { while (r - l \u003e eps) { ld m1 = l + (r - l) / 3; ld m2 = r - (r - l) / 3; if (f(m1) \u003e f(m2)) { l = m1; } else { r = m2; } } return f(l); } ","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#三分"},{"categories":["在学算法的日子里"],"content":" 优化按照上面的算法，每次减少三分之一的长度，但其实还可以通过在中点附近取点来优化，这样每次可以减少约二分之一的长度。 while (r - l \u003e eps) { ld mid = (l + r) / 2; ld fl = f(mid - eps), fr = f(mid + eps); if (fl \u003c fr) { r = mid; } else { l = mid; } } ","date":"2024-03-09","objectID":"/posts/geometry/:1:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#优化"},{"categories":["在学算法的日子里"],"content":" 题单部分","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#题单部分"},{"categories":["在学算法的日子里"],"content":" 基础 Problem - B. Balloon Darts P1652 圆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P1257 平面上的最接近点对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P1142 轰炸 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P1355 神秘大三角 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) // 这题莫名卡输入格式，坏！ 一些子问题Q 如何求一组点中用一条直线穿过的最多的点数？$O(n^3)$做法、$O(n^2logm)$做法 ","date":"2024-03-09","objectID":"/posts/geometry/:0:1","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#基础"},{"categories":["在学算法的日子里"],"content":" 难一些的 Panda Preserve - Problem - QOJ.ac Convex Hull Extension - Problem - QOJ.ac Minimum Euclidean Distance - Problem - QOJ.ac ","date":"2024-03-09","objectID":"/posts/geometry/:0:2","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#难一些的"},{"categories":["在学算法的日子里"],"content":" 模版代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; typedef pair\u003cld, ld\u003e pld; typedef pair\u003cll, ll\u003e pll; const ld eps = 1e-18; ld sqr(ld x) { return x * x; } int sgn(ld x) { if (fabs(x) \u003c eps) return 0; return x \u003c 0 ? -1 : 1; } struct point { ld x, y; point operator+(const point\u0026 p) const { // 加 return { x + p.x, y + p.y }; } point operator-(const point\u0026 p) const { // 减 return { x - p.x, y - p.y }; } point operator*(const ld p) const { // 乘 return { x * p, y * p }; } point operator/(const ld p) const { // 除 return { x / p, y / p }; } friend bool operator==(const point\u0026 a, const point\u0026 b) { return sgn(a.x - b.x) == 0 \u0026\u0026 sgn(a.y - b.y) == 0; } point rotate(ld t)const { return { x * cos(t) - y * sin(t), x * sin(t) + y * cos(t) }; } point rot90()const { return { -y,x }; } point unit()const { // 单位向量 return *this / sqrt(sqr(x) + sqr(y)); } }; struct line { point s, t; //s起点 t终点 }; point A(1, 0), B(3, 1), delta = B - A; line l(A, B); ld dis(const point\u0026 a, const point\u0026 b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } point C = A + (B - A).rot90(); ld dot(const point\u0026 a, const point\u0026 b) { return a.x * b.x + a.y * b.y; } ld det(const point\u0026 a, const point\u0026 b) { return a.x * b.y - a.y * b.x; } bool turn_left(const point\u0026 a, const point\u0026 b, const point\u0026 c) { return sgn(det(b - a, c - a)) \u003e 0; } bool same_dir(const line\u0026 a, const line\u0026 b) { return sgn(det(b.t - b.s, a.t - a.s)) == 0 \u0026\u0026 sgn(dot(b.t - b.s, a.t - a.s)) \u003e 0; } bool parallel(const line\u0026 a, const line\u0026 b) { return sgn(det(b.t - b.s, a.t - a.s)) == 0; } bool point_on_segment(const point\u0026 a, const line\u0026 l) { // 叉乘为0，点积小于0;l:BC, a:A BA?//AC return sgn(det(a - l.s, l.t - a)) == 0 \u0026\u0026 sgn(dot(a - l.s, l.t - a)) \u003e= 0; } // l:AB, c:C, d:D;ABxAC * ABxAD \u003c 0,表明旋转方向不同(两点在线段两侧) bool two_side(const point\u0026 c, const point\u0026 d, const line\u0026 l) { return sgn(det(l.t - l.s, c - l.s)) * sgn(det(l.t - l.s, d - l.s)) \u003c 0; } bool inter_judge(const line\u0026 a, const line\u0026 b) { if (point_on_segment(a.s, b) || point_on_segment(a.t, b) || point_on_segment(b.s, a) || point_on_segment(b.t, a)) return true; return two_side(a.s, a.t, b) \u0026\u0026 two_side(b.s, b.t, a); } // 判断平行(包括重合) bool parallel_judge(const line\u0026 a, const line\u0026 b) { return sgn(det(a.t - a.s, b.t - b.s)) == 0; } // 判断共线 bool collinear_judge(const line\u0026 a, const line\u0026 b) { return parallel_judge(a, b) \u0026\u0026 sgn(det(a.t - a.s, b.t - a.s)) == 0; } point line_intersect(const line\u0026 a, const line\u0026 b) { ld u = det(a.t - a.s, b.s - a.s); ld v = det(a.t - a.s, b.t - a.s); return (b.s * v + b.t * u) / (v + u); } // bool ray_intersect_judge(const line\u0026 a, const line\u0026 b) { // // TODO: finish this // } ld point_to_line(const point\u0026 p, const line\u0026 l) { if (sgn(dis(l.s, l.t)) == 0) // 线段退化为点 return dis(p, l.s); return abs(det(p - l.s, l.t - l.s)) / dis(l.s, l.t); } ld point_to_segment(const point\u0026 p, const line\u0026 l) { if (sgn(dot(p - l.s, l.t - l.s)) \u003c 0) return dis(p, l.s); if (sgn(dot(p - l.t, l.s - l.t)) \u003c 0) return dis(p, l.t); return point_to_line(p, l); } ld segment_to_segment(const line\u0026 a, const line\u0026 b) { if (inter_judge(a, b)) return 0; return min({ point_to_segment(a.s, b), point_to_segment(a.t, b), point_to_segment(b.s, a), point_to_segment(b.t, a) }); } vector\u003cpoint\u003eAndrew(vector\u003cpoint\u003e\u0026 p) { sort(p.begin(), p.end(), [](const point\u0026 a, const point\u0026 b) { return a.x == b.x ? a.y \u003c b.y : a.x \u003c b.x; }); vector\u003cpoint\u003e res; for (int i = 0; i \u003c p.size(); i++) { // 下凸壳 while (res.size() \u003e 1 \u0026\u0026 !turn_left(res[res.size() - 2], res.back(), p[i])) res.pop_back(); res.push_back(p[i]); } int k = res.size(); for (int i = p.size() - 2; i \u003e= 0; i--) { // 上凸壳 while (res.size() \u003e k \u0026\u0026 !turn_left(res[res.size() - 2], res.back(), p[i])) res.pop_back(); res.push_back(p[i]); } res.pop_back(); // 删除重复的点,即首尾相同 return res; } bool turn_left(const point\u0026 a, const point\u0026 b, const point\u0026 c) { // 逆时针 return sgn(det(b - a, c - a)) \u003e 0; } vector\u003cpoint\u003e Graham(vector\u003cpoint\u003e\u0026 p) { point base = *min_element(p.begin(), p.end(), [](const point\u0026 a, cons","date":"2024-03-09","objectID":"/posts/geometry/:0:0","series":null,"tags":["算法","计算几何"],"title":"计算几何模板||正在编辑喵...","uri":"/posts/geometry/#模版代码"},{"categories":["在学算法的日子里"],"content":" 👾线性动态规划线性动态规划，即具有线性阶段划分的动态规划。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#线性动态规划"},{"categories":["在学算法的日子里"],"content":" 💭[P1216]数字三角形 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1216数字三角形"},{"categories":["在学算法的日子里"],"content":" [USACO1.5] [IOI1994]数字三角形 Number Triangles","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#usaco15-ioi1994数字三角形-number-triangles"},{"categories":["在学算法的日子里"],"content":" 题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述"},{"categories":["在学算法的日子里"],"content":" 输入格式第一个行一个正整数 $r$ ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式"},{"categories":["在学算法的日子里"],"content":" 输出格式单独的一行,包含那个可能得到的最大的和。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 30 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1"},{"categories":["在学算法的日子里"],"content":" 提示【数据范围】 对于 $100%$ 的数据，$1\\le r \\le 1000$，所有输入在 $[0,100]$ 范围内。 题目翻译来自NOCOW。 USACO Training Section 1.5 IOI1994 Day1T1 🎈参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示"},{"categories":["在学算法的日子里"],"content":" 提示【数据范围】 对于 $100%$ 的数据，$1\\le r \\le 1000$，所有输入在 $[0,100]$ 范围内。 题目翻译来自NOCOW。 USACO Training Section 1.5 IOI1994 Day1T1 🎈参考代码 #include using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码"},{"categories":["在学算法的日子里"],"content":" 💭[P1020]导弹拦截 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1020导弹拦截"},{"categories":["在学算法的日子里"],"content":" [NOIP1999 普及组] 导弹拦截","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#noip1999-普及组-导弹拦截"},{"categories":["在学算法的日子里"],"content":" 题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 输入格式一行，若干个整数，中间由空格隔开。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-1"},{"categories":["在学算法的日子里"],"content":" 输出格式两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-1"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 389 207 155 300 299 170 158 65 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 6 2 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-1"},{"categories":["在学算法的日子里"],"content":" 提示对于前 $50%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\\mathcal O(n^2)$ 做法通过。 对于后 $50%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$ 做法通过。 对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。 此外本题开启 spj，每点两问，按问给分。 $\\text{upd 2022.8.24}$：新增加一组 Hack 数据。 🎈参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; vector\u003cint\u003ea, b, c; int main() { int n; while (cin \u003e\u003e n) { a.push_back(n); } for (int i = 0;i \u003c a.size();i++) { if (b.size() == 0 || a[i] \u003c= b.back()) b.push_back(a[i]); else { int l = 0, r = b.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (b[pos] \u003e= a[i])l = pos + 1; else r = pos; } b[l] = a[i]; } if (c.size() == 0 || c.back() \u003c a[i]) c.push_back(a[i]); else { int l = 0, r = c.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (c[pos] \u003c a[i])l = pos + 1; else r = pos; } c[l] = a[i]; } } cout \u003c\u003c b.size() \u003c\u003c endl; cout \u003c\u003c c.size() \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-1"},{"categories":["在学算法的日子里"],"content":" 提示对于前 $50%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\\mathcal O(n^2)$ 做法通过。 对于后 $50%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$ 做法通过。 对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。 此外本题开启 spj，每点两问，按问给分。 $\\text{upd 2022.8.24}$：新增加一组 Hack 数据。 🎈参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; vectora, b, c; int main() { int n; while (cin \u003e\u003e n) { a.push_back(n); } for (int i = 0;i \u003c a.size();i++) { if (b.size() == 0 || a[i] \u003c= b.back()) b.push_back(a[i]); else { int l = 0, r = b.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (b[pos] \u003e= a[i])l = pos + 1; else r = pos; } b[l] = a[i]; } if (c.size() == 0 || c.back() \u003c a[i]) c.push_back(a[i]); else { int l = 0, r = c.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (c[pos] \u003c a[i])l = pos + 1; else r = pos; } c[l] = a[i]; } } cout \u003c\u003c b.size() \u003c\u003c endl; cout \u003c\u003c c.size() \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" 💭[P1091]合唱队形 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1091合唱队形"},{"categories":["在学算法的日子里"],"content":" [NOIP2004 提高组] 合唱队形","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#noip2004-提高组-合唱队形"},{"categories":["在学算法的日子里"],"content":" 题目描述$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。 合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1\u003c \\cdots \u003ct_i\u003et_{i+1}\u003e$ … $\u003et_k(1\\le i\\le k)$。 你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 输入格式共二行。 第一行是一个整数 $n$（$2\\le n\\le100$），表示同学的总数。 第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\\le t_i\\le230$）是第 $i$ 位同学的身高（厘米）。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-2"},{"categories":["在学算法的日子里"],"content":" 输出格式一个整数，最少需要几位同学出列。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-2"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 8 186 186 150 200 160 130 197 220 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 4 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-2"},{"categories":["在学算法的日子里"],"content":" 提示对于 $50%$ 的数据，保证有 $n \\le 20$。 对于全部的数据，保证有 $n \\le 100$。 🎈参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003et; for (int i = 0; i \u003c n; i++) { int x;cin \u003e\u003e x; t.push_back(x); } int k = 1; for (int m = 0;m \u003c n;m++) { // 枚举中间位m vector\u003cint\u003el, r; // 左边最长上升子序列 for (int i = 0;i \u003c m;i++) { if (t[i] \u003e= t[m])continue; if (l.size()!=0) { if (t[i] \u003e l.back()) { l.push_back(t[i]); } else { auto it = lower_bound(l.begin(), l.end(), t[i]); *it = t[i]; } } else { l.push_back(t[i]); } } // 右边最长上升子序列 for (int i = n - 1;i \u003e m;i--) { if (t[i] \u003e= t[m])continue; if (r.size()!=0) { if (t[i] \u003e r.back()) { r.push_back(t[i]); } else { auto it = lower_bound(r.begin(), r.end(), t[i]); *it = t[i]; } } else { r.push_back(t[i]); } } k = max(k, (int)l.size() + (int)r.size() + 1); } cout \u003c\u003c n - k \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-2"},{"categories":["在学算法的日子里"],"content":" 提示对于 $50%$ 的数据，保证有 $n \\le 20$。 对于全部的数据，保证有 $n \\le 100$。 🎈参考代码 void solve() { int n;cin \u003e\u003e n; vectort; for (int i = 0; i \u003c n; i++) { int x;cin \u003e\u003e x; t.push_back(x); } int k = 1; for (int m = 0;m \u003c n;m++) { // 枚举中间位m vectorl, r; // 左边最长上升子序列 for (int i = 0;i \u003c m;i++) { if (t[i] \u003e= t[m])continue; if (l.size()!=0) { if (t[i] \u003e l.back()) { l.push_back(t[i]); } else { auto it = lower_bound(l.begin(), l.end(), t[i]); *it = t[i]; } } else { l.push_back(t[i]); } } // 右边最长上升子序列 for (int i = n - 1;i \u003e m;i--) { if (t[i] \u003e= t[m])continue; if (r.size()!=0) { if (t[i] \u003e r.back()) { r.push_back(t[i]); } else { auto it = lower_bound(r.begin(), r.end(), t[i]); *it = t[i]; } } else { r.push_back(t[i]); } } k = max(k, (int)l.size() + (int)r.size() + 1); } cout \u003c\u003c n - k \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" 💭[P1095]守望者的逃离 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1095守望者的逃离"},{"categories":["在学算法的日子里"],"content":" [NOIP2007 普及组] 守望者的逃离","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#noip2007-普及组-守望者的逃离"},{"categories":["在学算法的日子里"],"content":" 题目背景恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目背景"},{"categories":["在学算法的日子里"],"content":" 题目描述守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。 为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。 守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。 现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。 注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 输入格式输入数据共一行三个非负整数，分别表示 $M$，$S$，$T$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-3"},{"categories":["在学算法的日子里"],"content":" 输出格式输出数据共两行。 第一行一个字符串 $\\texttt{Yes}$ 或 $\\texttt{No}$，即守望者是否能逃离荒岛。 第二行包含一个整数。第一行为 $\\texttt{Yes}$ 时表示守望者逃离荒岛的最短时间；第一行为 $\\texttt{No}$ 时表示守望者能走的最远距离。 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-3"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 39 200 4 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 No 197 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-3"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 36 255 10 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 Yes 6 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-2"},{"categories":["在学算法的日子里"],"content":" 提示对于 $30%$ 的数据，$1 \\le T \\le 10$，$ 1 \\le S \\le 100$； 对于 $50%$ 的数据，$1 \\le T \\le 10^3$，$ 1 \\le S \\le 10^4$； 对于 $100%$ 的数据，$1 \\le T \\le 3\\times 10^5$，$0 \\le M \\le 10^3$，$ 1 \\le S \\le 10^8$。 🎈参考代码 void solve() { ll m, s, t;cin \u003e\u003e m \u003e\u003e s \u003e\u003e t; vector\u003cll\u003ef(t + 1); f[0] = 0;ll bl = m; for (ll i = 1;i \u003c= t;i++) { if (bl \u003e= 10) { f[i] = f[i - 1] + 60; bl -= 10; } else { f[i] = f[i - 1]; bl += 4; } } for (int i = 1;i \u003c= t;i++) { f[i] = max(f[i], f[i - 1] + 17); } if (f[t] \u003e= s) { cout \u003c\u003c \"Yes\\n\"; cout \u003c\u003c lower_bound(f.begin(), f.end(), s) - f.begin() \u003c\u003c endl; } else { cout \u003c\u003c \"No\\n\" \u003c\u003c f[t] \u003c\u003c endl; } } ","date":"2024-03-09","objectID":"/posts/lineardp/:7:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-3"},{"categories":["在学算法的日子里"],"content":" 提示对于 $30%$ 的数据，$1 \\le T \\le 10$，$ 1 \\le S \\le 100$； 对于 $50%$ 的数据，$1 \\le T \\le 10^3$，$ 1 \\le S \\le 10^4$； 对于 $100%$ 的数据，$1 \\le T \\le 3\\times 10^5$，$0 \\le M \\le 10^3$，$ 1 \\le S \\le 10^8$。 🎈参考代码 void solve() { ll m, s, t;cin \u003e\u003e m \u003e\u003e s \u003e\u003e t; vectorf(t + 1); f[0] = 0;ll bl = m; for (ll i = 1;i \u003c= t;i++) { if (bl \u003e= 10) { f[i] = f[i - 1] + 60; bl -= 10; } else { f[i] = f[i - 1]; bl += 4; } } for (int i = 1;i \u003c= t;i++) { f[i] = max(f[i], f[i - 1] + 17); } if (f[t] \u003e= s) { cout \u003c\u003c \"Yes\\n\"; cout \u003c\u003c lower_bound(f.begin(), f.end(), s) - f.begin() \u003c\u003c endl; } else { cout \u003c\u003c \"No\\n\" \u003c\u003c f[t] \u003c\u003c endl; } } ","date":"2024-03-09","objectID":"/posts/lineardp/:7:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" 💭[P1541]乌龟棋 ","date":"2024-03-09","objectID":"/posts/lineardp/:7:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1541乌龟棋"},{"categories":["在学算法的日子里"],"content":" [NOIP2010 提高组] 乌龟棋","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#noip2010-提高组-乌龟棋"},{"categories":["在学算法的日子里"],"content":" 题目背景小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目背景-1"},{"categories":["在学算法的日子里"],"content":" 题目描述乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 输入格式每行中两个数之间用一个空格隔开。 第 $1$ 行 $2$ 个正整数 $N,M$，分别表示棋盘格子数和爬行卡片数。 第 $2$ 行 $N$ 个非负整数，$a_1,a_2,…,a_N$，其中 $a_i$ 表示棋盘第 $i$ 个格子上的分数。 第 $3$ 行 $M$ 个整数，$b_1,b_2,…,b_M$，表示 $M$ 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光$M$张爬行卡片。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-4"},{"categories":["在学算法的日子里"],"content":" 输出格式$1$ 个整数，表示小明最多能得到的分数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-4"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 9 5 6 10 14 2 8 8 18 5 17 1 3 1 2 1 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 73 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-4"},{"categories":["在学算法的日子里"],"content":" 提示每个测试点 1s。 小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。 对于 $30%$ 的数据有 $1≤N≤30,1≤M≤12$。 对于 $50%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。 对于 $100%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。 🎈参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ea(n + 1); for (ll i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } vector\u003cll\u003ecnt(5); for (int i = 0;i \u003c m;i++) { ll x;cin \u003e\u003e x; cnt[x]++; } vector\u003cvector\u003cvector\u003cvector\u003cll\u003e\u003e\u003e\u003edp(cnt[1] + 1, vector\u003cvector\u003cvector\u003cll\u003e\u003e\u003e(cnt[2] + 1, vector\u003cvector\u003cll\u003e\u003e(cnt[3] + 1, vector\u003cll\u003e(cnt[4] + 1, 0)))); dp[0][0][0][0] = a[1]; for (int i = 0;i \u003c= cnt[1];i++) { for (int j = 0;j \u003c= cnt[2];j++) { for (int k = 0;k \u003c= cnt[3];k++) { for (int l = 0;l \u003c= cnt[4];l++) { ll x = i * 1 + j * 2 + k * 3 + l * 4 + 1; // 走到的格子是x if (i \u003e 0) // 走到x的时候，如果i \u003e 0，那么就可以从i - 1走到i，下面同理 dp[i][j][k][l] = max(dp[i][j][k][l], dp[i - 1][j][k][l] + a[x]); if (j \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j - 1][k][l] + a[x]); if (k \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k - 1][l] + a[x]); if (l \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k][l - 1] + a[x]); } } } } cout \u003c\u003c dp[cnt[1]][cnt[2]][cnt[3]][cnt[4]] \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-4"},{"categories":["在学算法的日子里"],"content":" 提示每个测试点 1s。 小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。 对于 $30%$ 的数据有 $1≤N≤30,1≤M≤12$。 对于 $50%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。 对于 $100%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。 🎈参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vectora(n + 1); for (ll i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } vectorcnt(5); for (int i = 0;i \u003c m;i++) { ll x;cin \u003e\u003e x; cnt[x]++; } vector","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" 💭[P1868]饥饿的奶牛 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1868饥饿的奶牛"},{"categories":["在学算法的日子里"],"content":" 饥饿的奶牛","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#饥饿的奶牛"},{"categories":["在学算法的日子里"],"content":" 题目描述有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。 现用汉语翻译为： 有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。 对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行一个整数 $N$。 接下来 $N$ 行，每行两个数 $x,y$，描述一个区间。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-5"},{"categories":["在学算法的日子里"],"content":" 输出格式输出最多能吃到的牧草堆数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-5"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 1 3 7 8 3 4 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 5 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-5"},{"categories":["在学算法的日子里"],"content":" 提示$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。 🎈参考代码 void solve() { ll n;cin \u003e\u003e n; map\u003cll, vector\u003cll\u003e\u003e mp; ll my = 0; for (ll i = 0;i \u003c n;i++) { ll x, y;cin \u003e\u003e x \u003e\u003e y; x += 1;y += 1; // 避免越界 my = max(my, y); mp[y].push_back(x); } vector\u003cll\u003edp(my + 1, 0); dp[0] = 0; for (ll i = 1;i \u003c= my;i++) { dp[i] = dp[i - 1]; if (mp.count(i)) { for (ll j = 0;j \u003c mp[i].size();j++) { ll y = mp[i][j]; dp[i] = max(dp[i], dp[y - 1] + i - y + 1); } } } cout \u003c\u003c dp[my] \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-5"},{"categories":["在学算法的日子里"],"content":" 提示$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。 🎈参考代码 void solve() { ll n;cin \u003e\u003e n; map","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" =======待完成部分=======","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#待完成部分"},{"categories":["在学算法的日子里"],"content":" 💭[P2679]子串 ","date":"2024-03-09","objectID":"/posts/lineardp/:0:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p2679子串"},{"categories":["在学算法的日子里"],"content":" [NOIP2015 提高组] 子串","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#noip2015-提高组-子串"},{"categories":["在学算法的日子里"],"content":" 题目描述有两个仅包含小写英文字母的字符串 $A$ 和 $B$。 现在要从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，然后把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串。请问有多少种方案可以使得这个新串与字符串 $B$ 相等？ 注意：子串取出的位置不同也认为是不同的方案。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-6"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行是三个正整数 $n,m,k$，分别表示字符串 $A$ 的长度，字符串 $B$ 的长度，以及问题描述中所提到的 $k$，每两个整数之间用一个空格隔开。 第二行包含一个长度为 $n$ 的字符串，表示字符串 $A$。 第三行包含一个长度为 $m$ 的字符串，表示字符串 $B$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-6"},{"categories":["在学算法的日子里"],"content":" 输出格式一个整数，表示所求方案数。 由于答案可能很大，所以这里要求输出答案对 $1000000007$ 取模的结果。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-6"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 6 3 1 aabaab aab ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 2 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-6"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 6 3 2 aabaab aab ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 7 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-2-1"},{"categories":["在学算法的日子里"],"content":" 样例 #3","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #3 6 3 3 aabaab aab ","date":"2024-03-09","objectID":"/posts/lineardp/:6:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #3 7 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-3"},{"categories":["在学算法的日子里"],"content":" 提示 对于第 1 组数据:$1≤n≤500,1≤m≤50,k=1$; 对于第 2 组至第 3 组数据:$1≤n≤500,1≤m≤50,k=2$; 对于第 4 组至第 5 组数据:$1≤n≤500,1≤m≤50,k=m$; 对于第 1 组至第 7 组数据:$1≤n≤500,1≤m≤50,1≤k≤m$; 对于第 1 组至第 9 组数据:$1≤n≤1000,1≤m≤100,1≤k≤m$; 对于所有 10 组数据:$1≤n≤1000,1≤m≤200,1≤k≤m$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:7:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-6"},{"categories":["在学算法的日子里"],"content":" 💭[P2501]数字序列 ","date":"2024-03-09","objectID":"/posts/lineardp/:7:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p2501数字序列"},{"categories":["在学算法的日子里"],"content":" [HAOI2006] 数字序列","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#haoi2006-数字序列"},{"categories":["在学算法的日子里"],"content":" 题目描述现在我们有一个长度为 $n$ 的整数序列 $a$。但是它太不好看了，于是我们希望把它变成一个单调严格上升的序列。但是不希望改变过多的数，也不希望改变的幅度太大。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-7"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行是一个整数，表示序列长度 $n$。 第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 项 $a_i$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-7"},{"categories":["在学算法的日子里"],"content":" 输出格式第一行输出一个整数，表示最少需要改变多少个数。 第二行输出一个整数，表示在改变的数最少的情况下，每个数改变的绝对值之和的最小值。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-7"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 4 5 2 3 5 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 4 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-7"},{"categories":["在学算法的日子里"],"content":" 提示 数据规模与约定 对于 $90%$ 的数据，保证 $n \\leq 6 \\times 10^3$。 对于 $100%$ 的数据，保证 $1 \\leq n \\leq 3.5 \\times 10^4$，$1 \\leq a_i \\leq 10^5$。数据保证 $a_i$ 随机生成。 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-7"},{"categories":["在学算法的日子里"],"content":" 提示 数据规模与约定 对于 $90%$ 的数据，保证 $n \\leq 6 \\times 10^3$。 对于 $100%$ 的数据，保证 $1 \\leq n \\leq 3.5 \\times 10^4$，$1 \\leq a_i \\leq 10^5$。数据保证 $a_i$ 随机生成。 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#数据规模与约定"},{"categories":["在学算法的日子里"],"content":" 💭[P3336]话旧 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p3336话旧"},{"categories":["在学算法的日子里"],"content":" [ZJOI2013] 话旧","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#zjoi2013-话旧"},{"categories":["在学算法的日子里"],"content":" 题目描述小林跟着银河队选手去了一趟宇宙比赛，耳濡目染，变得学术起来。回来后，他发现世界大变样了。比丘兽究级进化，成了凤凰兽；金先生因为发了一篇 paper，一跃成为教授，也成为了银河队选拔委员会成员。 一日，小林与金教授聊天。金教授回忆起过去的岁月，那些年他学过的电路原理。他曾经对一种三角波很感兴趣，并且进行了一些探究。小林感到很好奇，于是金教授就将课题形式化地说了一遍。 有一定义在 $[0,N]$ 的连续函数 $f(x)$，其中 $N$ 是整数，满足 $f(0)=f(N)=0$，它的所有极值点在整数处取到，且 $f(x)$ 的极小值均是 $0$。对于任意的 $0$ 到 $N-1$ 间的整数 $I$，$f(x)$ 在 $(I, I+1)$ 上是斜率为 $1$ 或 $-1$ 的一次函数。 金先生研究的是，若他知道其中 $K$ 个整点的函数值，那么： 有多少个函数满足条件？ 满足条件的函数中，$f(x)$ 的最大值，最大能是多少？ 小林思考了一下，便想出了很好的算法。那么作为经过多年训练的你呢？ ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-8"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行包含两个用空格隔开的整数 $N,K$。接下来 $K$ 行，每行两个整数，表示 $x_i$ 和 $f(x_i)$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-8"},{"categories":["在学算法的日子里"],"content":" 输出格式一行两个整数，分别对应两个问题的答案。考虑到第一问答案可能很大，你只要输出它除以 $19940417$ 的余数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-8"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 0 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 1 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-8"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-2-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 6 9 4 2 4 2 2 0 4 2 6 0 5 1 2 0 0 0 0 0 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-2-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 1 2 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-2-2"},{"categories":["在学算法的日子里"],"content":" 提示 对于 $10%$ 的数据，$N \\leq 10$。 对于 $20%$ 的数据，$N \\leq 50$。 对于 $30%$ 的数据，$N \\leq 100$，$K \\leq 100$。 对于 $50%$ 的数据，$N \\leq 10^3$，$K \\leq 10^3$。 对于 $70%$ 的数据，$N \\leq 10^5$。 另有 $10%$ 的数据，$K=0$。 对于 $100%$ 的数据，$ 0 \\leq N \\leq 10^9$，$0 \\leq K \\leq 10^6$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-8"},{"categories":["在学算法的日子里"],"content":" 💭[P3558]BAJ-Bytecomputer ","date":"2024-03-09","objectID":"/posts/lineardp/:6:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p3558baj-bytecomputer"},{"categories":["在学算法的日子里"],"content":" [POI2013] BAJ-Bytecomputer","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#poi2013-baj-bytecomputer"},{"categories":["在学算法的日子里"],"content":" 题面翻译给定一个长度为 $n$ 的只包含 $-1,0,1$ 的数列 $a$，每次操作可以使 $a_i\\gets a_i+a_{i-1}$，求最少操作次数使得序列单调不降。如果不可能通过该操作使得序列单调不降，请输出 BRAK。 数据范围：$1\\le n\\le 10^6$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题面翻译"},{"categories":["在学算法的日子里"],"content":" 题目描述A sequence of integers from the set is given. The bytecomputer is a device that allows the following operation on the sequence: incrementing by for any . There is no limit on the range of integers the bytecomputer can store, i.e., each can (in principle) have arbitrarily small or large value. Program the bytecomputer so that it transforms the input sequence into a non-decreasing sequence (i.e., such that ) with the minimum number of operations. ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-9"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line of the standard input holds a single integer (), the number of elements in the (bytecomputer’s) input sequence. The second line contains integers () that are the successive elements of the (bytecomputer’s) input sequence, separated by single spaces. In tests worth 24% of the total points it holds that , and in tests worth 48% of the total points it holds that . ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-9"},{"categories":["在学算法的日子里"],"content":" 输出格式The first and only line of the standard output should give one integer, the minimum number of operations the bytecomputer has to perform to make its input sequence non-decreasing, of the single word BRAK (Polish for none) if obtaining such a sequence is impossible. ","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-9"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 6 -1 1 0 -1 0 1 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 3 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-9"},{"categories":["在学算法的日子里"],"content":" 💭[P4158]粉刷匠 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:3","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p4158粉刷匠"},{"categories":["在学算法的日子里"],"content":" [SCOI2009] 粉刷匠","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#scoi2009-粉刷匠"},{"categories":["在学算法的日子里"],"content":" 题目描述windy 有 $N$ 条木板需要被粉刷。 每条木板被分为 $M$ 个格子。 每个格子要被刷成红色或蓝色。 windy 每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。 每个格子最多只能被粉刷一次。 如果 windy 只能粉刷 $T$ 次，他最多能正确粉刷多少格子？ 一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-10"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行包含三个整数，$N,M,T$。 接下来有 $N$ 行，每行一个长度为 $M$ 的字符串，0 表示红色，1 表示蓝色。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-10"},{"categories":["在学算法的日子里"],"content":" 输出格式包含一个整数，最多能正确粉刷的格子数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-10"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 6 3 111111 000000 001100 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 16 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-10"},{"categories":["在学算法的日子里"],"content":" 提示$30%$ 的数据，满足 $1 \\le N,M \\le 10,0 \\le T \\le 100$ 。 $100%$ 的数据，满足 $1 \\le N,M \\le 50,0 \\le T \\le 2500$ ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-9"},{"categories":["在学算法的日子里"],"content":" 💭[P5301]宝牌一大堆 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p5301宝牌一大堆"},{"categories":["在学算法的日子里"],"content":" [GXOI/GZOI2019] 宝牌一大堆","date":"2024-03-09","objectID":"/posts/lineardp/:0:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#gxoigzoi2019-宝牌一大堆"},{"categories":["在学算法的日子里"],"content":" 题目描述麻将是一种传统的博弈游戏，由 $4$ 名玩家参与，轮流摸牌、打牌。在竞技比赛中主要有国标麻将（中国）和立直麻将（日本）两大规则。本题采用一种特别的规则——「宝牌一大堆」规则。 牌型一副麻将由 $136$ 张牌组成，其中包含 $34$ 种不同的牌，每种各有 $4$ 张。这 $34$ 种牌分别是： 一万到九万、一索到九索、一筒到九筒、东、南、西、北、中、白、发。 它们可以组合成不同的牌型： 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的索，或 $3$ 张数字连续的筒。 刻子：$3$ 张完全一样的牌。 杠子：$4$ 张完全一样的牌。 雀头：$2$ 张完全一样的牌。 其中顺子和刻子统称为面子。 和牌手牌（一名玩家持有的牌）宣告胜利的状况称为「和牌」。 当玩家持有 $14$ 张牌，并且满足以下三个条件之一时，判定为「和牌」： 存在一种方案，使得这 $14$ 张牌可以分成 $4$ 组面子、$1$ 组雀头，简记为「$3 \\times 4 + 2$」。 存在一种方案，使得这 $14$ 张牌可以分成 $7$ 组不同的雀头，称为「七对子」。 这 $14$ 张牌仅由一万、九万、一索、九索、一筒、九筒、东、南、西、北、中、白、发这 $13$ 种牌组成，并且这 $13$ 种牌每种至少有 $1$ 张，称为「国士无双」。 当玩家持有 $15$ 张牌，并且存在一种方案，使得这 $15$ 张牌可以分成 $1$ 组杠子、$3$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $16$ 张牌，并且存在一种方案，使得这 $16$ 张牌可以分成 $2$ 组杠子、$2$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $17$ 张牌，并且存在一种方案，使得这 $17$ 张牌可以分成 $3$ 组杠子、$1$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $18$ 张牌，并且存在一种方案，使得这 $18$ 张牌可以分成 $4$ 组杠子、$1$ 组雀头，判定为和牌。 宝牌每局游戏还会指定若干张「宝牌」，和牌时，手牌中的每张宝牌会使收益翻一番（会在接下来详细介绍）。 达成分数由于可以「和牌」的手牌很多，可以给每种判定为「和牌」的手牌定义一个「达成分数」，这个分数等于从所有尚未打出的牌中选出若干张，能够组成该手牌的方法数，再乘上手牌中 $2$ 的「宝牌数」次方。 该分数综合考虑了和牌几率与和牌收益，理论上以分数较高的手牌为目标较好。 例如下图手牌显然是可以「和牌」的，如果目前场上还剩 $3$ 张一万、$4$ 张九万，以及二到八万各 $2$ 张没有打出，宝牌为九万，那么下图手牌的「达成分数」就是 $C_3^3 C_4^3 C_2^2 (C_2^1)^6 2^3 = 2048$，其中 $C$ 表示组合数。 特别地，「七对子」和牌的手牌，达成分数额外乘 $7$。「国士无双」和牌的手牌，达成分数额外乘 $13$。 有一天，小 L，小 Y，小 I 和小 W 正在打麻将，路过的雪野和看到了所有已经打出的牌，但不知道任何一名玩家的手牌。也许你已经猜到了下面的剧情— —雪野和想知道在所有尚未打出的牌中，「达成分数」最高的可以「和牌」的手牌有多少分，但是她还要观看麻将比赛，所以这个问题就交给你了。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-11"},{"categories":["在学算法的日子里"],"content":" 题目描述麻将是一种传统的博弈游戏，由 $4$ 名玩家参与，轮流摸牌、打牌。在竞技比赛中主要有国标麻将（中国）和立直麻将（日本）两大规则。本题采用一种特别的规则——「宝牌一大堆」规则。 牌型一副麻将由 $136$ 张牌组成，其中包含 $34$ 种不同的牌，每种各有 $4$ 张。这 $34$ 种牌分别是： 一万到九万、一索到九索、一筒到九筒、东、南、西、北、中、白、发。 它们可以组合成不同的牌型： 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的索，或 $3$ 张数字连续的筒。 刻子：$3$ 张完全一样的牌。 杠子：$4$ 张完全一样的牌。 雀头：$2$ 张完全一样的牌。 其中顺子和刻子统称为面子。 和牌手牌（一名玩家持有的牌）宣告胜利的状况称为「和牌」。 当玩家持有 $14$ 张牌，并且满足以下三个条件之一时，判定为「和牌」： 存在一种方案，使得这 $14$ 张牌可以分成 $4$ 组面子、$1$ 组雀头，简记为「$3 \\times 4 + 2$」。 存在一种方案，使得这 $14$ 张牌可以分成 $7$ 组不同的雀头，称为「七对子」。 这 $14$ 张牌仅由一万、九万、一索、九索、一筒、九筒、东、南、西、北、中、白、发这 $13$ 种牌组成，并且这 $13$ 种牌每种至少有 $1$ 张，称为「国士无双」。 当玩家持有 $15$ 张牌，并且存在一种方案，使得这 $15$ 张牌可以分成 $1$ 组杠子、$3$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $16$ 张牌，并且存在一种方案，使得这 $16$ 张牌可以分成 $2$ 组杠子、$2$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $17$ 张牌，并且存在一种方案，使得这 $17$ 张牌可以分成 $3$ 组杠子、$1$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $18$ 张牌，并且存在一种方案，使得这 $18$ 张牌可以分成 $4$ 组杠子、$1$ 组雀头，判定为和牌。 宝牌每局游戏还会指定若干张「宝牌」，和牌时，手牌中的每张宝牌会使收益翻一番（会在接下来详细介绍）。 达成分数由于可以「和牌」的手牌很多，可以给每种判定为「和牌」的手牌定义一个「达成分数」，这个分数等于从所有尚未打出的牌中选出若干张，能够组成该手牌的方法数，再乘上手牌中 $2$ 的「宝牌数」次方。 该分数综合考虑了和牌几率与和牌收益，理论上以分数较高的手牌为目标较好。 例如下图手牌显然是可以「和牌」的，如果目前场上还剩 $3$ 张一万、$4$ 张九万，以及二到八万各 $2$ 张没有打出，宝牌为九万，那么下图手牌的「达成分数」就是 $C_3^3 C_4^3 C_2^2 (C_2^1)^6 2^3 = 2048$，其中 $C$ 表示组合数。 特别地，「七对子」和牌的手牌，达成分数额外乘 $7$。「国士无双」和牌的手牌，达成分数额外乘 $13$。 有一天，小 L，小 Y，小 I 和小 W 正在打麻将，路过的雪野和看到了所有已经打出的牌，但不知道任何一名玩家的手牌。也许你已经猜到了下面的剧情— —雪野和想知道在所有尚未打出的牌中，「达成分数」最高的可以「和牌」的手牌有多少分，但是她还要观看麻将比赛，所以这个问题就交给你了。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#牌型"},{"categories":["在学算法的日子里"],"content":" 题目描述麻将是一种传统的博弈游戏，由 $4$ 名玩家参与，轮流摸牌、打牌。在竞技比赛中主要有国标麻将（中国）和立直麻将（日本）两大规则。本题采用一种特别的规则——「宝牌一大堆」规则。 牌型一副麻将由 $136$ 张牌组成，其中包含 $34$ 种不同的牌，每种各有 $4$ 张。这 $34$ 种牌分别是： 一万到九万、一索到九索、一筒到九筒、东、南、西、北、中、白、发。 它们可以组合成不同的牌型： 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的索，或 $3$ 张数字连续的筒。 刻子：$3$ 张完全一样的牌。 杠子：$4$ 张完全一样的牌。 雀头：$2$ 张完全一样的牌。 其中顺子和刻子统称为面子。 和牌手牌（一名玩家持有的牌）宣告胜利的状况称为「和牌」。 当玩家持有 $14$ 张牌，并且满足以下三个条件之一时，判定为「和牌」： 存在一种方案，使得这 $14$ 张牌可以分成 $4$ 组面子、$1$ 组雀头，简记为「$3 \\times 4 + 2$」。 存在一种方案，使得这 $14$ 张牌可以分成 $7$ 组不同的雀头，称为「七对子」。 这 $14$ 张牌仅由一万、九万、一索、九索、一筒、九筒、东、南、西、北、中、白、发这 $13$ 种牌组成，并且这 $13$ 种牌每种至少有 $1$ 张，称为「国士无双」。 当玩家持有 $15$ 张牌，并且存在一种方案，使得这 $15$ 张牌可以分成 $1$ 组杠子、$3$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $16$ 张牌，并且存在一种方案，使得这 $16$ 张牌可以分成 $2$ 组杠子、$2$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $17$ 张牌，并且存在一种方案，使得这 $17$ 张牌可以分成 $3$ 组杠子、$1$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $18$ 张牌，并且存在一种方案，使得这 $18$ 张牌可以分成 $4$ 组杠子、$1$ 组雀头，判定为和牌。 宝牌每局游戏还会指定若干张「宝牌」，和牌时，手牌中的每张宝牌会使收益翻一番（会在接下来详细介绍）。 达成分数由于可以「和牌」的手牌很多，可以给每种判定为「和牌」的手牌定义一个「达成分数」，这个分数等于从所有尚未打出的牌中选出若干张，能够组成该手牌的方法数，再乘上手牌中 $2$ 的「宝牌数」次方。 该分数综合考虑了和牌几率与和牌收益，理论上以分数较高的手牌为目标较好。 例如下图手牌显然是可以「和牌」的，如果目前场上还剩 $3$ 张一万、$4$ 张九万，以及二到八万各 $2$ 张没有打出，宝牌为九万，那么下图手牌的「达成分数」就是 $C_3^3 C_4^3 C_2^2 (C_2^1)^6 2^3 = 2048$，其中 $C$ 表示组合数。 特别地，「七对子」和牌的手牌，达成分数额外乘 $7$。「国士无双」和牌的手牌，达成分数额外乘 $13$。 有一天，小 L，小 Y，小 I 和小 W 正在打麻将，路过的雪野和看到了所有已经打出的牌，但不知道任何一名玩家的手牌。也许你已经猜到了下面的剧情— —雪野和想知道在所有尚未打出的牌中，「达成分数」最高的可以「和牌」的手牌有多少分，但是她还要观看麻将比赛，所以这个问题就交给你了。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#和牌"},{"categories":["在学算法的日子里"],"content":" 题目描述麻将是一种传统的博弈游戏，由 $4$ 名玩家参与，轮流摸牌、打牌。在竞技比赛中主要有国标麻将（中国）和立直麻将（日本）两大规则。本题采用一种特别的规则——「宝牌一大堆」规则。 牌型一副麻将由 $136$ 张牌组成，其中包含 $34$ 种不同的牌，每种各有 $4$ 张。这 $34$ 种牌分别是： 一万到九万、一索到九索、一筒到九筒、东、南、西、北、中、白、发。 它们可以组合成不同的牌型： 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的索，或 $3$ 张数字连续的筒。 刻子：$3$ 张完全一样的牌。 杠子：$4$ 张完全一样的牌。 雀头：$2$ 张完全一样的牌。 其中顺子和刻子统称为面子。 和牌手牌（一名玩家持有的牌）宣告胜利的状况称为「和牌」。 当玩家持有 $14$ 张牌，并且满足以下三个条件之一时，判定为「和牌」： 存在一种方案，使得这 $14$ 张牌可以分成 $4$ 组面子、$1$ 组雀头，简记为「$3 \\times 4 + 2$」。 存在一种方案，使得这 $14$ 张牌可以分成 $7$ 组不同的雀头，称为「七对子」。 这 $14$ 张牌仅由一万、九万、一索、九索、一筒、九筒、东、南、西、北、中、白、发这 $13$ 种牌组成，并且这 $13$ 种牌每种至少有 $1$ 张，称为「国士无双」。 当玩家持有 $15$ 张牌，并且存在一种方案，使得这 $15$ 张牌可以分成 $1$ 组杠子、$3$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $16$ 张牌，并且存在一种方案，使得这 $16$ 张牌可以分成 $2$ 组杠子、$2$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $17$ 张牌，并且存在一种方案，使得这 $17$ 张牌可以分成 $3$ 组杠子、$1$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $18$ 张牌，并且存在一种方案，使得这 $18$ 张牌可以分成 $4$ 组杠子、$1$ 组雀头，判定为和牌。 宝牌每局游戏还会指定若干张「宝牌」，和牌时，手牌中的每张宝牌会使收益翻一番（会在接下来详细介绍）。 达成分数由于可以「和牌」的手牌很多，可以给每种判定为「和牌」的手牌定义一个「达成分数」，这个分数等于从所有尚未打出的牌中选出若干张，能够组成该手牌的方法数，再乘上手牌中 $2$ 的「宝牌数」次方。 该分数综合考虑了和牌几率与和牌收益，理论上以分数较高的手牌为目标较好。 例如下图手牌显然是可以「和牌」的，如果目前场上还剩 $3$ 张一万、$4$ 张九万，以及二到八万各 $2$ 张没有打出，宝牌为九万，那么下图手牌的「达成分数」就是 $C_3^3 C_4^3 C_2^2 (C_2^1)^6 2^3 = 2048$，其中 $C$ 表示组合数。 特别地，「七对子」和牌的手牌，达成分数额外乘 $7$。「国士无双」和牌的手牌，达成分数额外乘 $13$。 有一天，小 L，小 Y，小 I 和小 W 正在打麻将，路过的雪野和看到了所有已经打出的牌，但不知道任何一名玩家的手牌。也许你已经猜到了下面的剧情— —雪野和想知道在所有尚未打出的牌中，「达成分数」最高的可以「和牌」的手牌有多少分，但是她还要观看麻将比赛，所以这个问题就交给你了。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#宝牌"},{"categories":["在学算法的日子里"],"content":" 题目描述麻将是一种传统的博弈游戏，由 $4$ 名玩家参与，轮流摸牌、打牌。在竞技比赛中主要有国标麻将（中国）和立直麻将（日本）两大规则。本题采用一种特别的规则——「宝牌一大堆」规则。 牌型一副麻将由 $136$ 张牌组成，其中包含 $34$ 种不同的牌，每种各有 $4$ 张。这 $34$ 种牌分别是： 一万到九万、一索到九索、一筒到九筒、东、南、西、北、中、白、发。 它们可以组合成不同的牌型： 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的索，或 $3$ 张数字连续的筒。 刻子：$3$ 张完全一样的牌。 杠子：$4$ 张完全一样的牌。 雀头：$2$ 张完全一样的牌。 其中顺子和刻子统称为面子。 和牌手牌（一名玩家持有的牌）宣告胜利的状况称为「和牌」。 当玩家持有 $14$ 张牌，并且满足以下三个条件之一时，判定为「和牌」： 存在一种方案，使得这 $14$ 张牌可以分成 $4$ 组面子、$1$ 组雀头，简记为「$3 \\times 4 + 2$」。 存在一种方案，使得这 $14$ 张牌可以分成 $7$ 组不同的雀头，称为「七对子」。 这 $14$ 张牌仅由一万、九万、一索、九索、一筒、九筒、东、南、西、北、中、白、发这 $13$ 种牌组成，并且这 $13$ 种牌每种至少有 $1$ 张，称为「国士无双」。 当玩家持有 $15$ 张牌，并且存在一种方案，使得这 $15$ 张牌可以分成 $1$ 组杠子、$3$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $16$ 张牌，并且存在一种方案，使得这 $16$ 张牌可以分成 $2$ 组杠子、$2$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $17$ 张牌，并且存在一种方案，使得这 $17$ 张牌可以分成 $3$ 组杠子、$1$ 组面子、$1$ 组雀头，判定为和牌。 当玩家持有 $18$ 张牌，并且存在一种方案，使得这 $18$ 张牌可以分成 $4$ 组杠子、$1$ 组雀头，判定为和牌。 宝牌每局游戏还会指定若干张「宝牌」，和牌时，手牌中的每张宝牌会使收益翻一番（会在接下来详细介绍）。 达成分数由于可以「和牌」的手牌很多，可以给每种判定为「和牌」的手牌定义一个「达成分数」，这个分数等于从所有尚未打出的牌中选出若干张，能够组成该手牌的方法数，再乘上手牌中 $2$ 的「宝牌数」次方。 该分数综合考虑了和牌几率与和牌收益，理论上以分数较高的手牌为目标较好。 例如下图手牌显然是可以「和牌」的，如果目前场上还剩 $3$ 张一万、$4$ 张九万，以及二到八万各 $2$ 张没有打出，宝牌为九万，那么下图手牌的「达成分数」就是 $C_3^3 C_4^3 C_2^2 (C_2^1)^6 2^3 = 2048$，其中 $C$ 表示组合数。 特别地，「七对子」和牌的手牌，达成分数额外乘 $7$。「国士无双」和牌的手牌，达成分数额外乘 $13$。 有一天，小 L，小 Y，小 I 和小 W 正在打麻将，路过的雪野和看到了所有已经打出的牌，但不知道任何一名玩家的手牌。也许你已经猜到了下面的剧情— —雪野和想知道在所有尚未打出的牌中，「达成分数」最高的可以「和牌」的手牌有多少分，但是她还要观看麻将比赛，所以这个问题就交给你了。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#达成分数"},{"categories":["在学算法的日子里"],"content":" 输入格式每个测试点包含多组数据，第一行是一个整数 $T$，表示数据组数。注意各组数据之间是互相独立的。 每组数据包含两行，第一行给出场上已经打出的牌，第二行给出该局的所有宝牌。 规定用 $\\texttt{1m},\\texttt{2m},\\dots,\\texttt{9m}$ 代表万，$\\texttt{1p},\\texttt{2p},\\dots,\\texttt{9p}$ 代表筒，$\\texttt{1s},\\texttt{2s},\\dots,\\texttt{9s}$ 代表索，$\\texttt E,\\texttt S,\\texttt W,\\texttt N$ 代表东、南、西、北，$\\texttt Z,\\texttt B,\\texttt F$ 代表中、白、发，相邻两张牌之间用一个空格隔开，每行的末尾有一个单独的 $0$ 代表结束。 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输入格式-11"},{"categories":["在学算法的日子里"],"content":" 输出格式输出文件应包含 $T$ 行，对于每组数据，输出一个整数表示最高分数。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#输出格式-11"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 0 0 7m 4p 2s 7s 6p 8s 7p 5s 9s 9s 1p 5m 9m 5s 4p 5s E 1p 6s 5p B 4m 6m W 6p 6s E 9s 5p 2s 8s 8p 4m 3s 9m 5p 3s 2s 6s 8s 8p 6p 5m 4s 3m 4s 5s 4s 6m 9s 6p N 5m 7s 4m 2m 2s 6s 3m 7p B B N 1m 3m B 8p F 7p 0 W 4p N 3m 2m B 9m 3p 1p 6p S 4s 5p 8s 4m 5s 2s 3s 0 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输入-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1308622848 127401984 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例输出-1-11"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#提示-10"},{"categories":["在学算法的日子里"],"content":" 样例解释在第一组数据中，没有打出过任何牌，没有宝牌，和「国士无双」分数最高，为 $13 \\times 6 \\times 4^{12}$。 和「$3 \\times 4 + 2$」和「七对子」的分数为 $100663296$ 和 $1959552$。 在第二组数据中，和「$3 \\times 4 + 2$」分数最高，为 $127401984$，可以得到该分数的手牌之一为「$\\texttt{1m2m3m 7m8m9m 1p2p3p 3p4p5p SS}$」。 和「七对子」的分数为 $125411328$，不存在和「国士无双」的可能。 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#样例解释"},{"categories":["在学算法的日子里"],"content":" 数据范围保证已经打出的牌必定是合法的牌，且每种不超过 $4$ 张。宝牌不会重复给出。 测试点编号 $T$ 的规模 已经打出的牌 宝牌数 $1$ $T = 10$ 无特殊限制 $\\le 20$ 张 $2$ $T = 100$ 至少包括所有数字为三到七的牌 $\\le 20$ 张 $3$ $T = 500$ 每种至少 $2$ 张 $\\le 20$ 张 $4$ $T = 500$ 每种至少 $3$ 张 $\\le 20$ 张 $5$ $T = 500$ 无特殊限制 $0$ 张 $6$ $T = 1,000$ 无特殊限制 $0$ 张 $7$ $T = 1,000$ 无特殊限制 $\\le 20$ 张 $8$ $T = 1,500$ 无特殊限制 $\\le 20$ 张 $9$ $T = 2,000$ 无特殊限制 $\\le 20$ 张 $10$ $T = 2,500$ 无特殊限制 $\\le 20$ 张 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":null,"tags":["动态规划","算法"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#数据范围"},{"categories":["在学算法的日子里"],"content":" A-Moving Chips","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#a-moving-chips"},{"categories":["在学算法的日子里"],"content":" 题意每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。 现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。 数据范围$t(1≤t≤1000)$ $n(2≤n≤50)$​ $a_i(a_i∈{1,0})$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。 现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。 数据范围$t(1≤t≤1000)$ $n(2≤n≤50)$​ $a_i(a_i∈{1,0})$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路统计数组中第一个1和最后一个1之间的0的数目。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ea(n); bool f = false; int cnt = 0; int ans = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; if (a[i] == 1 \u0026\u0026 !f) { f = true; } if (f) { if (a[i] == 0) cnt++; else { ans += cnt; cnt = 0; } } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Monsters Attack!","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#b-monsters-attack"},{"categories":["在学算法的日子里"],"content":" 题意玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于$k$颗子弹，每个子弹可以造成怪物的血量$a_i$下降1点，降为0后怪物将倒下并从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。 询问是否可能使玩家消灭所有$n$只怪物，不让任何一只怪物靠近玩家。 数据范围$t(1≤t≤3\\times 10^4)$ $n,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)$​ $a_i(1\\le a_i\\le 10^9)$ $x_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于$k$颗子弹，每个子弹可以造成怪物的血量$a_i$下降1点，降为0后怪物将倒下并从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。 询问是否可能使玩家消灭所有$n$只怪物，不让任何一只怪物靠近玩家。 数据范围$t(1≤t≤3\\times 10^4)$ $n,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)$​ $a_i(1\\le a_i\\le 10^9)$ $x_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路将所有怪物折合成同一个方向，每次玩家向怪物移动一格，每次都使用完所有的$k$颗子弹。遍历模拟，判断是否能在到达最远坐标之前消灭所有怪物。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 struct monster { ll a, x; bool operator\u003c(const monster\u0026 other) { return x \u003c other.x; } }; void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; vector\u003cll\u003ex(n); for(int i = 0;i \u003c n;i++) { cin \u003e\u003e x[i]; if (x[i] \u003c 0)x[i] *= -1; } vector\u003cmonster\u003emonsters; for (int i = 0;i \u003c n;i++) { monsters.push_back({a[i], x[i]}); } sort(monsters.begin(), monsters.end()); map\u003cll, ll\u003eturns; for (int i = 0;i \u003c n;i++) { ll t = monsters[i].a; ll s = monsters[i].x; turns[s] += t; } ll lk = 0; // 剩余子弹 ll ix = 0; for (auto i = turns.begin();i != turns.end();i++) { ll iy = i-\u003efirst; // 位置 ll t = i-\u003esecond; if ((iy - ix) * k + lk \u003c t) { cout \u003c\u003c \"NO\\n\";return; } else { lk = (iy - ix) * k + lk - t; ix = iy; } } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Find B","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#c-find-b"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组$a$，每次截取一段$[l,r]$的子数组$b$，判断该数组是否可以变化成一个数组$c$，满足： $\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i$ 任意$i∈[l,r]$，都满足$b_i≠c_i$ 任意$c_i\\gt 0$​ 数据范围$t(1≤t≤10^4)$ $n,q(1≤n,q≤3\\times 10^5)$​ $a_i(1\\le a_i\\le 10^9)$ $l_i,r_i(1\\le l_i\\le r_i\\le n)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组$a$，每次截取一段$[l,r]$的子数组$b$，判断该数组是否可以变化成一个数组$c$，满足： $\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i$ 任意$i∈[l,r]$，都满足$b_i≠c_i$ 任意$c_i\\gt 0$​ 数据范围$t(1≤t≤10^4)$ $n,q(1≤n,q≤3\\times 10^5)$​ $a_i(1\\le a_i\\le 10^9)$ $l_i,r_i(1\\le l_i\\le r_i\\le n)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路预处理数组$a$。 对于子数组$b$，考虑：将所有不为1的数变成1，将所有的1至少再加1。 这样生成的数组$c$是符合要求的。 如果上述操作可以实现总和不变，则可行。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, q;cin \u003e\u003e n \u003e\u003e q; vector\u003cll\u003ec(n + 1);c[0] = 0; vector\u003cll\u003epc(n + 1);pc[0] = 0; vector\u003cll\u003ect(n + 1);ct[0] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e c[i]; pc[i] = c[i] + pc[i - 1]; if (c[i] == 1)ct[i] = ct[i - 1] + 1; else ct[i] = ct[i - 1]; } while (q--) { ll l, r;cin \u003e\u003e l \u003e\u003e r; if (l == r) { cout \u003c\u003c \"NO\\n\";continue; } ll sum = pc[r] - pc[l - 1]; ll lr = r - l + 1; lr -= ct[r] - ct[l - 1]; // 非1的个数 if (sum - lr \u003e= 2 * (ct[r] - ct[l - 1])) { cout \u003c\u003c \"YES\\n\"; } else cout \u003c\u003c \"NO\\n\"; } } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":null,"tags":["算法","CF"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Turtle Puzzle: Rearrange and Negate","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#a-turtle-puzzle-rearrange-and-negate"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组执行两个操作： 对数组进行重新排序或保持元素顺序不变 选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。 求进行上述操作之后数组的最大和是多少。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ $a_i(-100\\le a_i\\le 100)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组执行两个操作： 对数组进行重新排序或保持元素顺序不变 选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。 求进行上述操作之后数组的最大和是多少。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ $a_i(-100\\le a_i\\le 100)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路遍历数组，对所有的数取非负后相加。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; ll ans = 0ll; for (int i = 0;i \u003c n;i++) { ll x;cin \u003e\u003e x; if (x \u003c 0)ans -= x; else ans += x; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Turtle Math: Fast Three Task","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#b-turtle-math-fast-three-task"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组，可以对数组中的数进行任意次下方两种操作： 将数移除 将该数的数值加1 求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？ 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组，可以对数组中的数进行任意次下方两种操作： 将数移除 将该数的数值加1 求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？ 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路统计数组$a$中模3为0、1、2的数量和余数总和。记总和为$sum$，余1的数量为$x$，余2的数量为$y$。考虑： 若$sum$模3为0，则不需要操作 若$sum$模3为2，则给任意一个数加1即可，操作1次。 若$sum$模3为1，若有余1的数，则去掉这个数即可，否则进行两次加1操作。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003eaa(n); ll ans = 0; ll x = 0, y = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e aa[i]; aa[i] %= 3; ans += aa[i]; if (aa[i] == 1)x++; else if (aa[i] == 2)y++; } if (ans%3 == 0) { cout\u003c\u003c0\u003c\u003c'\\n'; } else if (ans % 3 == 2) { cout \u003c\u003c 1 \u003c\u003c '\\n'; } else { if (x \u003e 0)cout \u003c\u003c 1 \u003c\u003c '\\n'; else cout \u003c\u003c 2 \u003c\u003c '\\n'; } } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Turtle Fingers: Count the Values of k","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#c-turtle-fingers-count-the-values-of-k"},{"categories":["在学算法的日子里"],"content":" 题意给3个正整数$a,b,l$，找出满足$l=k\\times a^x\\times b^y$的$k$的个数，$k,x,y$均为非负整数。 数据范围$t(1≤t≤10^4)$ $a,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给3个正整数$a,b,l$，找出满足$l=k\\times a^x\\times b^y$的$k$的个数，$k,x,y$均为非负整数。 数据范围$t(1≤t≤10^4)$ $a,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路$2^{20}\\gt 10^6$，可知，$x,y$的范围不超过20。 预处理$a^x$和$b^y$，然后暴力遍历即可。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll a, b, l;cin \u003e\u003e a \u003e\u003e b \u003e\u003e l; vector\u003cll\u003eax, by; ax.push_back(1);by.push_back(1); for (int i = 1;ax.back() \u003c= l;i++) { ax.push_back(ax.back() * a); } for (int i = 1;by.back() \u003c= l;i++) { by.push_back(by.back() * b); } set\u003cll\u003ek; for (int i = 0;i \u003c ax.size();i++) { for (int j = 0;j \u003c by.size();j++) { if (l%(ax[i] * by[j]) == 0) { k.insert(l/(ax[i] * by[j])); } } } cout \u003c\u003c k.size() \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Turtle Tenacity: Continual Mods","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#d-turtle-tenacity-continual-mods"},{"categories":["在学算法的日子里"],"content":" 题意给数组$a$重新排序，判断是否存在排序使得$a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots a_{n-1}\\text{ }mod\\text{ }a_n=0$。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$ $a_i(1\\le a_i\\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给数组$a$重新排序，判断是否存在排序使得$a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots a_{n-1}\\text{ }mod\\text{ }a_n=0$。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$ $a_i(1\\le a_i\\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路思考$x\\text{ }mod\\text{ }y$ 如果$x\\lt y$，则结果还是$x$ 如果$x=y$​，则结果是0 如果最小的数是唯一的，则一定有解；如果最小的数不唯一，考虑是否有较大的数$z$使得$z\\text{ }mod\\text{ }x≠0$，如果存在，则有更小的唯一最小值，可以有解，否则无解。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } sort(a.begin(), a.end()); if (a[0] != a[1]) { cout \u003c\u003c \"YES\\n\"; return; } for (int i = 1;i \u003c n;i++) { if (a[i] % a[0] != 0) { cout \u003c\u003c \"YES\\n\"; return; } } cout \u003c\u003c \"NO\\n\"; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Turtle vs. Rabbit Race: Optimal Trainings","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#e-turtle-vs-rabbit-race-optimal-trainings"},{"categories":["在学算法的日子里"],"content":" 题意训练量$k$是连续一段时间的每天的训练量的总和，每次训练的提高值$u$按照训练次数递减（第1次$u$，第2次$u-1$，第3次$u-2$，…，第$k$次$u-k+1$，，提高值可以是负数），每次给定一个起始日$l$和提高值$u$，寻找一个最佳的结束日$r$，使得训练提高值总和最高，如果有多个$r$的结果提供最高训练值，选$r$较小的那个。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$ $a_i(1\\le a_i\\le 10^4)$ $q(1\\le q\\le 10^5)$ $l,u(1\\le l\\le n,1\\le u \\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意训练量$k$是连续一段时间的每天的训练量的总和，每次训练的提高值$u$按照训练次数递减（第1次$u$，第2次$u-1$，第3次$u-2$，…，第$k$次$u-k+1$，，提高值可以是负数），每次给定一个起始日$l$和提高值$u$，寻找一个最佳的结束日$r$，使得训练提高值总和最高，如果有多个$r$的结果提供最高训练值，选$r$较小的那个。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$ $a_i(1\\le a_i\\le 10^4)$ $q(1\\le q\\le 10^5)$ $l,u(1\\le l\\le n,1\\le u \\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路训练提高值总量$S$与训练量$k$之间的关系是$S(k)=u\\times k-\\frac{k\\times (k-1)}{2}$，是一个关于$k$先增后减的函数，最高值在$k=u+0.5$处取到，由于$k$为整数，$S(k)$的最高值应该在$u$和$u+1$处取到。 在对称轴左边，二分查找在$[l,u]$的范围内最靠近$u$的$k$的取值，即小于等于$u$的最后一个$k$值。 在对称轴右边，二分查找$[u+1,n]$的范围内最靠近$u+1$的$k$值，即大于等于$u+1$的第一个$k$值。 $k$值可以通过前缀和进行筛选，$k=pre[r]-pre[l-1]$，则对$pre$数组进行二分查找$u+pre[l-1]$和$u+1+pre[l-1]$即可。 对比这两个值对应的$S(k)$和$r$，以及只在$l$那天训练的效果，择优选择。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll f(ll u, ll k) { return k * u - k * (k - 1) / 2; } void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); vector\u003cll\u003epre(n + 1); pre[0] = 0;a[0] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] + a[i]; } int q;cin \u003e\u003e q; while (q--) { ll l, u;cin \u003e\u003e l \u003e\u003e u; ll x = pre[l - 1]; int ru = upper_bound(pre.begin() + l, pre.end(), x + u) - pre.begin() - 1; ll ans = a[l], ansr = l; if (ru \u003e= l \u0026\u0026 ru \u003c= n) { if (f(u, pre[ru] - x) \u003e ans) { ans = f(u, pre[ru] - x); ansr = ru; } } int ru1 = lower_bound(pre.begin() + l, pre.end(), x + u + 1) - pre.begin(); if (ru1 \u003e= l, ru1 \u003c= n) { if (f(u, pre[ru1] - x) \u003e ans) { ans = f(u, pre[ru1] - x); ansr = ru1; } } cout \u003c\u003c ansr \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-Thorns and Coins","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#a-thorns-and-coins"},{"categories":["在学算法的日子里"],"content":" 题意长度为$n$的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ .代表空，*代表荆棘，@代表金币 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意长度为$n$的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ .代表空，*代表荆棘，@代表金币 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路从左往右，寻找第一个含有2个以上*的*连通块，其前的金币都可以达到。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int cnt = 0; bool f = true; for (int i = 0;i \u003c n;i++) { if (s[i] == '@')cnt++; if (i \u003e 0 \u0026\u0026 s[i] == '*' \u0026\u0026 s[i - 1] == '*'){ break; } } cout \u003c\u003c cnt \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Chaya Calendar","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#b-chaya-calendar"},{"categories":["在学算法的日子里"],"content":" 题意查亚部落相信世界末日有$n$个征兆，第$i$个征兆每隔$a_i$年出现一次，当观测到第$i-1$个征兆后才会等待第$i$个征兆。给出每个征兆的出现间隔，询问观测到所有$n$个征兆所需要的年数。 ps:当第$i$个征兆在第$x$年被观测，部落会从第$x+1$年开始等待第$i+1$个征兆。 数据范围$t(1≤t≤1000)$ $n(1≤n≤100)$​ $a_i(1\\le a_i\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意查亚部落相信世界末日有$n$个征兆，第$i$个征兆每隔$a_i$年出现一次，当观测到第$i-1$个征兆后才会等待第$i$个征兆。给出每个征兆的出现间隔，询问观测到所有$n$个征兆所需要的年数。 ps:当第$i$个征兆在第$x$年被观测，部落会从第$x+1$年开始等待第$i+1$个征兆。 数据范围$t(1≤t≤1000)$ $n(1≤n≤100)$​ $a_i(1\\le a_i\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路第$i$个征兆间隔$a_i$年出现，若上一个征兆在第$x$年被观测，则下一个征兆将在第$y=k\\times a_i$年出现（$x\\lt y\\le x+a_i$）。等待的时间是$y-x$，也就是$a_i-x\\text{ }mod\\text{ }a_i$年。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; ll lf = a[i] - sum % a[i]; sum += lf; } cout \u003c\u003c sum \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-LR-remainders","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#c-lr-remainders"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组$a$，一个正整数$m$和长度为$n$的命令（由L和R组成的字符串），每次求数组中剩余数的积模$m$的余数并输出，然后按照命令删数（L删去最左边的数，R删去最右边的数）。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组$a$，一个正整数$m$和长度为$n$的命令（由L和R组成的字符串），每次求数组中剩余数的积模$m$的余数并输出，然后按照命令删数（L删去最左边的数，R删去最右边的数）。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路反过来考虑，从最后一个删去的数开始，每次对积乘上上一次被删去的数，记录模m的值，逆序输出。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } string s;cin \u003e\u003e s; vector\u003cint\u003eb; int l = 0, r = n - 1; for (int i = 0;i \u003c n;i++) { if (s[i] == 'L')b.push_back(a[l++]); else b.push_back(a[r--]); } ll ans = 1; vector\u003cint\u003eres; reverse(b.begin(), b.end()); for (int i = 0;i \u003c n;i++) { ans *= b[i]; res.push_back(ans % m); ans %= m; } reverse(res.begin(), res.end()); for (int i = 0;i \u003c n;i++) { cout \u003c\u003c res[i] \u003c\u003c \" \"; }cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Card Game","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#d-card-game"},{"categories":["在学算法的日子里"],"content":" 题意纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花色之间比较数字大小。 给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。 数据范围$t(1≤t≤100)$ $n(1\\le n \\le 16)$​ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花色之间比较数字大小。 给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。 数据范围$t(1≤t≤100)$ $n(1\\le n \\le 16)$​ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路模拟。 先对不同花色的牌分类，然后遍历同花色的牌，排序后，将非王牌花色放入一个序列，王牌花色单独一个序列。 从非王牌花色序列开始遍历，如果当前牌和其后一牌是同一种花色，凑成一对局；如果不是，用一张王牌花色和它凑成一个对局。假如可以凑成所有的对局，输出这些对局，否则不能构成对局。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string w;cin \u003e\u003e w; int f = 0; switch (w[0]) { case 'S':f = 3;break; case 'H':f = 2;break; case 'D':f = 1;break; case 'C':f = 0;break; default:break; } vector\u003cvector\u003cstring\u003e\u003esp(4); for (int i = 0;i \u003c 2 * n;i++) { string s;cin \u003e\u003e s; if (s[1] == 'C')sp[0].push_back(s); else if (s[1] == 'D')sp[1].push_back(s); else if (s[1] == 'H')sp[2].push_back(s); else sp[3].push_back(s); } vector\u003cstring\u003erk; for (int i = 0;i \u003c 4;i++) { if (i == f)continue; sort(sp[i].begin(), sp[i].end()); for (int j = 0;j \u003c sp[i].size();j++) rk.push_back(sp[i][j]); } sort(sp[f].begin(), sp[f].end()); for (int j = 0;j \u003c sp[f].size();j++) rk.push_back(sp[f][j]); vector\u003cpair\u003cstring, string\u003e\u003eans; int cnt = 0;int p = rk.size() - 1; for (int i = 0;i \u003c p;i++) { if (rk[i][1] == rk[i + 1][1]) { ans.push_back({ rk[i],rk[i + 1] });i++; cnt++; } else { if (f == 0 \u0026\u0026 rk[p][1] == 'C') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 1 \u0026\u0026 rk[p][1] == 'D') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 2 \u0026\u0026 rk[p][1] == 'H') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 3 \u0026\u0026 rk[p][1] == 'S') { ans.push_back({ rk[i],rk[p] });p--; } else { cout \u003c\u003c \"IMPOSSIBLE\\n\";return; } } } for (int i = 0;i \u003c n;i++) { cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c ans[i].second \u003c\u003c '\\n'; } } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Final Countdown","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#e-final-countdown"},{"categories":["在学算法的日子里"],"content":" 题意倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。 求实际上需要多少秒完成倒计时。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤4\\times 10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。 求实际上需要多少秒完成倒计时。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤4\\times 10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路计数模拟： 12345 1234 123 12 1 -----+ 13715 则对从第一位开始做前缀和，对(前缀和+进位)倒着取模，最后输出即可。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int x = 0; while (s[x] == '0') { x++; } s = s.substr(x); vector\u003cll\u003ev; for (int i = 0;i \u003c s.size();i++) { if (i != 0) v.push_back(v.back() + s[i] - '0'); else { v.push_back(s[i] - '0'); } } reverse(v.begin(), v.end()); ll k = 0; vector\u003cint\u003eres; for (int i = 0;i \u003c v.size();i++) { res.emplace_back((v[i] + k) % 10); k = (v[i] + k) / 10; } while(k \u003e 0) { res.emplace_back(k % 10); k /= 10; } reverse(res.begin(), res.end()); for (int i = 0;i \u003c res.size();i++) { cout \u003c\u003c res[i]; }cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":null,"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-宇宙的终结","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#a-宇宙的终结"},{"categories":["在学算法的日子里"],"content":" 题意在$[l,r]$中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。 数据范围$1\\leq l\\leq r \\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意"},{"categories":["在学算法的日子里"],"content":" 题意在$[l,r]$中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。 数据范围$1\\leq l\\leq r \\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路数据小，模拟即可 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { vector\u003cbool\u003eisprime(101, true); // 判断素数 isprime[0] = isprime[1] = false; for (int i = 2;i \u003c= 100;i++) { if (isprime[i]) { for (int j = i + i;j \u003c= 100;j += i) { isprime[j] = false; } } } int l, r; cin \u003e\u003e l \u003e\u003e r; for (int i = 2;i \u003c= r;i++) { for (int j = 2;j \u003c= r;j++) { for (int k = 2;k \u003c= r;k++) { if (isprime[i] \u0026\u0026 isprime[j] \u0026\u0026 isprime[k] \u0026\u0026 i != j \u0026\u0026 j != k \u0026\u0026 i != k) { if (i * j * k \u003e= l \u0026\u0026 i * j * k \u003c= r) { cout \u003c\u003c i * j * k;return; } } } } } cout \u003c\u003c -1; } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-爱恨的纠葛","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#b-爱恨的纠葛"},{"categories":["在学算法的日子里"],"content":" 题意定义两个等长数组的亲密值：$|a_i-b_i|(1\\leq i\\leq n)$的最小值。给定2个数组，可以任意排列$a$数组的元素顺序，输出一个亲密度最小的方案（数组$a$的操作结果）。 数据范围$1\\leq n\\leq 10^5$ $1\\leq a,b \\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意定义两个等长数组的亲密值：$|a_i-b_i|(1\\leq i\\leq n)$的最小值。给定2个数组，可以任意排列$a$数组的元素顺序，输出一个亲密度最小的方案（数组$a$的操作结果）。 数据范围$1\\leq n\\leq 10^5$ $1\\leq a,b \\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路将$a,b$数组的数据放入 一个数组中，进行排序，从第一位开始遍历，如果某两个相邻的数一个来自于$a$数组，一个来自于$b$数组，更新最小的差的绝对值，将$a$数组中的这两个相匹配的位置进行互换后输出$a$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n), b(n); vector\u003cpair\u003cll, pair\u003cint,int\u003e\u003e\u003ec; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; c.push_back({ a[i],{0,i} }); } for (int i = 0;i \u003c n;i++) { cin \u003e\u003e b[i]; c.push_back({ b[i],{1,i} }); } sort(c.begin(), c.end()); ll ans = 1e9 + 20; int pa = 0, pb = 0; for (int i = 1;i \u003c 2 * n;i++) { if (c[i].second.first != c[i - 1].second.first) { if (c[i].first - c[i - 1].first \u003c ans) { ans = c[i].first - c[i - 1].first; if(c[i].second.first == 0) { pa = c[i].second.second; pb = c[i - 1].second.second; } else { pa = c[i - 1].second.second; pb = c[i].second.second; } } } } ll tp = a[pa];a[pa] = a[pb];a[pb] = tp; for (int i = 0;i \u003c n;i++) { cout \u003c\u003c a[i] \u003c\u003c ' '; } } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-心绪的解剖","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#c-心绪的解剖"},{"categories":["在学算法的日子里"],"content":" 题意将$n$分解为三个斐波那契数列之和。 数据范围$1\\leq q \\leq 10^5$ $1\\leq n\\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意将$n$分解为三个斐波那契数列之和。 数据范围$1\\leq q \\leq 10^5$ $1\\leq n\\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路斐波那契数列到$F_{45}$是大于$10^{10}$的，联系到斐波那契数列的单调性，每次二分出不大于$n$的一位$F_x$，再在$n$中减去这个$F_x$直到$n$为0，如果三次二分后无法使得$n=0$则无解。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll q;cin \u003e\u003e q; vector\u003cll\u003ef(45, 0); f[0] = 0;f[1] = 1; for (int i = 2;i \u003c 45;i++) { f[i] = f[i - 1] + f[i - 2]; } while (q--) { ll n;cin \u003e\u003e n; int p1 = upper_bound(f.begin(), f.end(), n) - f.begin(); p1--; n -= f[p1]; ll f1 = f[p1]; if (n == 0) { cout \u003c\u003c f1 \u003c\u003c \" 0 0\\n\";continue; } int p2 = upper_bound(f.begin(), f.end(), n) - f.begin(); p2--; n -= f[p2]; ll f2 = f[p2]; if (n == 0) { cout \u003c\u003c f1 \u003c\u003c ' ' \u003c\u003c f2 \u003c\u003c \" 0\\n\";continue; } int p3 = upper_bound(f.begin(), f.end(), n) - f.begin(); p3--; n -= f[p3]; ll f3 = f[p3]; if (n == 0) cout \u003c\u003c f1 \u003c\u003c ' ' \u003c\u003c f2 \u003c\u003c ' ' \u003c\u003c f3 \u003c\u003c '\\n'; else cout \u003c\u003c \"-1\\n\"; } } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-友谊的套路","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#d-友谊的套路"},{"categories":["在学算法的日子里"],"content":" 题意一场$BO5$的游戏（五局三胜），已知某队伍获胜的概率是$p$，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局） 数据范围$0\\lt p\\lt 1$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意一场$BO5$的游戏（五局三胜），已知某队伍获胜的概率是$p$，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局） 数据范围$0\\lt p\\lt 1$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路赢赢输输输or输输赢赢赢 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { double p;cin \u003e\u003e p; double ans = 0.0; double q = 1 - p; ans += p * p * q * q * q + q * q * p * p * p; printf(\"%.6f\", ans); } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-未来的预言","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#e-未来的预言"},{"categories":["在学算法的日子里"],"content":" 题意BO机制：$BOx$代表$x$局先胜$x/2+1$次为赢，$x$为奇数。 给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。 判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。 数据范围$1\\leq x\\leq 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意BO机制：$BOx$代表$x$局先胜$x/2+1$次为赢，$x$为奇数。 给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。 判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。 数据范围$1\\leq x\\leq 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路遍历统计，先赢到$x/2$次的获胜。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n; scanf(\"BO%d\", \u0026n); n = n / 2 + 1; string res;cin \u003e\u003e res; int a = 0, b = 0; for (int i = 0;i \u003c res.size();i++) { if (res[i] == 'R') { a++; } else { b++; } if (a == n) { cout \u003c\u003c \"kou!\\n\" \u003c\u003c i + 1; return; } if (b == n) { cout \u003c\u003c \"yukari!\\n\" \u003c\u003c i + 1; return; } } cout \u003c\u003c \"to be continued.\\n\"; cout \u003c\u003c res.size(); } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" I-时空的交织","date":"2024-02-26","objectID":"/posts/nc24wd6/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#i-时空的交织"},{"categories":["在学算法的日子里"],"content":" 题意一个$n$行$m$列的矩阵，每个元素由$a$数组和$b$数组决定，第$i$行第$j$列的元素为$a_i\\times b_j$，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。 数据范围$1\\leq n,m\\leq 10^5$ $-10^4 \\leq a_i,b_i\\leq 10^4$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意一个$n$行$m$列的矩阵，每个元素由$a$数组和$b$数组决定，第$i$行第$j$列的元素为$a_i\\times b_j$，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。 数据范围$1\\leq n,m\\leq 10^5$ $-10^4 \\leq a_i,b_i\\leq 10^4$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路对$a、b$数组分别求最大子段和和最小子段和，最大子矩阵元素和是这四个数分别相乘的积中最大的一个。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ea(n), b(m); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; for (int i = 0;i \u003c m;i++)cin \u003e\u003e b[i]; vector\u003cll\u003epa(n), qa(n); pa[0] = qa[0] = a[0]; ll xa, ya;xa = ya = a[0]; for (int i = 1;i \u003c n;i++) { if(pa[i-1]+a[i]\u003ea[i]){ pa[i] = pa[i - 1] + a[i]; } else{ pa[i] = a[i]; } xa = max(xa, pa[i]); if (qa[i - 1] + a[i] \u003c a[i]) { qa[i] = qa[i - 1] + a[i]; } else{ qa[i] = a[i]; } ya = min(ya, qa[i]); } vector\u003cll\u003epb(m), qb(m); pb[0] = qb[0] = b[0]; ll xb, yb;xb = yb = b[0]; for (int i = 1;i \u003c m;i++) { if(pb[i-1]+b[i]\u003eb[i]){ pb[i] = pb[i - 1] + b[i]; } else{ pb[i] = b[i]; } xb = max(xb, pb[i]); if(qb[i-1]+b[i]\u003cb[i]){ qb[i] = qb[i - 1] + b[i]; } else{ qb[i] = b[i]; } yb = min(yb, qb[i]); } cout \u003c\u003c max(xa * xb, max(xa * yb, max(ya * yb, ya * xb))) \u003c\u003c endl; } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" A-柠檬可乐","date":"2024-02-26","objectID":"/posts/nc24wd4/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#a-柠檬可乐"},{"categories":["在学算法的日子里"],"content":" 题意输入$a,b,k$，判断$a\\ge k\\times b$是否成立 数据范围$a,b,k(1\\leq a,b,k\\leq 100)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意"},{"categories":["在学算法的日子里"],"content":" 题意输入$a,b,k$，判断$a\\ge k\\times b$是否成立 数据范围$a,b,k(1\\leq a,b,k\\leq 100)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路简单判断 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int a, b, k;cin \u003e\u003e a \u003e\u003e b \u003e\u003e k; if (a \u003e= k * b)cout \u003c\u003c \"good\\n\"; else cout \u003c\u003c \"bad\\n\"; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-左右互博","date":"2024-02-26","objectID":"/posts/nc24wd4/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#b-左右互博"},{"categories":["在学算法的日子里"],"content":" 题意有$n$堆石子，每次选择某堆石子，选一个整数$y(2\\leq y\\leq x)$，将石子分为$\\lfloor \\frac{x}{y} \\rfloor$和$x-\\lfloor \\frac{x}{y} \\rfloor$，直到某人不能操作时结束，不能操作者输。 数据范围$n,a_i(1\\leq n,a_i \\leq 2\\times 10^5)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有$n$堆石子，每次选择某堆石子，选一个整数$y(2\\leq y\\leq x)$，将石子分为$\\lfloor \\frac{x}{y} \\rfloor$和$x-\\lfloor \\frac{x}{y} \\rfloor$，直到某人不能操作时结束，不能操作者输。 数据范围$n,a_i(1\\leq n,a_i \\leq 2\\times 10^5)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路相当于每次至少分出1个石子出来，计算将所有石头分出1颗一份的操作数，判断拿到最后一颗石子的是谁即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0; for (int i = 0;i \u003c n;i++){ cin \u003e\u003e a[i]; sum += a[i] - 1; } if (sum % 2) { cout \u003c\u003c \"gui\\n\"; } else cout \u003c\u003c \"sweet\\n\"; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-冬眠","date":"2024-02-26","objectID":"/posts/nc24wd4/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#c-冬眠"},{"categories":["在学算法的日子里"],"content":" 题意给一个$n\\times m$的字符矩阵，每天有$q$次行循环移动或列循环移动，共执行$p$次，最后询问第$x$行$y$​列是什么字符。 $op=1$表示行循环移动 $op=2$表示列循环移动 数据范围$1\\leq n,m,p,q\\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给一个$n\\times m$的字符矩阵，每天有$q$次行循环移动或列循环移动，共执行$p$次，最后询问第$x$行$y$​列是什么字符。 $op=1$表示行循环移动 $op=2$表示列循环移动 数据范围$1\\leq n,m,p,q\\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路记录循环移动顺序，然后将$(x,y)$的字符逆顺序模拟即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m, x, y; cin \u003e\u003e n \u003e\u003e m \u003e\u003e x \u003e\u003e y; x -= 1, y -= 1; vector\u003cstring\u003erec(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e rec[i]; } int p, q;cin \u003e\u003e p \u003e\u003e q; vector\u003cpair\u003cint, int\u003e\u003eopz; for (int i = 0;i \u003c q;i++) { int z, op;cin \u003e\u003e op \u003e\u003e z; opz.push_back({ op,z }); } for (int i = 0;i \u003c p;i++) { for (int j = q - 1;j \u003e= 0;j--) { int op = opz[j].first, z = opz[j].second; if (op == 1 \u0026\u0026 x == z - 1) { y -= 1; y = (y + m) % m; } else if (op == 2 \u0026\u0026 y == z - 1) { x -= 1; x = (x + n) % n; } // cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c '\\n'; } } cout \u003c\u003c rec[x][y] \u003c\u003c '\\n'; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-守恒","date":"2024-02-26","objectID":"/posts/nc24wd4/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#d-守恒"},{"categories":["在学算法的日子里"],"content":" 题意有一个长度为$n$的数组，每次操作可以对数组$a$中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少种不同的值？ 数据范围$1\\leq n,a_i\\leq 2\\times 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有一个长度为$n$的数组，每次操作可以对数组$a$中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少种不同的值？ 数据范围$1\\leq n,a_i\\leq 2\\times 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路特判$n=1$的时候（答案为1） $n\\ge 2$时，枚举最大公约数，计数合适的数的数量即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0ll; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i];sum += a[i]; } if (n == 1) { cout \u003c\u003c 1 \u003c\u003c '\\n';return; } set\u003cll\u003eres; ll f = sum / n; for (ll k = 1;k * k \u003c= sum;k++) { if (sum % k == 0) { ll x = sum / k; if (x \u003e= n \u0026\u0026 k \u003c= f) { res.insert(k); } if (k * k != sum \u0026\u0026 k \u003e= n \u0026\u0026 sum / k \u003c= f) { res.insert(sum / k); } } } cout \u003c\u003c res.size() \u003c\u003c '\\n'; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" A-mutsumi的质数合数","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#a-mutsumi的质数合数"},{"categories":["在学算法的日子里"],"content":" 题意一个由$n$个正整数组成的数组，求其中质数和合数共有几个。 数据范围$n(1\\leq n\\leq 100)$ $a_i(1\\leq a_i\\leq 100)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意"},{"categories":["在学算法的日子里"],"content":" 题意一个由$n$个正整数组成的数组，求其中质数和合数共有几个。 数据范围$n(1\\leq n\\leq 100)$ $a_i(1\\leq a_i\\leq 100)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路1不是质数也不是合数。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; int ans = 0; for (int i = 0;i \u003c n;i++) { int x;cin \u003e\u003e x; if (x\u003e1)ans++; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码"},{"categories":["在学算法的日子里"],"content":" C-anon的私货","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#c-anon的私货"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组中一些位置插入$0$，要求插入后任意不是全$0$子段的平均值大于等于$1$，询问最多插入多少个$0$ 数据范围$n(1\\leq n\\leq 10^5)$ $a_i(1\\leq a_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组中一些位置插入$0$，要求插入后任意不是全$0$子段的平均值大于等于$1$，询问最多插入多少个$0$ 数据范围$n(1\\leq n\\leq 10^5)$ $a_i(1\\leq a_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路从第一位开始贪，统计在每一位前最多可以插入多少个0，考虑两数之间的0的数目不能大于这2位之间允许的最大值。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 2); vector\u003cll\u003eb(n + 2); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; b[i] = a[i] - 1; } b[0] = 1e9 + 50; b[n + 1] = 1e9 + 50; ll ans = 0; for (int i = 0;i \u003c= n;i++) { // for (int j = 0;j \u003c= n + 1;j++)cout \u003c\u003c b[j] \u003c\u003c ' ';cout \u003c\u003c endl; if (b[i] \u003e= b[i + 1]) { ans += b[i + 1]; ll tmp = b[i + 1]; b[i + 1] = 0; b[i] -= tmp; } else { ans += b[i]; ll tmp = b[i]; b[i] = 0; b[i + 1] -= tmp; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" E-soyorin的数组操作（easy）","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#e-soyorin的数组操作easy"},{"categories":["在学算法的日子里"],"content":" 题意有一个长为$n$的数组$a$ 操作：选择一个不超过$n$的偶数$k$，$a_i=a_i+i(1\\leq i\\leq k)$ 询问是否能在任意操作后使得数组非降序。 数据范围$T(1≤T≤10^6)$ $n(1≤n≤10^5)$ $a_i(1\\leq a_i\\leq 10^{12})$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个长为$n$的数组$a$ 操作：选择一个不超过$n$的偶数$k$，$a_i=a_i+i(1\\leq i\\leq k)$ 询问是否能在任意操作后使得数组非降序。 数据范围$T(1≤T≤10^6)$ $n(1≤n≤10^5)$ $a_i(1\\leq a_i\\leq 10^{12})$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路操作的效果是使得$a_{i+1}-a{i}$的值增大1，从后往前遍历，将靠后的部分先操作为非降序（操作的效果会影响到前段） ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } if (n % 2 == 0 || n == 1) { // 加個無窮次總能彌補不合適的地方 cout \u003c\u003c \"YES\\n\";return; } // a(n-1)上限是a(n)，在這個上限下能不能把它變成需要的 ll d = 0; // 操作次數(對應相鄰兩個數之間的差距減少d(越靠後增加的越多 for (int i = n - 1;i \u003e= 1;i--) { if (a[i] \u003e a[i + 1] + d) { cout \u003c\u003c \"NO\\n\";return; } if (i % 2 == 0) d += (a[i + 1] - a[i] + d) / i; } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" G\u0026H-sakiko的排列构造（easy/hard）","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#gh-sakiko的排列构造easyhard"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长为$n$的排列，使得排列中每个$p_i+i(1\\leq i\\leq n)$都是质数。 输出符合要求的排列，若无解输出-1。 数据范围$n(1\\leq n\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长为$n$的排列，使得排列中每个$p_i+i(1\\leq i\\leq n)$都是质数。 输出符合要求的排列，若无解输出-1。 数据范围$n(1\\leq n\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路排列是$1\\sim n$的，下标也是$1\\sim n$的，从$p_i=n$开始给寻找匹配的下标(在可选范围内从小到大)，也就是寻找使得$p_i+i$是质数的最小$i$，即比$p_i$大的最小质数。如果该符合要求的质数可以被找到就缩小范围，直到所有的数都可以被确定。(从ac结果看似乎并不存在无法被构造出的排列耶) ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c \"1\\n\"; return; } else if (n == 2) { cout \u003c\u003c \"2 1\\n\"; return; } vector\u003cll\u003eprimes(n * 2 + 1); vector\u003cbool\u003eisprime(n * 2 + 1, true); isprime[0] = isprime[1] = false; for (int i = 2;i \u003c= 2 * n;i++) { if (isprime[i]) { primes.push_back(i); for (int j = i + i;j \u003c= 2 * n;j += i) { isprime[j] = false; } } } ll x = n; ll pos = n; vector\u003cll\u003ea(n + 1); while (pos \u003e= 1) { bool f = false; for (int i = pos + 1;i \u003c= pos * 2;i++) { if (isprime[i]) { f = true; x = i;break; } } // 从ac结果看似乎并不存在-1的情况(好神奇！) // if (!f) { // cout \u003c\u003c -1 \u003c\u003c '\\n';return; // } // if (x \u003e pos * 2) { // cout \u003c\u003c -1 \u003c\u003c '\\n';return; // } // ai+i=x for (int i = pos;i \u003e= x - pos;i--) { a[i] = x - i; } pos = x - pos - 1; } for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c a[i] \u003c\u003c ' '; }cout \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" I-rikki的最短路","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#i-rikki的最短路"},{"categories":["在学算法的日子里"],"content":" 题意给出一位轴上的3个坐标，$rikki$需要把$A$带到$T$的坐标，初始$rikki$在原点，且只知道$T$的坐标，到达$T$之后可以知道$A$的坐标。 $rikki$有一个范围为$k$的视野，在$[u-k,u+k]$视野内的$A$可以被发现。 数据范围$t,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意给出一位轴上的3个坐标，$rikki$需要把$A$带到$T$的坐标，初始$rikki$在原点，且只知道$T$的坐标，到达$T$之后可以知道$A$的坐标。 $rikki$有一个范围为$k$的视野，在$[u-k,u+k]$视野内的$A$可以被发现。 数据范围$t,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路签到模拟(怎么会有人签到交7发才过啊(小声)) 视野只有在出发点的时候看A有用，其他情况按规则来qwq ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll t, a, k;cin \u003e\u003e t \u003e\u003e a \u003e\u003e k; if (a \u003e= -k \u0026\u0026 a \u003c= k) { if (a * t \u003e 0) { cout \u003c\u003c t \u003c\u003c '\\n';return; } else { cout \u003c\u003c abs(2 * a - t) \u003c\u003c '\\n';return; } } else if (a * t \u003e 0) { if (abs(a) \u003c abs(t)) { cout \u003c\u003c abs(t) \u003c\u003c '\\n';return; } else { cout \u003c\u003c abs(a) + abs(a - t) \u003c\u003c '\\n';return; } } else { cout \u003c\u003c 3 * abs(t) + 2 * abs(a) \u003c\u003c '\\n';return; } } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" J-rikki的数组陡峭值","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#j-rikki的数组陡峭值"},{"categories":["在学算法的日子里"],"content":" 题意数组的陡峭值：数组相邻元素之差的绝对值之和。 给出数组$a$中每个元素$a_i$的范围$[l_i,r_i]$，求最小的陡峭值。 数据范围$n(1\\leq n\\leq 10^5)$ $l_i,r_i(1\\leq l_i,r_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意数组的陡峭值：数组相邻元素之差的绝对值之和。 给出数组$a$中每个元素$a_i$的范围$[l_i,r_i]$，求最小的陡峭值。 数据范围$n(1\\leq n\\leq 10^5)$ $l_i,r_i(1\\leq l_i,r_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路贪心，从前往后遍历，如果$a_i$和$a_{i+1}$的范围有重合，则直接将$a_i$和$a_{i+1}$的值取成同一个数，陡峭值不增加，更新$a_{i+1}$的范围为两数重合的范围。如果范围不重合，两数分别取靠近的两个端点，并将$a_{i+1}$的范围缩成1个点。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003el(n + 1), r(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e l[i] \u003e\u003e r[i]; } // 這題該不會能貪吧(破防 ll ans = 0; for (int i = 1;i \u003c n;i++) { ll x = max(l[i], l[i + 1]); ll y = min(r[i], r[i + 1]); if (x \u003c= y) { // 貪貪貪 l[i + 1] = x;r[i + 1] = y; } else { ans += abs(x - y); if (r[i + 1] \u003c l[i]) l[i + 1] = r[i + 1]; else r[i + 1] = l[i + 1]; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" K-soyorin的通知","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#k-soyorin的通知"},{"categories":["在学算法的日子里"],"content":" 题意$soyorin$要把消息传递给$n$个人，每个知道消息的可以将消息传递给其他人。 第$i$个人可以花费$a_i$将消息通知给最多$b_i$个人，前提是第$i$个人已知消息，消息源通知一个人花费为$p$。求最小花费。 数据范围$n(1\\leq n\\leq 1000)$ $p(1\\leq p\\leq 10^6)$ $a_i,b_i(1\\leq a_i,b_i\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意$soyorin$要把消息传递给$n$个人，每个知道消息的可以将消息传递给其他人。 第$i$个人可以花费$a_i$将消息通知给最多$b_i$个人，前提是第$i$个人已知消息，消息源通知一个人花费为$p$。求最小花费。 数据范围$n(1\\leq n\\leq 1000)$ $p(1\\leq p\\leq 10^6)$ $a_i,b_i(1\\leq a_i,b_i\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路dp，更新通知$i$个人的最小花费。每当第$i$个人知道消息时更新使得$j$人知道消息的花费。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, p;cin \u003e\u003e n \u003e\u003e p; vector\u003cll\u003ea(n + 1), b(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } // dp：通知i個人的最小花費j,dp[i]=j vector\u003cll\u003edp(n + 1); for (int i = 1;i \u003c= n;i++) dp[i] = p * i; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { // 第i個人已經被通知的情況下，通知j個人，花費a[i] if (j - b[i] \u003e 0) dp[j] = min(dp[j], dp[j - b[i]] + a[i]); else dp[j] = min(dp[j], dp[1] + a[i]); } } cout \u003c\u003c dp[n] \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" L-anon的星星","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#l-anon的星星"},{"categories":["在学算法的日子里"],"content":" 题意赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。 已知一共玩了$n$局，共获得了$x$颗星星，求胜利了几局失败了几局。 如果无法知道胜利的局数和失败的局数输出-1。 数据范围$n(1\\leq n\\leq 1000)$ $x(-n\\leq x\\leq n)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。 已知一共玩了$n$局，共获得了$x$颗星星，求胜利了几局失败了几局。 如果无法知道胜利的局数和失败的局数输出-1。 数据范围$n(1\\leq n\\leq 1000)$ $x(-n\\leq x\\leq n)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路赢$k$局就是失败$n-k$局，星星数是$k-(n-k)$。如果$k$有合法值就是合法的。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, x;cin \u003e\u003e n \u003e\u003e x; if ((n + x) \u0026 1) { cout \u003c\u003c -1 \u003c\u003c '\\n'; } else { ll k = (n + x) / 2; cout \u003c\u003c k \u003c\u003c ' ' \u003c\u003c n - k \u003c\u003c '\\n'; } } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" M-mutsumi的排列连通","date":"2024-02-21","objectID":"/posts/nc24wd5/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#m-mutsumi的排列连通"},{"categories":["在学算法的日子里"],"content":" 题意有两个长度为$n$的排列上下组成$2\\times n$的矩形。 有操作：选择数字$x$，将矩形中的$x$删去。 询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。 如果无法实现，输出-1。 数据范围$T(1\\leq T\\leq 10^5)$ $n(1\\leq n\\leq 10^5)$ 排列$a(1\\leq a_i\\leq n)$ 排列$b(1\\leq b_i\\leq n)$ $n$总和不超过$10_5$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意有两个长度为$n$的排列上下组成$2\\times n$的矩形。 有操作：选择数字$x$，将矩形中的$x$删去。 询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。 如果无法实现，输出-1。 数据范围$T(1\\leq T\\leq 10^5)$ $n(1\\leq n\\leq 10^5)$ 排列$a(1\\leq a_i\\leq n)$ 排列$b(1\\leq b_i\\leq n)$ $n$总和不超过$10_5$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路特判$n=1,2$。 $n\\ge 3$的最多删2个即可实现需求。 遍历寻找是否存在$a_i=b_i$或者$a_i=b_{i+1}$或者$a_i=b_{i-1}$的情况，注意边界判断。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1), b(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e b[i]; } if (n == 1) { cout \u003c\u003c \"-1\\n\";return; } if (n == 2) { if (a[1] == b[1]) { cout \u003c\u003c \"-1\\n\"; } else { cout \u003c\u003c \"1\\n\"; } return; } for (int i = 1;i \u003c= n;i++) { if ((i != 1 \u0026\u0026 i != n \u0026\u0026 a[i] == b[i]) || (i \u003e 1 \u0026\u0026 a[i] == b[i - 1]) || (i \u003c n \u0026\u0026 a[i] == b[i + 1])) { cout \u003c\u003c \"1\\n\";return; } } cout \u003c\u003c \"2\\n\";return; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" A-智乃与瞩目狸猫、幸运水母、月宫龙虾","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#a-智乃与瞩目狸猫幸运水母月宫龙虾"},{"categories":["在学算法的日子里"],"content":" 题意在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代号。 数据范围$T(1\\leq T \\leq 10^5)$ $S,T(1\\leq |S|,|T|\\leq 50)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代号。 数据范围$T(1\\leq T \\leq 10^5)$ $S,T(1\\leq |S|,|T|\\leq 50)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路按题意判断即可 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; if (s[0] == t[0] || abs(s[0] - t[0]) == abs('a' - 'A')) { cout \u003c\u003c \"Yes\\n\"; } else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-智乃的数字手串","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#b-智乃的数字手串"},{"categories":["在学算法的日子里"],"content":" 题意一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。 数据范围$T(1\\leq T \\leq 10^4)$ $N(1\\leq N\\leq 26)$ $a_i(0\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。 数据范围$T(1\\leq T \\leq 10^4)$ $N(1\\leq N\\leq 26)$ $a_i(0\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路只有1个数时直接取走，先手赢。 2个数时：奇偶/奇奇/偶偶，都是后手赢。 3个数时：奇偶奇/偶奇偶/奇奇奇/偶偶偶，都是先手赢。 … 结束时候的状态是奇偶奇偶...奇偶，如果数量是奇数个，一定存在奇奇/偶偶，操作后可能直接结束游戏或继续，如果数量是偶数个且可操作，则转移为奇数时的状态且此时下一位操作者一定可以再操作。双方的操作不会改变他面对该数字串时数字的个数的奇偶性。也就是说，只有一直面对奇数个数的一方才能赢。 故判断原始长度，看先手是否在奇数位。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } if (n \u0026 1)cout \u003c\u003c \"qcjj\\n\"; else cout \u003c\u003c \"zn\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" D-chino’s bubble sort and maximum subarray sum(easy version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#d-chinos-bubble-sort-and-maximum-subarray-sumeasy-version"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组内的元素进行恰好$K$次相邻元素交换后，求整个数组的最大子段和。 数据范围$N,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)$ $a_i(-10^9\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组内的元素进行恰好$K$次相邻元素交换后，求整个数组的最大子段和。 数据范围$N,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)$ $a_i(-10^9\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路easy版本的K只有两种取值（0和1），N的范围不大，分类处理，进行dp即可。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll maxsum(vector\u003cll\u003ea) { int n = a.size(); ll sum = a[0]; ll b = 0; for (int i = 0;i \u003c n;i++) { if (b \u003e 0)b += a[i]; else b = a[i]; if (b \u003e sum)sum = b; } return sum; } void solve() { int n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; ll ans; if (k == 0) { ans = maxsum(a); } else { for (int i = 0;i \u003c n - 1;i++) { a[i] = a[i] ^ a[i + 1]; a[i + 1] = a[i] ^ a[i + 1]; a[i] = a[i] ^ a[i + 1]; if (i != 0) ans = max(ans, maxsum(a)); else ans = maxsum(a); a[i] = a[i] ^ a[i + 1]; a[i + 1] = a[i] ^ a[i + 1]; a[i] = a[i] ^ a[i + 1]; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" G-智乃的比较函数(easy version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#g-智乃的比较函数easy-version"},{"categories":["在学算法的日子里"],"content":" 题意给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。 cmp的排序规则是这样的： $cmp(x,y)=1$表示规定$x\u003ey$，即$x$的顺序严格先于$y$ 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 2)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。 cmp的排序规则是这样的： $cmp(x,y)=1$表示规定$x\u003ey$，即$x$的顺序严格先于$y$ 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 2)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路只有3个数、两个约束关系时，不能构成$a_x\u003ca_y$且$a_y\u003ca_z$且$a_x\u003ea_z$，只需判断最多存在2中约束关系时的逻辑是否合法。 对于两个数$x$、$y$，不合法的约束关系只有：$cmp(x,y)=1$且$cmp(y,x)=1$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003erules(4, vector\u003cint\u003e(4, -1)); bool f = true; for (int i = 0;i \u003c n;i++) { int x, y, z;cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; if (!f)continue; if (x == y \u0026\u0026 z == 1)f = false; if (z == 1 \u0026\u0026 rules[y][x] == 1) { f = false; } if (rules[x][y] == -1) { rules[x][y] = z; if (z == 1) rules[y][x] = 0; } else if (rules[x][y] != z) f = false; } if (f)cout \u003c\u003c \"Yes\\n\"; else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" H-智乃的比较函数(normal version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#h-智乃的比较函数normal-version"},{"categories":["在学算法的日子里"],"content":" 题意同G 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 50)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意同G 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 50)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路和G相比，N的范围大于2，不合法的情况增加了，但是依然只是3个数据之间判断合法性。 新增的三个关系不合法的情况有： $x\u003cy,x\u003cz,z\u003cx$ $x\\leq y,y\\leq z,z\u003cx$ 分别特判即可。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003erules(4, vector\u003cint\u003e(4, -1)); bool f = true; for (int i = 0;i \u003c n;i++) { int x, y, z;cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; if (!f)continue; if (x == y \u0026\u0026 z == 1)f = false; if (z == 1 \u0026\u0026 rules[y][x] == 1) { f = false; } if (rules[x][y] == -1) { rules[x][y] = z; if (z == 1) rules[y][x] = 0; } else if (rules[x][y] != z) f = false; } if (rules[1][2] == 1 \u0026\u0026 rules[2][3] == 1 \u0026\u0026 rules[3][1] == 1) f = false; if (rules[1][3] == 1 \u0026\u0026 rules[3][2] == 1 \u0026\u0026 rules[2][1] == 1) f = false; for (int x = 1;x \u003c= 3;x++) { for (int y = 1;y \u003c= 3;y++) { if (y == x)continue; int z = 6 - x - y; if (rules[x][y] == 0 \u0026\u0026 rules[y][z] == 0 \u0026\u0026 rules[x][z] == 1) f = false; } } if (f)cout \u003c\u003c \"Yes\\n\"; else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" L\u0026M-智乃的36倍数(easy/hard version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#lm-智乃的36倍数easyhard-version"},{"categories":["在学算法的日子里"],"content":" 题意定义一种运算$f$，可以将正整数按照字面值从左到右拼接，如：$f(123,569)=1234569$。 一个正整数数组，其中有多少对有序对$i,j(i≠j)$满足$f(a_i,a_j)$是36的倍数。 数据范围easy: $N(1\\leq N\\leq 1000)$ $a_i(1\\leq a_i \\leq 10)$ hard： $N(1\\leq N\\leq 10^5)$ $a_i(1\\leq a_i \\leq 10^{18})$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意定义一种运算$f$，可以将正整数按照字面值从左到右拼接，如：$f(123,569)=1234569$。 一个正整数数组，其中有多少对有序对$i,j(i≠j)$满足$f(a_i,a_j)$是36的倍数。 数据范围easy: $N(1\\leq N\\leq 1000)$ $a_i(1\\leq a_i \\leq 10)$ hard： $N(1\\leq N\\leq 10^5)$ $a_i(1\\leq a_i \\leq 10^{18})$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路easy版本的数据较小，直接双层循环暴力即可。 hard版本可以考虑同余，k是y的位数。 $$ f(x,y)=x\\times 10^{k}+y $$ $$ f(x,y)% 36=0 $$ $$ (x\\times 10^{k}+y)%36=0 $$ $$ (x%36\\times 10^{k}%36+y%36)%36=0 $$ 对数组预处理后，枚举以$y$结尾。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 // 暴力easy version void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } int cnt = 0; for (int i = 0;i \u003c n;i++) { for (int j = i + 1;j \u003c n;j++) { int n1 = a[i] * 10 + a[j]; int n2 = a[j] * 10 + a[i]; if (n1 % 36 == 0)cnt++; if (n2 % 36 == 0)cnt++; } } cout \u003c\u003c cnt \u003c\u003c '\\n'; } // hard version void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); map\u003cint, int\u003ecnt; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; cnt[a[i] % 36]++; } ll k = 1; vector\u003cint\u003edk(19); for (int i = 1;i \u003c 19;i++) { k *= 10; dk[i] = k % 36; } auto getlen = [](ll x) { int i = 0; while (x) { i++;x /= 10; } return i; }; ll ans = 0; for (int i = 0;i \u003c n;i++) { int x = a[i] % 36; int z = getlen(a[i]); for (int j = 0;j \u003c 36;j++) { if ((j * dk[z] + x) % 36 == 0) { ans += cnt[j]; if (j == x)ans -= 1; } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" A-Tokitsukaze and Bracelet","date":"2024-02-09","objectID":"/posts/nc24wd2/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#a-tokitsukaze-and-bracelet"},{"categories":["在学算法的日子里"],"content":" 题意根据手环的三个属性值判断手环的等级。 对攻击百分比来说，+0为100%，+1为150%，+2为200% 对体力和精神来说，+0在${29,30,31,32}$里选择，+1在${34,36,38,40}$里选择，+2固定为45 数据范围$n(1≤n≤100)$ $a_i,b_i,c_i(a_i∈{100,150,200};b_i,ci∈{29,30,31,32,34,36,38,40,45})$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意根据手环的三个属性值判断手环的等级。 对攻击百分比来说，+0为100%，+1为150%，+2为200% 对体力和精神来说，+0在${29,30,31,32}$里选择，+1在${34,36,38,40}$里选择，+2固定为45 数据范围$n(1≤n≤100)$ $a_i,b_i,c_i(a_i∈{100,150,200};b_i,ci∈{29,30,31,32,34,36,38,40,45})$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路模拟即可 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int lv1[3] = { 100,150,200 }; int lv2[9] = { 29,30,31,32,34,36,38,40,45 }; int a, b, c;cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int ans = 0; for (int i = 0;i \u003c 3;i++) { if (a == lv1[i]) { ans += i; break; } } for (int i = 0;i \u003c 9;i++) { if (b == lv2[i]) { if (i \u003c 4)ans += 0; else if (i \u003c 8)ans += 1; else ans += 2; break; } } for (int i = 0;i \u003c 9;i++) { if (c == lv2[i]) { if (i \u003c 4)ans += 0; else if (i \u003c 8)ans += 1; else ans += 2; break; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Tokitsukaze and Cats","date":"2024-02-09","objectID":"/posts/nc24wd2/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#b-tokitsukaze-and-cats"},{"categories":["在学算法的日子里"],"content":" 题意关猫，每个猫被限制在一个单元格内就算被关住了，如图： 给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。 数据范围$n, m, k (1≤n,m≤300;1≤k≤n⋅m)$ $x_i, y_i (1≤xi≤n; 1≤yi≤m)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意关猫，每个猫被限制在一个单元格内就算被关住了，如图： 给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。 数据范围$n, m, k (1≤n,m≤300;1≤k≤n⋅m)$ $x_i, y_i (1≤xi≤n; 1≤yi≤m)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路遍历坐标点判断它上下左右是否有隔板，如果没有则补充。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m, k;cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; map\u003cpair\u003cint, int\u003e, bool\u003ecats; int ans = 0; while (k--) { int x, y;cin \u003e\u003e x \u003e\u003e y; cats[{ x, y }] = true; pair\u003cint, int\u003epu = { x - 1,y }, pd = { x + 1,y }, pl = { x,y - 1 }, pr = { x,y + 1 }; int cnt = 4; if (cats.count(pu) != 0)cnt -= 1; if (cats.count(pd) != 0)cnt -= 1; if (cats.count(pl) != 0)cnt -= 1; if (cats.count(pr) != 0)cnt -= 1; ans += cnt; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" E\u0026F-Tokitsukaze and Eliminate","date":"2024-02-09","objectID":"/posts/nc24wd2/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#ef-tokitsukaze-and-eliminate"},{"categories":["在学算法的日子里"],"content":" 题意有一排n个宝石，第i个的颜色是$col_i$，可以进行如下的操作： 选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。 数据范围$T(1\\leq T\\leq 2 * 10^5)$ $n(1\\leq n\\leq 2 * 10^5)$ easy：$1\\leq col_i\\leq min(n,2)$ hard：$1\\leq col_i\\leq n$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一排n个宝石，第i个的颜色是$col_i$，可以进行如下的操作： 选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。 数据范围$T(1\\leq T\\leq 2 * 10^5)$ $n(1\\leq n\\leq 2 * 10^5)$ easy：$1\\leq col_i\\leq min(n,2)$ hard：$1\\leq col_i\\leq n$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路贪心，从右边枚举，当找到最后一种达到两次出现的颜色后，进行一次对该颜色的操作，直到所有宝石都被消除。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ecol(n + 1); set\u003cint\u003ecls; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e col[i]; cls.insert(col[i]); } int tn = cls.size(); // 颜色种数 map\u003cint, int\u003eclrs; map\u003cint, int\u003ecolors; int ans = 0; int cnt = 0; int pi = n; while (tn != 0) { for (int i = n;i \u003e 0;i--) { colors[col[i]]++; if (colors[col[i]] == 1) { cnt++; // 达到两次及以上的颜色数 if (cnt == tn) { ans++; cnt = 0; colors = clrs; pi = i - 1; } } } tn = colors.size(); colors = clrs; n = pi;cnt = 0; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" I-Tokitsukaze and Short Path (plus)","date":"2024-02-09","objectID":"/posts/nc24wd2/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#i-tokitsukaze-and-short-path-plus"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|+|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|+|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路$$ |a_i+a_j|+|a_i-a_j|= \\begin{cases} \u0026a_i+a_j+a_i-a_j\u0026=2\\times a_i\u0026\\quad a_i\\ge a_j \\\\ \u0026a_i+a_j+a_j-a_i\u0026=2\\times a_j\u0026\\quad a_i\\lt a_j \\end{cases} $$ 对$a$进行排序，计算每个数对总和的贡献，也就是比某数小的数的个数。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } sort(a.begin(), a.end()); ll ans = 0; for (int i = 0;i \u003c n;i++) { ans += a[i] * i; } cout \u003c\u003c 4 * ans \u003c\u003c '\\n'; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" J-Tokitsukaze and Short Path (minus)","date":"2024-02-09","objectID":"/posts/nc24wd2/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#j-tokitsukaze-and-short-path-minus"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|-|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|-|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路$$ |a_i+a_j|-|a_i-a_j|= \\begin{cases} \u0026a_i+a_j-a_i+a_j\u0026=2\\times a_j\u0026\\quad a_i\\ge a_j \\\\ \u0026a_i+a_j-a_j+a_i\u0026=2\\times a_i\u0026\\quad a_i\\lt a_j \\end{cases} $$ 如果$u$到$v$的直接路径的长度大于$dist(u,w)+dist(v,w)$，则取后者，假设$dist(u,v)=2\\times a_v$，则有$dist(u,w)+dist(v,w)=2\\times a_v+2\\times a_v=4\\times a_v$，则只有当$2\\times a_w$的值小于$a_v$时取后者找到数组中的最小值。 对$a$​进行排序，计算每个数对总和的贡献次数，也就是比某数或2×最小$a_i$大的数的个数。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll mn = 1e18; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; mn = min(mn, a[i]); } sort(a.begin(), a.end()); ll ans = 0; for (int i = 0;i \u003c n;i++) { ans += min(mn * 2, a[i]) * (n - i - 1); } cout \u003c\u003c 4 * ans \u003c\u003c '\\n'; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-DFS搜索","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#a-dfs搜索"},{"categories":["在学算法的日子里"],"content":" 题意给一个字符串，判断其中是否包含dfs子序列和DFS子序列。 数据范围$T(1≤T≤100)$ $n(1≤n≤50)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意"},{"categories":["在学算法的日子里"],"content":" 题意给一个字符串，判断其中是否包含dfs子序列和DFS子序列。 数据范围$T(1≤T≤100)$ $n(1≤n≤50)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路直接搜。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int f1 = 1, f2 = 1; int p = s.find('D'); if (p != -1) { p = s.find('F', p); if (p != -1) { p = s.find('S', p); if (p == -1) { f1 = 0; } } else { f1 = 0; } } else { f1 = 0; } p = s.find('d'); if (p != -1) { p = s.find('f', p); if (p != -1) { p = s.find('s', p); if (p == -1) { f2 = 0; } } else { f2 = 0; } } else { f2 = 0; } cout \u003c\u003c f1 \u003c\u003c \" \" \u003c\u003c f2 \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-关鸡","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#b-关鸡"},{"categories":["在学算法的日子里"],"content":" 题意 从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。 数据范围$T(1≤T≤1e4)$ $0≤n≤1e5$ $r,c(1≤r≤2,−1e9≤c≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意 从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。 数据范围$T(1≤T≤1e4)$ $0≤n≤1e5$ $r,c(1≤r≤2,−1e9≤c≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路分别堵住两端的管道即可，堵住有三种情况： x 1 2 3 1 2 3 或者 x ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; map\u003cpair\u003cll, ll\u003e, bool\u003efires; // 记录是否有某个点 int fl = 2, fr = 2, fn = 0; // 空白，左2右2 for (int i = 0;i \u003c n;i++) { ll r, c;cin \u003e\u003e r \u003e\u003e c; fires[{c, r}] = true; if ((c == -1 \u0026\u0026 r == 1) || (c == 0 \u0026\u0026 r == 2) || (c == 1 \u0026\u0026 r == 1))fn++; // 环绕 if (c \u003c= 0)fl = 1; if (c \u003e= 0)fr = 1; } for (auto i = fires.begin(); i != fires.end();i++) { auto pr = i-\u003efirst;bool hs = i-\u003esecond; ll c = pr.first, r = pr.second; for (int j = -1;j \u003c 2;j++) { if (fires.find({ c + j, (3 - r) }) != fires.end()) { if (c \u003c 0) { fl = 0; } // 左边不用再加 if (c \u003e 0) { fr = 0; } // 右边不用再加 } } } int ans = 3 - fn; cout \u003c\u003c min(ans, fl + fr) \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-按闹分配","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#c-按闹分配"},{"categories":["在学算法的日子里"],"content":" 题意有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度$S_{min}=\\sum_{i=1}^{n}D_i$最小，记为$S_{min}$。 然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度$S_{c}$与$S_{min}$的差值，则会允许急急鸡插队。 有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。 数据范围$n,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)$ $t_i(1≤t_i≤1e6)$ $M(0≤M≤1e18)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度$S_{min}=\\sum_{i=1}^{n}D_i$最小，记为$S_{min}$。 然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度$S_{c}$与$S_{min}$的差值，则会允许急急鸡插队。 有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。 数据范围$n,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)$ $t_i(1≤t_i≤1e6)$ $M(0≤M≤1e18)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路初始从小到大排，求每个客户的不满意度Di（做前缀和） ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, q, tc;cin \u003e\u003e n \u003e\u003e q \u003e\u003e tc; vector\u003cll\u003et(n+1); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e t[i]; } t[n] = 0; sort(t.begin(), t.end()); ll tn = 0ll; vector\u003cll\u003ed(n+1); for (int i = 0;i \u003c= n;i++) { d[i] = tn + t[i]; // 第i个人的不满意度 tn += t[i]; // 时间线 } while (q--) { ll m;cin \u003e\u003e m; ll l = 0, r = n; while (l \u003c r) { ll x = (l + r) \u003e\u003e 1; // 插在x号客户前面 if ((n - x) * tc \u003c= m) { // 可以 r = x; } else { l = x + 1; } } // 最早：插在l的前面 cout \u003c\u003c d[l] + tc \u003c\u003c endl; } } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-本题又主要考察了贪心","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#d-本题又主要考察了贪心"},{"categories":["在学算法的日子里"],"content":" 题意大骗子！ n个人的比赛，还剩m局，每局的结果有： 胜方加3分，败方不得分 平局各加一分 求一号选手最好的名次（并列的取并列的排名） 数据范围$T(1≤T≤100)$ $n,m(2≤n≤10,1\\leq m\\leq 10)$ $0\\leq a_i\\leq 100$ $u_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意大骗子！ n个人的比赛，还剩m局，每局的结果有： 胜方加3分，败方不得分 平局各加一分 求一号选手最好的名次（并列的取并列的排名） 数据范围$T(1≤T≤100)$ $n,m(2≤n≤10,1\\leq m\\leq 10)$ $0\\leq a_i\\leq 100$ $u_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路不会贪，数据范围小可以直接dfs暴力每种情况取最优，$O(3^m)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 int dfs(vector\u003cint\u003ea, vector\u003cpair\u003cint, int\u003e\u003etb, int now) { if (now == tb.size()) { // 最后一局 int rk = 1; for (int i = 1;i \u003c a.size();i++) { if (a[i] \u003e a[1])rk++; } return rk; } int ret = a.size() - 1; int u = tb[now].first, v = tb[now].second; // u赢 a[u] += 3; ret = min(ret, dfs(a, tb, now + 1)); a[u] -= 3; // v赢 a[v] += 3; ret = min(ret, dfs(a, tb, now + 1)); a[v] -= 3; // 平局 a[v] += 1;a[u] += 1; ret = min(ret, dfs(a, tb, now + 1)); a[v] -= 1;a[u] -= 1; return ret; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003ea(n + 1); for (int i = 1;i \u003c= n;i++)cin \u003e\u003e a[i]; vector\u003cpair\u003cint, int\u003e\u003etb; for (int i = 0;i \u003c m;i++) { int u, v;cin \u003e\u003e u \u003e\u003e v; tb.push_back({ u,v }); } int ans = dfs(a, tb, 0); cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" F-鸡数题","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#f-鸡数题"},{"categories":["在学算法的日子里"],"content":" 题意求有多少个长为m的数组a同时满足以下条件： 对任意i，都有$a_i\u003e0$ 数组a严格递增 $a_1|a_2|…|a_{m-1}|a_m=2^n-1$（其中|为按位或操作） 对任意$i≠j$有$a_i\u0026a_j=0$（其中\u0026为按位与操作） 答案要对$10^9+7$取模 数据范围$1\\leq n,m\\leq 10^5$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意求有多少个长为m的数组a同时满足以下条件： 对任意i，都有$a_i\u003e0$ 数组a严格递增 $a_1|a_2|…|a_{m-1}|a_m=2^n-1$（其中|为按位或操作） 对任意$i≠j$有$a_i\u0026a_j=0$（其中\u0026为按位与操作） 答案要对$10^9+7$取模 数据范围$1\\leq n,m\\leq 10^5$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路条件3说明，在2进制下的$2^n-1$（也就是数$(\\overbrace{11\\dots111}^n)_2$）每一位1都至少在$a_1~a_m$中出现一次，数组a的大小为m，联合条件4说明每个数位上的1最多只能出现1次，所以问题转化为，将n个不同位置上1分配给m个数，且每个数至少有1个1。可知$n\\geq m$。 也就是一个第二类斯特林数$n\\brace m$。 递推式： $$ {n\\brace k}={n-1\\brace k-1}+k{n-1\\brace k} $$ 边界是：${n\\brace m}=[n=0]$。 通项： $$ {n\\brace m}=\\sum_{i=0}^m \\frac{(-1)^{m-i}\\times i^n}{i!\\times (m-i)!} $$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; if (n \u003c m) { cout \u003c\u003c \"0\\n\"; return; } // 阶乘 vector\u003cll\u003efac; fac.push_back(1);fac.push_back(1); for (ll i = 2;i \u003c= n;i++) { ll faci = (fac.back() * i) % mod; fac.push_back(faci); } vector\u003cll\u003efinv(n + 1); // 阶乘的逆元 finv[n] = powerMod(fac[n], mod - 2, mod); for (int i = n - 1;i \u003e= 0;i--) { finv[i] = finv[i + 1] * (i + 1) % mod; } ll ans = 0ll; for (ll i = 0;i \u003c= m;i++) { ll ansi = 1ll; if ((m - i) \u0026 1)ansi = -1; ansi *= powerMod(i, n, mod); ansi *= finv[i] * finv[m - i] % mod; ans = (ans + ansi) % mod + mod; // 加一个mod取正数 ans %= mod; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" G-why买外卖","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#g-why买外卖"},{"categories":["在学算法的日子里"],"content":" 题意一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。 数据范围$T(1≤T≤1e4)$ $n,m(1≤n≤1e5,1≤m≤1e9)$ $a_i,b_i(1≤a_i,b_i≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。 数据范围$T(1≤T≤1e4)$ $n,m(1≤n≤1e5,1≤m≤1e9)$ $a_i,b_i(1≤a_i,b_i≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路前缀和，按照ai升序排列，能用ai的券的食物一定也能使用原价小于等于ai的所有的券，最后枚举原价即可。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; map\u003cll, ll\u003ediscnt; for (int i = 0;i \u003c n;i++) { ll a, b;cin \u003e\u003e a \u003e\u003e b; discnt[a] += b; // 一次前缀和，合并相同ai的券 } for (auto i = discnt.begin(); i != discnt.end();i++) { ll price = i-\u003efirst, discount = i-\u003esecond; auto j = i;j++; if (j != discnt.end()) { (j-\u003esecond) += discount; // 第二次前缀和，合并小于等于ai的券 } } ll x = m; for (auto i = discnt.begin();i != discnt.end();i++) { ll price = i-\u003efirst, discount = i-\u003esecond; if (m + discount \u003e= price)x = m + discount; // 枚举，取最大原价 } cout \u003c\u003c x \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" I-It’s bertrand paradox. Again!","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#i-its-bertrand-paradox-again"},{"categories":["在学算法的日子里"],"content":" 题意有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。 bit-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$。 随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤2重新生成$r$，若满足，则将该圆加入到结果中。 buaa-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$，随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤1重新生成$x,y,r$，若满足，则将该圆加入到结果中。 数据范围$n=10^5$ $0\u003c x_i,y_i\u003c 100,0\u003c r_i\\leq100$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。 bit-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$。 随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤2重新生成$r$，若满足，则将该圆加入到结果中。 buaa-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$，随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤1重新生成$x,y,r$，若满足，则将该圆加入到结果中。 数据范围$n=10^5$ $0\u003c x_i,y_i\u003c 100,0\u003c r_i\\leq100$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路两种方法中，第一种的x和y的取值更容易受到r的限制，在r均匀分布在$[1,100]$的情况下，bit-noob的方法相对于buaa-noob的方法，x,y会更偏向集中在原点附近。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; int cnt = 0; for (int i = 0;i \u003c n;i++) { int x, y, r;cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; if (abs(x) \u003c= 50 \u0026\u0026 abs(y) \u003c= 50)cnt++; } if (cnt \u003c n - cnt)cout \u003c\u003c \"bit-noob\\n\"; else cout \u003c\u003c \"buaa-noob\\n\"; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" H-01背包，但是bit","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#h-01背包但是bit"},{"categories":["在学算法的日子里"],"content":" 题意$n$个物品，每个物品有价值$v_i$和重量$w_i$，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过$m$的最大价值和 数据范围$T(1≤T≤10^4)$ $n,m(1≤n≤10^5,0\\leq m\\leq 10^8)$ $v_i,w_i(0\\leq v_i,w_i\\leq 10^8)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意$n$个物品，每个物品有价值$v_i$和重量$w_i$，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过$m$的最大价值和 数据范围$T(1≤T≤10^4)$ $n,m(1≤n≤10^5,0\\leq m\\leq 10^8)$ $v_i,w_i(0\\leq v_i,w_i\\leq 10^8)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路枚举m右移位后的数字，能被这个位数低于m、数位上全是1的新m覆盖的都能拿 状态转换：拿新筛出来的可选与原来的比较，取价值较大的那个 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ev(n), w(n); ll ans = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e v[i] \u003e\u003e w[i]; if ((w[i] | m) == m)ans += v[i]; } for (ll i = m;i \u003e 0;i -= i \u0026 -i) { // i每次抹去最后一位1，再重新取全1 ll xi = i - 1; ll ansi = 0; for (int j = 0;j \u003c n;j++) { if ((w[j] | xi) == xi) ansi += v[j]; } ans = max(ans, ansi); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" L-要有光","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#l-要有光"},{"categories":["在学算法的日子里"],"content":" 题意 如图，有一点光源在轨迹L($x=c,y=0,0\\leq z\\leq d$)上移动，存在一宽为$2w$，高为$h$的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。 数据范围$1\\leq T\\leq 10^4$ $1\\leq c,d,h,w\\leq 10^4$ 输出浮点数误差小于$10^{-4}$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意 如图，有一点光源在轨迹L($x=c,y=0,0\\leq z\\leq d$)上移动，存在一宽为$2w$，高为$h$的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。 数据范围$1\\leq T\\leq 10^4$ $1\\leq c,d,h,w\\leq 10^4$ 输出浮点数误差小于$10^{-4}$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路当点光源放在地面上时投影最大(z=0时)，这个投影是一个等腰梯形（大三角形截去一个小三角形）。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { double c, d, h, w;cin \u003e\u003e c \u003e\u003e d \u003e\u003e h \u003e\u003e w; double ans = 3.0 * c * w; cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" M-牛客老粉才知道的秘密","date":"2024-02-02","objectID":"/posts/nc24wd1/:0:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#m-牛客老粉才知道的秘密"},{"categories":["在学算法的日子里"],"content":" 题意 就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。 数据范围$1\\leq T\\leq 10^5$ $6\\leq n\\leq 10^9$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-9"},{"categories":["在学算法的日子里"],"content":" 题意 就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。 数据范围$1\\leq T\\leq 10^5$ $6\\leq n\\leq 10^9$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-9"},{"categories":["在学算法的日子里"],"content":" 思路判断n是否是6的倍数即可，如果正好是6的倍数，那么返回时并不产生新的位置。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-9"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; if (n % 6)cout \u003c\u003c n / 6 + n / 6 \u003c\u003c '\\n'; else cout \u003c\u003c n / 6 \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":null,"tags":["算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-9"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#线段树segment-tree"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#模板线段树"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#线段树的建立"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#如何更新数据"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#懒标记延迟标记"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":null,"tags":["算法","线段树"],"title":"线段树模板","uri":"/posts/seg_tree/#查询区间"},{"categories":["在学算法的日子里"],"content":" 1.1图的定义上课讲过一大堆这里不再赘述，直接学习代码实现。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:1","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#11图的定义"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w\u003cb.w; if(a.from==b.from) return a.to\u003cb.to; return a.from\u003cb.from; } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct NODE { int from, to, w; }edge[maxm]; int head[maxn]; bool cmp(NODE a, NODE b) { if (a.from == b.from \u0026\u0026 a.to == b.to) return a.w \u003c b.w; if (a.from == b.from) return a.to \u003c b.to; return a.from \u003c b.from; } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 读入数据 for (int i = 0;i \u003c m;i++) cin \u003e\u003e edge[i].from \u003e\u003e edge[i].to \u003e\u003e edge[i].w; // 排序 sort(edge, edge + m, cmp); // 初始化head memset(head, -1, sizeof(head)); // 制成点位数组 head[edge[0].from] = 0; // 初始化 // edge数组中起点为点i的在数组里的第一条边在下标head[i]处 for (int i = 1;i \u003c m;i++) if (edge[i].from != edge[i - 1].from) // 表明是新的起始点 head[edge[i].from] = i; // 遍历输出各边信息（按点位输出） for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c \"以点v\" \u003c\u003c i \u003c\u003c \"为起点的边：\" \u003c\u003c endl; for (int j = head[i];j \u003c m \u0026\u0026 edge[j].from == i;j++) { cout \u003c\u003c \"v\" \u003c\u003c edge[j].from \u003c\u003c \"--\u003ev\" \u003c\u003c edge[j].to \u003c\u003c \" 权值为：\" \u003c\u003c edge[j].w \u003c\u003c \" 该边在数组edge中的序号为\" \u003c\u003c j \u003c\u003c endl; } cout \u003c\u003c endl; } return 0; } // Output： /* 以点v1为起点的边： v1--\u003ev2 权值为：4 该边在数组edge中的序号为0 v1--\u003ev6 权值为：9 该边在数组edge中的序号为1 以点v2为起点的边： 以点v3为起点的边： v3--\u003ev1 权值为：22 该边在数组edge中的序号为2 v3--\u003ev2 权值为：19 该边在数组edge中的序号为3 以点v4为起点的边： v4--\u003ev3 权值为：17 该边在数组edge中的序号为4 以点v5为起点的边： v5--\u003ev8 权值为：29 该边在数组edge中的序号为5 以点v6为起点的边： v6--\u003ev1 权值为：12 该边在数组edge中的序号为6 v6--\u003ev5 权值为：9 该边在数组edge中的序号为7 v6--\u003ev7 权值为：4 该边在数组edge中的序号为8 以点v7为起点的边： v7--\u003ev4 权值为：25 该边在数组edge中的序号为9 以点v8为起点的边： v8--\u003ev3 权值为：11 该边在数组edge中的序号为10 v8--\u003ev7 权值为：7 该边在数组edge中的序号为11 */ 邻接表图的一种链式存储结构，把图G中所有邻接于v~i~的顶点链接成为一个v~i~的单链表。 三种实现方法： 1. 动态建表动态建表的时间效率是O(m)，空间效率是O(m)，主要的时间损耗在于不断地申请新空间，且判断任意两个点之间是否有边相连的效率也低（需要搜索各个点的单链表）(感觉还好？)。 数据结构： struct EdgeNode { int to; // 终点 int w; // 权值 EdgeNode* next; // 下一边的指针 }; struct VNode { int from; // 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点） EdgeNode* first; // 邻接表的头指针 }; 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 EdgeNode* next; // 下一边的指针 }; struct VNode { int from; // 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点） EdgeNode* first; // 邻接表的头指针 }; VNode Adjlist[maxn]; // 全图 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; // 创建一个新的边结构数据 EdgeNode* p = new EdgeNode(); // 给该数据传值 p-\u003eto = ti; p-\u003ew = wi; // 该新边的next指针指向上一个链接到起点为fi的单链表中的起点 /* （相当于在前面插入，这点可以观察遍历输出部分发现，比如先读入的v1--\u003ev2后读入的v1--\u003ev6，但在储存时我们将后来的v1--\u003ev6插入在了v1--\u003ev2前面） */ p-\u003enext = Adjlist[fi].first; // 将起点为fi的单链表的指针更新为这个新传入边的地址 Adjlist[fi].first = p; } // 遍历 for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c \"点v\" \u003c\u003c i \u003c\u003c \"为起点的边：\" \u003c\u003c endl; int ind = 0; for (EdgeNode* k = Adjlist[i].first;k != NULL;k = k-\u003enext) { // 指针遍历该链表至结束 cout \u003c\u003c \"v\" \u003c\u003c i \u003c\u003c \" --\u003ev\" \u003c\u003c k-\u003eto \u003c\u003c \" 权值为：\" \u003c\u003c k-\u003ew \u003c\u003c \" 该边记录在点v\" \u003c\u003c i \u003c\u003c \"的单链表的第\" \u003c\u003c ind++ \u003c\u003c \"个\" \u003c\u003c endl; } cout \u003c\u003c \"点v\" \u003c\u003c i \u003c\u003c \"为的度数为：\" \u003c\u003c ind \u003c\u003c endl; cout \u003c\u003c endl; } return 0; } // Output: /* 点v1为起点的边： v1 --\u003ev6 权值为：9 该边记录在点v1的单链表的第0个 v1 --\u003ev2 权值为：4 该边记录在点v1的单链表的第1个 点v1为的度数为：2 点v2为起点的边： 点v2为的度数为：0 点v3为起点的边： v3 --\u003ev2 权值为：19 该边记录在点v3的单链表的第0个 v3 --\u003ev1 权值为：22 该边记录在点v3的单链表的第1个 点v3为的度数为：2 点","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#12图的存储"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#邻接矩阵"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#前向星"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#邻接表"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#1-动态建表"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#2-vector模拟链表实现"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#3-静态建表链式前向星"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v~0~出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v~0~的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#13图的遍历"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v~0~出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v~0~的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#深度优先遍历"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v~0~出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v~0~的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":null,"tags":["图论","DFS","BFS"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#广度优先遍历"},{"categories":["在学算法的日子里"],"content":" 拓扑排序前提：拓扑排序是对有向无环图来说的，无向图、有环图都不存在拓扑排序。 拓扑排序是将图G中的所有顶点排成一个线性序列，使得对于任意一堆有边顶点\u003cu, v\u003e，在线性序列中，u都出现在v之前。 拓扑排序可以反应某种方案是否是切实可行的。 一般一个图是否是有向图我们分析题意要求就能知道，但是究竟有没有环存在，就不是瞄一眼就能发现的了，所以，虽然拓扑排序是针对有向无环图而言的一种性质，但是反过来，一个有向图是否有拓扑排序，也可以反过来解决该图是否存在环、以及存在多少环等等问题，也就是某种方案可不可行。 接下来我们通过代码学习如何获得一个有向图的拓扑排序： ","date":"2024-01-05","objectID":"/posts/topo/:1:0","series":null,"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#拓扑排序"},{"categories":["在学算法的日子里"],"content":" 算法思路拓扑排序一定是从入度为0的顶点开始的（假如入度不为0不就是有点要排在它的前面了嘛qwq），所以，我们通过删除点(及由该点出发的所有边)的方法可以不断更新制作拓扑排序时当前图的状态，这样的步骤不断执行，直到图中能删的点(入度为0的点)都删光了，我们的程序就执行到了终点。 ","date":"2024-01-05","objectID":"/posts/topo/:1:1","series":null,"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#算法思路"},{"categories":["在学算法的日子里"],"content":" 程序实现我们还是用链式前向星来存储图 使用队列来记录我们的拓扑序列（说是队列不过其实还是个每次只读末尾的数组啦，也没用到queue容器qwq） 寻找拓扑序列样例代码： // 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录 int queue[maxn]; int iq = 0; // 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法) // 先将图里入度为0的顶点加入队列 // 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq) for (int i = 1;i \u003c= n;i++) if (indegree[i] == 0) queue[iq++] = i; // 删点，对队列做更新 for (int i = 0;i \u003c iq;i++) { // 按队列顺序删点删边(终点的入度--就算删掉这条边了) for (int k = head[queue[i]];k != 0;k = Edge[k].next) { indegree[Edge[k].to]--; if (indegree[Edge[k].to] == 0) queue[iq++] = Edge[k].to; } } 这时候我们得到了一个序列，其实这个序列无论如何都能得到（空序列也是序列！），所以接下来需要判断一下是否是拓扑序列，同时也就判断出当前的图是不是有向无环图啦。 判断样例代码： cout \u003c\u003c \"iq=\" \u003c\u003c iq \u003c\u003c \" n=\" \u003c\u003c n \u003c\u003c endl; if (iq == n) { cout \u003c\u003c \"有拓扑序列：\" \u003c\u003c endl; // 输出拓扑排序序列 for (int i = 0;i \u003c iq;i++) cout \u003c\u003c queue[i] \u003c\u003c \" \"; cout \u003c\u003c endl; } else { cout \u003c\u003c \"没有拓扑序列\" \u003c\u003c endl; } 前面的输入样例是个有向有环图，这里添加一组有向无环图的样例用于学习： graph LR v1((v1))--5--\u003ev2((v2)) v1((v1))--6--\u003ev3((v3)) v2((v2))--9--\u003ev4((v4)) v3((v3))--10--\u003ev5((v5)) v3((v3))--4--\u003ev6((v6)) v4((v4))--12--\u003ev6((v6)) v5((v5))--6--\u003ev7((v7)) v6((v6))--9--\u003ev7((v7)) v7((v7))--24--\u003ev8((v8)) v6((v6))--3--\u003ev8((v8)) 8 10 1 2 5 1 3 6 2 4 9 3 5 10 3 6 4 4 6 12 5 7 6 6 7 9 6 8 3 7 8 24 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int indegree[maxn]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 初始化为0应该也冇问题，反正只是方便我们判断终点啦，想用向量也行qwq // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; // 记录各个顶点的入度(当该点是终点的时候++qwq) indegree[ti]++; } // 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录 int queue[maxn]; int iq = 0; // 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法) // 先将图里入度为0的顶点加入队列 // 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq) for (int i = 1;i \u003c= n;i++) if (indegree[i] == 0) queue[iq++] = i; // 删点，对队列做更新 for (int i = 0;i \u003c iq;i++) { // 按队列顺序删点删边(终点的入度--就算删掉这条边了) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { indegree[Edge[k].to]--; if (indegree[Edge[k].to] == 0) queue[iq++] = Edge[k].to; } } // 这里可以判断是否有环啦，假如此时iq的值小于顶点的数量n，不就是说明接下来没法删边了嘛，也就是说最后剩下了环。 cout \u003c\u003c \"iq=\" \u003c\u003c iq \u003c\u003c \" n=\" \u003c\u003c n \u003c\u003c endl; if (iq == n) { cout \u003c\u003c \"有拓扑序列：\" \u003c\u003c endl; // 输出拓扑排序序列 for (int i = 0;i \u003c iq;i++) cout \u003c\u003c queue[i] \u003c\u003c \" \"; cout \u003c\u003c endl; } else { cout \u003c\u003c \"没有拓扑序列\" \u003c\u003c endl; } return 0; } 该算法在O(m)的时间内对indegree数组进行初始化，在O(n)时间内对queue进行初始化，后面的部分虽然看起来是两层循环，但实际上是m条边各遍历一次，所以时间复杂度只有O(m)而已，所以一共也就O(m+n)的复杂度。还是很友好滴。 ","date":"2024-01-05","objectID":"/posts/topo/:1:2","series":null,"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#程序实现"},{"categories":["关于Hugo的一些设置"],"content":"今天打算转帖原来发过的一篇博文时，遇到了Markdown中嵌入的Mermaid无法正常显示的问题，Mermaid可以内嵌于Markdown中通过代码显示svg绘图，但是显然hugo本身不含，这篇记录如何调整hugo达到如下效果转换： ","date":"2023-12-23","objectID":"/posts/mermaid_js/:0:0","series":null,"tags":["Hugo","Markdown","Mermaid"],"title":"【拓展Markdown】为hugo渲染Mermaid绘图","uri":"/posts/mermaid_js/#"},{"categories":["关于Hugo的一些设置"],"content":" 效果 调整之前 调整之后 ","date":"2023-12-23","objectID":"/posts/mermaid_js/:0:1","series":null,"tags":["Hugo","Markdown","Mermaid"],"title":"【拓展Markdown】为hugo渲染Mermaid绘图","uri":"/posts/mermaid_js/#效果"},{"categories":["关于Hugo的一些设置"],"content":" 配置方法这里涉及到hugo中设置代码高亮的配置，我们检查hugo.toml 写入/修改： [markup.highlight] codeFences = true guessSyntax = false # 注意这一项 # hl_Lines = \"\" lineAnchors = \"\" lineNoStart = 1 lineNos = true lineNumbersInTable = true noClasses = false style = \"monokai\" tabWidth = 4 在./layouts/partials/下新建一个mermaid.html 写入： {{ if .Params.mermaid }} \u003cscript src=\"https://cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js\" integrity=\"sha256-KqisLh8jVMBRjpNkOhH5W9VWs+F6x6vQksLqxs7+x9A=\" crossorigin=\"anonymous\" \u003e\u003c/script\u003e \u003cscript\u003e // Replace mermaid pre.code to div Array.from(document.getElementsByClassName(\"language-mermaid\")).forEach( (el) =\u003e { el.parentElement.outerHTML = `\u003cdiv class=\"mermaid\"\u003e${el.innerText}\u003c/div\u003e`; } ); \u003c/script\u003e \u003cstyle\u003e /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u003c/style\u003e {{ end }} 然后在./layouts/_default/baseof.html引入： \u003cbody\u003e ... {{ partial \"mermaid.html\" .}} \u003c/body\u003e ","date":"2023-12-23","objectID":"/posts/mermaid_js/:0:2","series":null,"tags":["Hugo","Markdown","Mermaid"],"title":"【拓展Markdown】为hugo渲染Mermaid绘图","uri":"/posts/mermaid_js/#配置方法"},{"categories":["关于Hugo的一些设置"],"content":" 效果解决了之前一直没有解决的一个小bug——我的hugo没有办法渲染Markdown里数学公式捏qwq 现在成功从图1到图2了！ 调整之前 调整之后 这里记录一下干了什么吧qwq 数学公式与代码高亮不同，hugo本身不支持渲染数学公式，所以我们在前端新加一个html页面去处理这个渲染问题。 MathJax官方介绍了3中引入mathjax的方法，考虑到我们的页面还需要渲染到行内公式，我们选择全局引入。 官方提供：Three Ways to Use MathJax in Node — MathJax 3.2 documentation ","date":"2023-12-23","objectID":"/posts/mathjax_js/:0:1","series":null,"tags":["Hugo","MathJax","Markdown"],"title":"【拓展Markdown】为hugo渲染数学公式","uri":"/posts/mathjax_js/#效果"},{"categories":["关于Hugo的一些设置"],"content":" 方法在./layouts/partials/下新建一个mathjax.html 在./layouts/partials/extend_head.html引入： {{partial \"mathjax.html\" .}} 在mathjax.html写入下方代码： {{ if .Params.math }} \u003cscript\u003e MathJax = { tex: { inlineMath: [[\"$\", \"$\"]], }, displayMath: [ [\"$$\", \"$$\"], [\"\\[\\[\", \"\\]\\]\"], ], svg: { fontCache: \"global\", }, }; \u003c/script\u003e \u003cscript src=\"https://polyfill.io/v3/polyfill.min.js?features=es6\"\u003e\u003c/script\u003e \u003cscript id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\" \u003e\u003c/script\u003e {{ end }} 然后在需要显示数学公式的markdown文档中添加如下参数： +++ ... math = true +++ ","date":"2023-12-23","objectID":"/posts/mathjax_js/:0:2","series":null,"tags":["Hugo","MathJax","Markdown"],"title":"【拓展Markdown】为hugo渲染数学公式","uri":"/posts/mathjax_js/#方法"},{"categories":["在学算法的日子里"],"content":" 思维先行我们要找某点到某点的最短路径(记为点u到点v)，这样的路径只能从两种路径中选择—— u和v之间有边连接时，存在边(u, v)，不存在的话可以视作这两点的距离无限大 u和v可以通过某些点中转相连，这个(最短的)中转路径 很明显，我们选最短路径肯定是在这两种路径当中选最短的来作为u和v的最短距离，而路径选择2又可以不断拆分，比如我们有u -\u003e P -\u003e v我们再去寻找这条路径的最短时，可以分为u -\u003e P最短+P -\u003e v最短，再去寻找中转点…而且每次取最小值最小的+最小的肯定得最小的（有一点贪心的感觉）。 那么思维布置到这，我们来看看这个寻找最短路径的几种算法： ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:1","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#思维先行"},{"categories":["在学算法的日子里"],"content":" Floyd算法\u0026Bellman-Ford算法 ==Floyd算法== 这个算法就是刚刚思维里的算法的朴素实现了，动态规划思维，不断去尝试增加节点来找最小值。伪代码如下： #define INF 0x3f3f3f3f dist[maxn][maxn]; // dist[u][v]记录从点u到点v的距离 // 初始化时dist[n][n]=0, 两点有边则记录为w\u003cu, v\u003e，其他的就是INF void Floyd(int n){ // 一共有n个点，我们遍历填充dist[][]数组来计算所有的距离 for(int p=1 ;p \u003c= n;p++){ // 点p是中转点 for(int u=1;u\u003c=n;u++){ for(int v=1;v\u003c=n;v++){ dist[u][v] = min(dist[u][v], dist[u][p]+dist[p][v]); } } } } 很明显，这个算法有O(n^3)的复杂度，并不好，而且开的dist[maxn][maxn]数组空间也大，和之前学习存储图时一样，如果图比较稀疏，浪费的空间也大。 如何优化呢？ 先看算法上，我们在选择中间点p的时候，我们很容易想到——并不是所有的点1~点n和u都有边，所以假如我们按边存储成为邻接表(前向星/链式前向星)，我们在搜索边的时候就能直接在已有的\u003cu, p\u003e边上进行选择。 TIP：Floyd算法可以获得所有点之间的最短距离，所以在需要处理多源最短路且数据规模比较小的时候会选择它。 我们更关心单源最短路问题，接下来我们的问题就假定为：找到以点v~1~为起点的最短路。 由于是确定起点的单源最短路，我们接下来记录距离的数组只用开一维就行。 初始化：dist[1]=0, dist[v]=distance[1][v], 其他的置INF。 在Bellman-Ford算法中，我们假设不存在负权环（有负权环我们就会发现每绕一次dist都在变小，而我们取min（dist[v],weight(p-\u003ev)+dist[v]）肯定会把路径上的这个负权环走超过n遍），那么从v~1~到任何点的路径上点的个数都不会大于总点数n，所以Bellman-Ford算法就直接暴力搜n次来找最短路,到这里我们先代码实现一下这样的思路： 给出一个图例like this： graph LR v1((v1))-.4.-\u003ev2((v2)) v1((v1))-.3.-\u003ev3((v3)) v1((v1))-.8.-\u003ev4((v4)) v2((v2))-.2.-\u003ev6((v6)) v7((v7))-.5.-\u003ev6((v6)) v7((v7))-.1.-\u003ev4((v4)) v3((v3))-.1.-\u003ev7((v7)) v4((v4))-.5.-\u003ev3((v3)) v4((v4))-.5.-\u003ev5((v5)) 样例： 7 9 1 2 4 1 3 3 1 4 8 2 6 2 3 7 1 4 3 5 4 5 5 7 6 5 7 4 1 参考代码like this： #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; void BellmanFord(int vn) { // 初始化dist[] fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; int turn = n - 1; while (turn--) // 下方的遍历重复n-1遍，保证可以更新全部的dist[] for (int ei = 0;ei \u003c m;ei++) dist[Edge[ei].to] = min(dist[Edge[ei].to], dist[Edge[ei].from] + Edge[ei].w); // 这里为了方便获得查看的边的起点，可以在储存边的起点的时候加一个from的信息(否则就要先去找起点是谁) } int main() { cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } BellmanFord(1); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; // -\u003e0 4 3 5 10 6 4 return 0; } IDEA：我们在这个算法中可以发现，我们选边的时候对于它终点于何处并不关心，相反，我们会关心它的起点的信息（我们要算的源起点到该边的起点的距离），所以直接在存边的时候添加起点(from)的记录会方便我们确定起点。 虽然上文提到我们不考虑负权环的存在，但是我们可以想象，如果存在负权环，该图进入Bellman-Ford算法之后会有神奇的数据产生，我们试试看： 给我们的测试数据添加一个负权边： 7 10 1 2 4 1 3 3 1 4 8 2 6 2 3 7 1 4 3 5 4 5 5 7 7 -9 7 6 5 7 4 1 graph LR v1((v1))-.4.-\u003ev2((v2)) v1((v1))-.3.-\u003ev3((v3)) v1((v1))-.8.-\u003ev4((v4)) v2((v2))-.2.-\u003ev6((v6)) v7((v7))-.5.-\u003ev6((v6)) v7((v7))-.1.-\u003ev4((v4)) v3((v3))-.1.-\u003ev7((v7)) v4((v4))-.5.-\u003ev3((v3)) v4((v4))-.5.-\u003ev5((v5)) v7((v7))-. -9 .-\u003ev7((v7)) 同样的程序跑出来的结果是： 0 4 -35 -49 -35 -45 -50 原来的结果： 0 4 3 5 10 6 4 思考：不管有没有负权环，我们得到的其实都是合理的最短路径，但是存在负权环会使得到某些点的最短距离一定会减少（加上一个负数肯定变小，而我们选择的是较小的那个路径），所以有负权环时，最短路径(假设路径上的点的数量没有限制)其实可以无限短，我们先前用暴力循环所有的点来保证所有的dist数组能够更新到最佳，那么假如有负权环在其中，dist数组没有最佳状态，所以我们简单的多循环一边，假如没有负权环，再多循环一边并不会改变dist数组里的值，如果有负权环，dist数组里一定有值改变。我们试试看： 原来保证得到最佳只需要暴力循环n-1遍，得结果： 0 4 -35 -49 -35 -45 -50 暴力n次的结果： 0 4 -44 -58 -44 -54 -59 符合我们的想法。 不过啊这个算法还是有暴力的成分，我们先前提到的只要遍历那些起点可直接到达的点等等想法还没实现，Bellman-Ford算法的时间复杂度有O(nm)，我们讨论算法的对于这样的复杂度肯定还是不满意的。 我们再回忆一下整个搜索过程：其实我们关系的只是可以拓展的可能当中最小的是哪个，为了找到最小的那个，我们上面用了搜索全部的边、点的方法。那么我们的目的还是还是：有没有一种可以维护数据结构的方式，让我们更容易找到最小的那个可能？ 于是队列优化进入思维 ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:2","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#floyd算法bellman-ford算法"},{"categories":["在学算法的日子里"],"content":" SPFA算法我们找u -\u003e p -\u003e v路径时，p点的选择方法会实际影响我们的复杂度。我们的目的肯定是去更新u可以直接到达的点，而下一次就是p可以直接到达的点… SPFA算法使用一个队列去记录这些可以直接到达的点(也就是答案可能在的路径上)。 SPFA是如何做到“只更新可能更新的点”的？ 只让当前点能到达的点入队 如果一个点已经在队列里，便不重复入队 如果一条边的起点还没被更新，那么它的终点不入队 也就是说：当一个点入队了，代表它还在等待更新，当一个点出队了，那么它一定在当前经过最好的更新了。 会有一个点入队了更新之后再次入队的情况吗？会有这种可能。 来看看代码实现吧： // 因为queue其实没有查找操作，所以简单用个bool型数组记录点p在队列中?inqueue[p]=true:inque[p]=false bool inqueue[maxn]; void SPFA(int vn) { // 寻找vn到各个点的最短路径，记录在dist[]数组中。 // 初始化dist[] fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; queue\u003cint\u003e updates; updates.push(vn); // 将vn点加入待更新队列 while (!updates.empty()) { // 获得队首点，并把它移除待更新队列 int firstp = updates.front(); updates.pop(); inqueue[firstp] = false; // 标记firstp已经不在队列中 for (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) { // 遍历k可以直接到达的点to if (dist[to] \u003e dist[firstp] + Edge[k].w) { dist[to] = dist[firstp] + Edge[k].w; if (!inqueue[to]) { updates.push(to); inqueue[to] = true; } } } } } SPFA算法的时间复杂度并不稳定，可以预想，在极端的情况下，SPFA算法的复杂度可以和Bellman-Ford算法一样是O(nm)（不过随机数据模拟的算法复杂度大概是O(m + nlogn)） SPFA算法也可以判断负权环的存在：若一个点入队次数超过n次，接下来无论怎么更新队列都不会为空，可以据此判断是否有负权环。 emmm优化了一点的BellmanFord算法？(思考) 接下来介绍复杂度稳定的贪心算法：==Dijstra算法== ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:3","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#spfa算法"},{"categories":["在学算法的日子里"],"content":" ☆☆☆Dijstra算法Dij假设没有负边 因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。 思路：起点u可以直接到达的点中，最近的点p对应的e\u003cu, p\u003e一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; int path[maxm]; // 储存路径(存边) struct Polar { // 注意每个dist其实是一对一的绑定了它的索引的，直接写什么return dist[a]\u003edist[b]会破坏堆的结构，可能会让dist[a]和dist[b]的索引变化。 int id, dist; Polar(int dist, int id) :dist(dist), id(id) {} // 对结构体中传数据，和下面这种写法作用一样： // Polar(int d, int d_id) { // dist = d; // id = d_id; // } // 重载运算符\u003c bool operator\u003c(const Polar\u0026 P)const { return dist \u003c P.dist; } }; struct cmp { // // 重写仿函数法： bool operator ()(Polar a, Polar b) { // 重载()运算符，使其成为一个仿函数 return a.dist \u003e b.dist; } }; // priority_queue\u003cPolar, vector\u003cPolar\u003e, cmp\u003e q; priority_queue\u003cPolar\u003e q; bool visited[maxn]; void Dij(int vn) { fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; q.push(Polar(0, vn)); while (!q.empty()) { int pid = q.top().id; q.pop(); if (visited[pid]) // 若已经在队列中 continue; visited[pid] = true; for (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) { if (dist[pid] + Edge[ei].w \u003c dist[to]){ dist[to] = dist[pid] + Edge[ei].w; path[to] = Edge[ei].from; // 记录路径的 if (!visited[to]) q.push(Polar(dist[to], to)); } } } } int main() { cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } int s = 1, t = 5; Dij(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; // -\u003e0 4 3 5 10 6 4 while (t != s) { cout \u003c\u003c t \u003c\u003c \"\u003c-\"; t = path[t]; } cout \u003c\u003c t; // -\u003e5\u003c-4\u003c-7\u003c-3\u003c-1 return 0; } 当然了用pair也行，反正只有id和dist两个数据，多个其实也没关系你也可以pair套pair (另外两种简单的写法在STL.md里面写了，这里不写了) -如何记录路径？把在更新点更新path数组就行。也就是dist[pos]\u003edist[u]+w(u-\u003epos)的时候把这个更新的来源放在path数组里就行（记录到达某点的最好的路径的上一个来源点）。像这样： if (dist[pid] + Edge[ei].w \u003c dist[to]){ dist[to] = dist[pid] + Edge[ei].w; path[to] = Edge[ei].from; } ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:4","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#dijstra算法"},{"categories":["在学算法的日子里"],"content":" ☆☆☆Dijstra算法Dij假设没有负边 因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。 思路：起点u可以直接到达的点中，最近的点p对应的e一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。 #include using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; int path[maxm]; // 储存路径(存边) struct Polar { // 注意每个dist其实是一对一的绑定了它的索引的，直接写什么return dist[a]\u003edist[b]会破坏堆的结构，可能会让dist[a]和dist[b]的索引变化。 int id, dist; Polar(int dist, int id) :dist(dist), id(id) {} // 对结构体中传数据，和下面这种写法作用一样： // Polar(int d, int d_id) { // dist = d; // id = d_id; // } // 重载运算符\u003c bool operator\u003c(const Polar\u0026 P)const { return dist \u003c P.dist; } }; struct cmp { // // 重写仿函数法： bool operator ()(Polar a, Polar b) { // 重载()运算符，使其成为一个仿函数 return a.dist \u003e b.dist; } }; // priority_queue","date":"2023-12-23","objectID":"/posts/shortest_path/:0:4","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#-如何记录路径"},{"categories":["在学算法的日子里"],"content":" 模板题 模板题指路： P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3371【模板】单源最短路径（弱化版） ==题目背景== 本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 P4779。 题目描述 如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。 ==输入格式== 第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。 接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \\to v$ 的，长度为 $w$ 的边。 ==输出格式== 输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。 ==样例== 样例输入 #1 4 6 1 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 样例输出 #1 0 2 4 3 ==提示== 【数据范围】 对于 $20%$ 的数据：$1\\le n \\le 5$，$1\\le m \\le 15$； 对于 $40%$ 的数据：$1\\le n \\le 100$，$1\\le m \\le 10^4$； 对于 $70%$ 的数据：$1\\le n \\le 1000$，$1\\le m \\le 10^5$； 对于 $100%$ 的数据：$1 \\le n \\le 10^4$，$1\\le m \\le 5\\times 10^5$，$1\\le u,v\\le n$，$w\\ge 0$，$\\sum w\u003c 2^{31}$，保证数据随机。 Update 2022/07/29：两个点之间可能有多条边，敬请注意。 对于真正 $100%$ 的数据，请移步 P4779。请注意，该题与本题数据范围略有不同。 样例说明： 图片1到3和1到4的文字位置调换 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; typedef long long ll; struct EdgeNode { int from; int to; // 终点 ll w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; ll dist[maxm]; ll n, m; bool inqueue[maxn]; void SPFA(int vn) { fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; queue\u003cint\u003e updates; updates.push(vn); while (!updates.empty()) { int firstp = updates.front(); updates.pop(); inqueue[firstp] = false; for (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) { // 遍历k可以直接到达的点to if (dist[to] \u003e dist[firstp] + Edge[k].w) { dist[to] = dist[firstp] + Edge[k].w; if (!inqueue[to]) { updates.push(to); inqueue[to] = true; } } } } } int main() { int s; cin \u003e\u003e n \u003e\u003e m \u003e\u003e s; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { ll fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } SPFA(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; return 0; } 这个…没有卡SPFA。看另一个卡SPFA的题： P4779【模板】单源最短路径（标准版） ==题目背景== 2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。 然后呢？ $100 \\rightarrow 60$； $\\text{Ag} \\rightarrow \\text{Cu}$； 最终，他因此没能与理想的大学达成契约。 小 F 衷心祝愿大家不再重蹈覆辙。 ==题目描述== 给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。 数据保证你能从 $s$ 出发到任意点。 ==输入格式== 第一行为三个正整数 $n, m, s$。 第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。 ==输出格式== 输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。 ==样例== 样例输入 #1 4 6 1 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 样例输出 #1 0 2 4 3 ==提示== 样例解释请参考 数据随机的模板题。 $1 \\leq n \\leq 10^5$； $1 \\leq m \\leq 2\\times 10^5$； $s = 1$； $1 \\leq u_i, v_i\\leq n$； $0 \\leq w_i \\leq 10 ^ 9$, $0 \\leq \\sum w_i \\leq 10 ^ 9$。 本题数据可能会持续更新，但不会重测，望周知。 2018.09.04 数据更新 from @zzq AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f typedef long long ll; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; // priority_queue\u003cpair\u003cll, int\u003e\u003e q; priority_queue\u003cpair\u003cll, int\u003e, vector\u003cpair\u003cll, int\u003e\u003e, greater\u003cpair\u003cll, int\u003e\u003e\u003e q; bool visited[maxn]; // 记录已经获得最短路的点 void Dij(int vn) { dist[vn] = 0; // 初始化 q.push(make_pair(dist[vn], vn)); while (!q.empty()) { // 取队首元素(最小的)将它移出队列并标记移出 int pid = q.top().second; q.pop(); if (visited[pid]) continue; visited[pid] = true; for (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) { // 找和pid(被移出的已最佳点)相连的边，更新dist if (dist[to] \u003e dist[pid] + Edge[ei].w) { dist[to] = dist[pid] + Edge[ei].w; if (!visited[to]) q.push(make_pair(dist[to], to)); } } } } int main() { int s; cin \u003e\u003e n \u003e\u003e m \u003e\u003e s; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } fill(dist + 1, dist + n + 1, INF); Dij(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } 啊总算绕完最短路这几个算法了，时候想通了感觉还挺明白的，不过由于某人的码力好差，老是达不到想要的效果[可恶]，还得多写代","date":"2023-12-23","objectID":"/posts/shortest_path/:0:5","series":null,"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#模板题"},{"categories":["在学算法的日子里"],"content":"有的题还没写完）咕咕咕）） ","date":"2023-12-19","objectID":"/posts/nenuoj/:0:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#"},{"categories":["在学算法的日子里"],"content":" NENU OJ算法2例题这学期写算法2并不想写详细思路(出于ddl再也不用关心小组啦的自由)，不过如果有想交流的也可以评论区或者私信，学校oj的题大多比较简单，这里的所有代码或许只保证通过学校的弱测试数据，因为其他地方OJ我还没有试过。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:0:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#nenu-oj算法2例题"},{"categories":["在学算法的日子里"],"content":" 算法2递归A","date":"2023-12-19","objectID":"/posts/nenuoj/:1:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2递归a"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 ==输入== 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 ==输出== 输出猴子第一天摘的桃子数，每组数据占一行。 ==样例输入== 2 2 2 3 0 ==样例输出== 6 6 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1241-a001-猴子吃桃"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 ==输入== 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 ==输出== 输出猴子第一天摘的桃子数，每组数据占一行。 ==样例输入== 2 2 2 3 0 ==样例输出== 6 6 AC代码 #include using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 ==输入== 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 ==输出== 输出猴子第一天摘的桃子数，每组数据占一行。 ==样例输入== 2 2 2 3 0 ==样例输出== 6 6 AC代码 #include using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 ==样例输入== 2 48 32 15 5 ==样例输出== 16 5 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1242-a002-最大公约数"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 ==样例输入== 2 48 32 15 5 ==样例输出== 16 5 AC代码 #include using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 ==样例输入== 2 48 32 15 5 ==样例输出== 16 5 AC代码 #include using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-1"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 ==输入== 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 ==输出== 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 ==样例输入== 3 1 ==样例输出== A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1243-a003-经典的hanoi汉诺塔问题"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 ==输入== 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 ==输出== 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 ==样例输入== 3 1 ==样例输出== A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC AC代码 #include using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 ==输入== 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 ==输出== 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 ==样例输入== 3 1 ==样例输出== A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC AC代码 #include using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-2"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 ==输出== 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 ==样例输入== 4 5 2 19 1 ==样例输出== 5 1 4181 1 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1244-a004-菲波那契数列"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 ==输出== 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 ==样例输入== 4 5 2 19 1 ==样例输出== 5 1 4181 1 AC代码 #include using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 ==输出== 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 ==样例输入== 4 5 2 19 1 ==样例输出== 5 1 4181 1 AC代码 #include using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-3"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 ==输入== 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 ==输出== 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 ==样例输入== 0 1 2 3 ==样例输出== no no yes no AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1245-a005-另一个fibonacci数列"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 ==输入== 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 ==输出== 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 ==样例输入== 0 1 2 3 ==样例输出== no no yes no AC代码 #include using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 ==输入== 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 ==输出== 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 ==样例输入== 0 1 2 3 ==样例输出== no no yes no AC代码 #include using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-4"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 ==输出== 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 ==样例输入== 2 3 -1 ==样例输出== X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1246-a006-分形fractal"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 ==输出== 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 ==样例输入== 2 3 -1 ==样例输出== X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X AC代码 #include using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 ==输出== 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 ==样例输入== 2 3 -1 ==样例输出== X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X AC代码 #include using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-5"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 ==输入== 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 ==输出== 每行输出只有一个正整数xi。 ==样例输入== 10 4 ==样例输出== 2 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1247-a007-二叉树"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 ==输入== 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 ==输出== 每行输出只有一个正整数xi。 ==样例输入== 10 4 ==样例输出== 2 AC代码 #include using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-6"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 ==输入== 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 ==输出== 每行输出只有一个正整数xi。 ==样例输入== 10 4 ==样例输出== 2 AC代码 #include using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-6"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 ==输入== 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 ==输出== 输出n行，每行表达式的值，保留3位小数输出。 ==样例输入== 1 * + 11.0 12.0 + 24.0 35.0 ==样例输出== 1357.000 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1248-a008-波兰表达式"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 ==输入== 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 ==输出== 输出n行，每行表达式的值，保留3位小数输出。 ==样例输入== 1 * + 11.0 12.0 + 24.0 35.0 ==样例输出== 1357.000 AC代码 #include using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-7"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 ==输入== 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 ==输出== 输出n行，每行表达式的值，保留3位小数输出。 ==样例输入== 1 * + 11.0 12.0 + 24.0 35.0 ==样例输出== 1357.000 AC代码 #include using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-7"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 ==输入== 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 ==输出== 对输入的每组数据M和N，用一行输出相应的K。 ==样例输入== 1 7 3 ==样例输出== 8 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1249-a009-放苹果"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 ==输入== 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 ==输出== 对输入的每组数据M和N，用一行输出相应的K。 ==样例输入== 1 7 3 ==样例输出== 8 AC代码 #include using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-8"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 ==输入== 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 ==输出== 对输入的每组数据M和N，用一行输出相应的K。 ==样例输入== 1 7 3 ==样例输出== 8 AC代码 #include using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-8"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ ==输入== 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 ==输出== 输出第m个人的岁数，每个一行。 ==样例输入== 5 2 10 ==样例输出== 18 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1250-a010-递归练习1"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ ==输入== 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 ==输出== 输出第m个人的岁数，每个一行。 ==样例输入== 5 2 10 ==样例输出== 18 AC代码 #include using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-9"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ ==输入== 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 ==输出== 输出第m个人的岁数，每个一行。 ==样例输入== 5 2 10 ==样例输出== 18 AC代码 #include using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-9"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 ==输出== 输出组合数C(m,n)。 ==样例输入== 2 1 100 100 1 ==样例输出== 0 100 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1251-a011-递归练习2"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 ==输出== 输出组合数C(m,n)。 ==样例输入== 2 1 100 100 1 ==样例输出== 0 100 AC代码 #include using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-10"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 ==输出== 输出组合数C(m,n)。 ==样例输入== 2 1 100 100 1 ==样例输出== 0 100 AC代码 #include using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-10"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 ==输入== 输入有多个整数t，每个一行。 ==输出== 输出t时刻反应堆里分别有多少个α粒子和β粒子。 ==样例输入== 6 ==样例输出== 183 546 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; pair\u003cint, int\u003e qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1252-a012-递归练习3"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 ==输入== 输入有多个整数t，每个一行。 ==输出== 输出t时刻反应堆里分别有多少个α粒子和β粒子。 ==样例输入== 6 ==样例输出== 183 546 AC代码 #include using namespace std; pair qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-11"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 ==输入== 输入有多个整数t，每个一行。 ==输出== 输出t时刻反应堆里分别有多少个α粒子和β粒子。 ==样例输入== 6 ==样例输出== 183 546 AC代码 #include using namespace std; pair qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-11"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 ==输入== 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 ==输出== 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 ==样例输出== 45 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx\u003ch \u0026\u0026 ny\u003e-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1253-a013-红与黑"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 ==输入== 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 ==输出== 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 ==样例输出== 45 AC代码 #include using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-12"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 ==输入== 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 ==输出== 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 ==样例输出== 45 AC代码 #include using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-12"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 ==输入== 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 ==输出== 城堡的房间数、城堡中最大房间所包括的方块数。 ==样例输入== 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 ==样例输出== 5 9 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1254-a014-城堡问题"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 ==输入== 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 ==输出== 城堡的房间数、城堡中最大房间所包括的方块数。 ==样例输入== 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 ==样例输出== 5 9 AC代码 #include using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-13"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 ==输入== 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 ==输出== 城堡的房间数、城堡中最大房间所包括的方块数。 ==样例输入== 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 ==样例输出== 5 9 AC代码 #include using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-13"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 ==样例输入== 2 2 20 ==样例输出== 1 4 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1255-a015-分解因式"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 ==样例输入== 2 2 20 ==样例输出== 1 4 AC代码 #include using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-14"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 ==输入== 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 ==输出== n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 ==样例输入== 2 2 20 ==样例输出== 1 4 AC代码 #include using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-14"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 ==输入== 一个正整数n。 ==输出== 一个正整数，表示具有该性质数的个数。 ==样例输入== 6 ==样例输出== 6 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1256-a016-数字拼凑"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 ==输入== 一个正整数n。 ==输出== 一个正整数，表示具有该性质数的个数。 ==样例输入== 6 ==样例输出== 6 AC代码 #include using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-15"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 ==输入== 一个正整数n。 ==输出== 一个正整数，表示具有该性质数的个数。 ==样例输入== 6 ==样例输出== 6 AC代码 #include using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-15"},{"categories":["在学算法的日子里"],"content":" 算法2排序B","date":"2023-12-19","objectID":"/posts/nenuoj/:2:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2排序b"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 ==输入== 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 ==输出== 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 ==样例输入== 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 ==样例输出== 9 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector\u003cnode\u003e a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1257-b001-快乐的蠕虫"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 ==输入== 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 ==输出== 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 ==样例输入== 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 ==样例输出== 9 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-16"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 ==输入== 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 ==输出== 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 ==样例输入== 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 ==样例输出== 9 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-16"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 ==输入== 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 ==输出== 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 ==样例输入== tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX ==样例输出== score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1258-b002-单词重组"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 ==输入== 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 ==输出== 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 ==样例输入== tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX ==样例输出== score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-17"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 ==输入== 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 ==输出== 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 ==样例输入== tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX ==样例输出== score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-17"},{"categories":["在学算法的日子里"],"content":" 算法2查找C","date":"2023-12-19","objectID":"/posts/nenuoj/:3:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2查找c"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 ==输入== 先给定一个N，N≤100000，接着输入N个字符串。 ==输出== 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 ==样例输入== 5 BBA BBA BEA DEC CCF ==样例输出== 1 3 2 1 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; map\u003cstring, int\u003ests; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map\u003cstring, int\u003e::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map\u003cstring, int\u003e::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1264-c001-字符串计数"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 ==输入== 先给定一个N，N≤100000，接着输入N个字符串。 ==输出== 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 ==样例输入== 5 BBA BBA BEA DEC CCF ==样例输出== 1 3 2 1 AC代码 #include using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; mapsts; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-18"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 ==输入== 先给定一个N，N≤100000，接着输入N个字符串。 ==输出== 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 ==样例输入== 5 BBA BBA BEA DEC CCF ==样例输出== 1 3 2 1 AC代码 #include using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; mapsts; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-18"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 ==输入== 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 ==输出== 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 ==样例输入== 5 2 3 5 7 12 5 2 16 64 256 1024 0 ==样例输出== 12 no solution AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1265-c002-赌徒"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 ==输入== 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 ==输出== 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 ==样例输入== 5 2 3 5 7 12 5 2 16 64 256 1024 0 ==样例输出== 12 no solution AC代码 #include using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-19"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 ==输入== 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 ==输出== 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 ==样例输入== 5 2 3 5 7 12 5 2 16 64 256 1024 0 ==样例输出== 12 no solution AC代码 #include using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-19"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 ==输入== 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 ==输出== 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 ==样例输入== 3 4 6 12 ==样例输出== NO YES YES NO AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vector\u003cint\u003eprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1266-c003-半素数"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 ==输入== 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 ==输出== 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 ==样例输入== 3 4 6 12 ==样例输出== NO YES YES NO AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vectorprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-20"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 ==输入== 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 ==输出== 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 ==样例输入== 3 4 6 12 ==样例输出== NO YES YES NO AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vectorprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-20"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 ==输出== 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 ==样例输入== 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 ==样例输出== 61.329 225.020 0.000 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1267-c004-棍子的膨胀"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 ==输出== 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 ==样例输入== 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 ==样例输出== 61.329 225.020 0.000 AC代码 #include using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-21"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 ==输入== 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 ==输出== 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 ==样例输入== 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 ==样例输出== 61.329 225.020 0.000 AC代码 #include using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-21"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 ==输入== 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 ==输出== 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 ==样例输入== 4 11 8.02 7.43 4.57 5.39 ==样例输出== 2.00 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1268-c005-电缆主"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 ==输入== 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 ==输出== 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 ==样例输入== 4 11 8.02 7.43 4.57 5.39 ==样例输出== 2.00 AC代码 #include using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-22"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 ==输入== 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 ==输出== 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 ==样例输入== 4 11 8.02 7.43 4.57 5.39 ==样例输出== 2.00 AC代码 #include using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-22"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 ==输入== 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 ==输出== 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 ==样例输入== dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay ==样例输出== cat eh loops AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10050; map\u003cstring, string\u003emp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1269-c006-宝贝鱼"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 ==输入== 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 ==输出== 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 ==样例输入== dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay ==样例输出== cat eh loops AC代码 #include using namespace std; typedef long long ll; const int maxn = 10050; mapmp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-23"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 ==输入== 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 ==输出== 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 ==样例输入== dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay ==样例输出== cat eh loops AC代码 #include using namespace std; typedef long long ll; const int maxn = 10050; mapmp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-23"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ ==输入== 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 ==输出== 对于每组数据输出形成正方形的个数。 ==样例输入== 4 1 0 0 1 1 1 0 0 0 ==样例输出== 1 AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1270-c007-星空"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ ==输入== 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 ==输出== 对于每组数据输出形成正方形的个数。 ==样例输入== 4 1 0 0 1 1 1 0 0 0 ==样例输出== 1 AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-24"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ ==输入== 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 ==输出== 对于每组数据输出形成正方形的个数。 ==样例输入== 4 1 0 0 1 1 1 0 0 0 ==样例输出== 1 AC代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-24"},{"categories":["在学算法的日子里"],"content":" 算法2动态规划D","date":"2023-12-19","objectID":"/posts/nenuoj/:4:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2动态规划d"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 ==输入== 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 ==输出== 输出最大的和。 ==样例输入== 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ==样例输出== 30 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1272-d001-数字三角形"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 ==输入== 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 ==输出== 输出最大的和。 ==样例输入== 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ==样例输出== 30 AC代码 #include using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-25"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 ==输入== 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 ==输出== 输出最大的和。 ==样例输入== 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 ==样例输出== 30 AC代码 #include using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-25"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … \u003ciK \u003c= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8)。 你的任务，就是对于给定的序列，求出最长上升子序列的长度。 ==输入== 输入有很多组，每组输入的第一行是序列的长度N (1 \u003c= N \u003c= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。 ==输出== 输出每组的最长上升子序列的长度。 ==样例输入== 7 1 7 3 5 9 4 8 6 2 3 4 1 6 5 ==样例输出== 4 4 AC代码 #include\u003ciostream\u003e #include\u003cvector\u003e using namespace std; typedef long long ll; const int maxn = 1010; int a[maxn]; // int dp[maxn]; int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++)cin \u003e\u003e a[i]; vector\u003cint\u003e lmax; lmax.push_back(a[1]); for (int i = 2;i \u003c= n;i++) { if (a[i] \u003e lmax.back()) { lmax.push_back(a[i]); } else if (a[i] \u003c lmax.back()) { int l = 0, r = lmax.size() - 1; while (l \u003c r) { int md = (l + r) / 2; if (lmax[md] \u003c= a[i])l = md + 1; else r = md; } lmax[l] = a[i]; } // for (int j = 0;j \u003c lmax.size();j++) // cout \u003c\u003c lmax[j] \u003c\u003c \" \"; // cout \u003c\u003c endl; } cout \u003c\u003c lmax.size() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1273-d002-最长上升子序列"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-26"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-26"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 ==输入== 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 ==输出== 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 ==样例输入== 1 3 8 17 20 0 10 8 0 10 13 4 14 3 ==样例输出== 23 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1274-d003-help-jimmy"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 ==输入== 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 ==输出== 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 ==样例输入== 1 3 8 17 20 0 10 8 0 10 13 4 14 3 ==样例输出== 23 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-27"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 ==输入== 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 ==输出== 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 ==样例输入== 1 3 8 17 20 0 10 8 0 10 13 4 14 3 ==样例输出== 23 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-27"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 ==输入== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==输出== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==样例输入== abcfbc abfcab programming contest abcd mnp ==样例输出== 4 2 0 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1275-d004-最长公共子序列"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 ==输入== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==输出== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==样例输入== abcfbc abfcab programming contest abcd mnp ==样例输出== 4 2 0 AC代码 #include using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-28"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 ==输入== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==输出== 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 ==样例输入== abcfbc abfcab programming contest abcd mnp ==样例输出== 4 2 0 AC代码 #include using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-28"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 ==输入== 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 ==输出== 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 ==样例输入== 4 2 1 2 2 3 4 1 6 2 0 0 ==样例输出== Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector\u003cint\u003e mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1276-d005-陪审团的人选"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 ==输入== 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 ==输出== 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 ==样例输入== 4 2 1 2 2 3 4 1 6 2 0 0 ==样例输出== Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 AC代码 #include using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-29"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 ==输入== 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 ==输出== 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 ==样例输入== 4 2 1 2 2 3 4 1 6 2 0 0 ==样例输出== Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 AC代码 #include using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-29"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); ==输入== 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 ==输出== 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 ==样例输入== 1 10 1 -1 2 2 3 -3 4 -4 5 -5 ==样例输出== 13 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1277-d006-最大和"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); ==输入== 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 ==输出== 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 ==样例输入== 1 10 1 -1 2 2 3 -3 4 -4 5 -5 ==样例输出== 13 AC代码 #include using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-30"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); ==输入== 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 ==输出== 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 ==样例输入== 1 10 1 -1 2 2 3 -3 4 -4 5 -5 ==样例输出== 13 AC代码 #include using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-30"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 ==输入== 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 ==输出== 输出最大矩阵的和。 ==样例输入== 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 ==样例输出== 15 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1278-d007-最大子矩阵"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 ==输入== 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 ==输出== 输出最大矩阵的和。 ==样例输入== 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 ==样例输出== 15 AC代码 #include using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-31"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 ==输入== 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 ==输出== 输出最大矩阵的和。 ==样例输入== 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 ==样例输出== 15 AC代码 #include using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-31"},{"categories":["在学算法的日子里"],"content":" 算法2搜索E","date":"2023-12-19","objectID":"/posts/nenuoj/:5:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2搜索e"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 ==输入== 每组数据由一行上的2个整数n，k构成（6\u003cn≤200,2≤k≤6）。 ==输出== 对每组测试数据，输出不同的分法整数。 ==样例输入== 7 3 ==样例输出== 4 AC代码 #include\u003cbits/stdc++.h\u003e #define AUTHOR \"DODOLA\" using namespace std; typedef long long ll; const int maxn = 220; ll dp[maxn][maxn]; // i个小球放入j个盒子没有空盒的方法数 int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 1;i \u003c= n;i++) { dp[i][1] = 1;dp[i][0] = 1; } for (int i = 2;i \u003c= n;i++) { for (int j = 2;j \u003c= k;j++) { if (i \u003e j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]; else dp[i][j] = dp[i - 1][j - 1]; } } cout \u003c\u003c dp[n][k] \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1281-e001-数的划分"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 ==输入== 每组数据由一行上的2个整数n，k构成（6","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-32"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 ==输入== 每组数据由一行上的2个整数n，k构成（6","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-32"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 ==输入== 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 ==输出== 对每组测试数据，输出有最大湖泊的单元的数目。 ==样例输入== 3 4 5 3 2 2 2 3 1 2 3 1 1 ==样例输出== 4 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1282-e002-闪避湖泊"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 ==输入== 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 ==输出== 对每组测试数据，输出有最大湖泊的单元的数目。 ==样例输入== 3 4 5 3 2 2 2 3 1 2 3 1 1 ==样例输出== 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-33"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 ==输入== 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 ==输出== 对每组测试数据，输出有最大湖泊的单元的数目。 ==样例输入== 3 4 5 3 2 2 2 3 1 2 3 1 1 ==样例输出== 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-33"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 ==输入== 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 ==输出== 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 ==样例输入== 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 ==样例输出== 1 channel needed. 3 channels needed. AC代码 #include\u003ciostream\u003e #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003calgorithm\u003e using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1283-e003-信道分配"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 ==输入== 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 ==输出== 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 ==样例输入== 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 ==样例输出== 1 channel needed. 3 channels needed. AC代码 #include #include #include #include using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-34"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 ==输入== 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 ==输出== 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 ==样例输入== 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 ==样例输出== 1 channel needed. 3 channels needed. AC代码 #include #include #include #include using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-34"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 ==输出== 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 ==样例输入== e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 ==样例输出== To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue\u003cpair\u003cint, int\u003e\u003e q; q.push({ x1, y1 }); while (!q.empty()) { queue\u003cpair\u003cint, int\u003e\u003e qs; while (!q.empty()) { auto [x, y] = q.front();q.pop(); for (int i = 0;i \u003c 8;i++) { int nx = x + mv[i][0], ny = y + mv[i][1]; if (nx \u003c 0 || nx \u003e= 8 || ny \u003c 0 || ny \u003e= 8)continue; if (nx == x2 \u0026\u0026 ny == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes \" \u003c\u003c stp + 1 \u003c\u003c \" knight moves.\\n\"; return; } qs.push({ nx, ny }); } } stp++; q = qs; } } void solve() { int x1 = fs[0] - 'a', y1 = fs[1] - '1', x2 = ts[0] - 'a', y2 = ts[1] - '1'; bfs(x1, y1, x2, y2); } int main() { while (cin \u003e\u003e fs \u003e\u003e ts) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1284-e004-移动的骑士"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 ==输出== 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 ==样例输入== e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 ==样例输出== To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. AC代码 #include using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-35"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 ==输出== 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 ==样例输入== e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 ==样例输出== To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. AC代码 #include using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-35"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 ==输入== 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 ==输出== 对每个网络输出一行，是选中目标的周长。 ==样例输入== 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 ==样例输出== 8 18 40 AC代码 #include\u003cbits/stdc++.h\u003e #define AUTHOR \"DODOLA\" // #include\u003cqueue\u003e // #include\u003ciostream\u003e // #include\u003cstring\u003e using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vector\u003cstring\u003emp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1285-e005-图像周长"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 ==输入== 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 ==输出== 对每个网络输出一行，是选中目标的周长。 ==样例输入== 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 ==样例输出== 8 18 40 AC代码 #include #define AUTHOR \"DODOLA\" // #include // #include // #include using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vectormp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-36"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 ==输入== 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 ==输出== 对每个网络输出一行，是选中目标的周长。 ==样例输入== 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 ==样例输出== 8 18 40 AC代码 #include #define AUTHOR \"DODOLA\" // #include // #include // #include using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vectormp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-36"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 ==输出== 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 ==样例输入== 1 8 0 0 7 0 ==样例输出== 5 AC代码 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003ccstring\u003e #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue\u003cP\u003e q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1286-e006-移动的骑士"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 ==输出== 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 ==样例输入== 1 8 0 0 7 0 ==样例输出== 5 AC代码 #include #include #include #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-37"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： ==输入== 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 ==输出== 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 ==样例输入== 1 8 0 0 7 0 ==样例输出== 5 AC代码 #include #include #include #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-37"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 ==输入== 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 ==输出== 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 ==样例输入== 2 6 0 ==样例输出== 10 1110 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1287-e007-寻找m"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 ==输入== 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 ==输出== 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 ==样例输入== 2 6 0 ==样例输出== 10 1110 AC代码 #include using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-38"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 ==输入== 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 ==输出== 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 ==样例输入== 2 6 0 ==样例输出== 10 1110 AC代码 #include using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-38"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 ==输入== 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 ==输出== 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 ==样例输出== 45 59 AC代码 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003ccstring\u003e const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1288-e008-红与黑"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 ==输入== 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 ==输出== 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 ==样例输出== 45 59 AC代码 #include #include #include const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-39"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 ==输入== 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 ==输出== 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 ==样例输入== 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 ==样例输出== 45 59 AC代码 #include #include #include const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-39"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 ==输入== 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 ==输出== 输出一行，即为原始木棒可能的最小长度。 ==样例输入== 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 ==样例输出== 6 5 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1289-e009-小木棒"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 ==输入== 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 ==输出== 输出一行，即为原始木棒可能的最小长度。 ==样例输入== 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 ==样例输出== 6 5 AC代码 #include using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-40"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 ==输入== 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 ==输出== 输出一行，即为原始木棒可能的最小长度。 ==样例输入== 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 ==样例输出== 6 5 AC代码 #include using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-40"},{"categories":["在学算法的日子里"],"content":" 算法2贪心F","date":"2023-12-19","objectID":"/posts/nenuoj/:6:0","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2贪心f"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 ==输入== 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 ==输出== 输出是以分钟为单位的最少准备时间，一行一个。 ==样例输入== 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 ==样例输出== 2 1 3 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector\u003cpair\u003cint, int\u003e\u003e len; for (int i = 0; i \u003c n; i++) { int l, w;cin \u003e\u003e l \u003e\u003e w; len.push_back(make_pair(l, w)); } sort(len.begin(), len.end()); int cnt = 0, ans = 0; while (cnt \u003c n) { ans++; int ki = 0; int li = 0, wi = 0; for (int i = 0;i \u003c n;i++) { if (!ck[i]) { ki = i; li = len[i].first, wi = len[i].second; ck[i] = true; cnt++; break; } } // cout \u003c\u003c ki \u003c\u003c \" \" \u003c\u003c li \u003c\u003c \" \" \u003c\u003c wi \u003c\u003c endl; for (int i = 0;i \u003c n;i++) { if (ck[i])continue; if (li \u003c= len[i].first \u0026\u0026 wi \u003c= len[i].second) { ck[i] = true; cnt++; li = len[i].first, wi = len[i].second; } } } cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1290-f001-木棒加工问题"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 ==输入== 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 ==输出== 输出是以分钟为单位的最少准备时间，一行一个。 ==样例输入== 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 ==样例输出== 2 1 3 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-41"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 ==输入== 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 ==输出== 输出是以分钟为单位的最少准备时间，一行一个。 ==样例输入== 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 ==样例输出== 2 1 3 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-41"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 ==输入== 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 ==输出== 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 ==样例输入== 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 ==样例输出== 2 1 AC代码 // #include\u003cbits/stdc++.h\u003e #include\u003ciostream\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1291-f002-装箱"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 ==输入== 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 ==输出== 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 ==样例输入== 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 ==样例输出== 2 1 AC代码 // #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-42"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 ==输入== 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 ==输出== 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 ==样例输入== 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 ==样例输出== 2 1 AC代码 // #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-42"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 ==输入== 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 ==输出== 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 ==样例输入== 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 ==样例输出== 10 20 AC代码 // #include\u003cbits/stdc++.h\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1292-f003-移动桌子"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 ==输入== 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 ==输出== 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 ==样例输入== 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 ==样例输出== 10 20 AC代码 // #include #include #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-43"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 ==输入== 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 ==输出== 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 ==样例输入== 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 ==样例输出== 10 20 AC代码 // #include #include #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-43"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 ==输入== 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 ==输出== 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 ==样例输入== 6 340 500 220 470 100 300 880 943 525 556 612 776 0 ==样例输出== 3 1 5 6 4 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vector\u003cnode\u003eans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1293-f004-基因集合"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 ==输入== 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 ==输出== 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 ==样例输入== 6 340 500 220 470 100 300 880 943 525 556 612 776 0 ==样例输出== 3 1 5 6 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vectorans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-44"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 ==输入== 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 ==输出== 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 ==样例输入== 6 340 500 220 470 100 300 880 943 525 556 612 776 0 ==样例输出== 3 1 5 6 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vectorans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-44"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 ==输入== 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 ==输出== 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 ==样例输入== 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 ==样例输出== Case 1: 74 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vector\u003cJOB\u003etot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1294-f005-主框架"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 ==输入== 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 ==输出== 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 ==样例输入== 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 ==样例输出== Case 1: 74 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vectortot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-45"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 ==输入== 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 ==输出== 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 ==样例输入== 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 ==样例输出== Case 1: 74 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vectortot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-45"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 ==输入== 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 ==输出== 输出符合条件的集合R中元素的个数。 ==样例输入== 4 3 6 2 4 0 2 4 7 ==样例输出== 4 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector\u003cpair\u003cint, int\u003e\u003e v; for (int i = 0;i \u003c n;i++) { int a, b; cin \u003e\u003e a \u003e\u003e b; v.push_back(make_pair(a, b)); for (int j = a;j \u003c= b;j++) { cnt[j]++; } } int ans = 0; while (true) { int mx = max_element(cnt, cnt + 10005) - cnt; // cout \u003c\u003c mx \u003c\u003c endl; if (cnt[mx] == 0)break; hasi[mx] = true; ans++; fill(cnt, cnt + 10005, 0); for (int i = 0;i \u003c n;i++) { if (ck[i] == 2)continue; if (v[i].first \u003c= mx \u0026\u0026 v[i].second \u003e= mx) { ck[i]++; } if (ck[i] == 2)continue; for (int j = v[i].first;j \u003c= v[i].second;j++) { if (hasi[j]) continue; cnt[j]++; } } } cout \u003c\u003c ans \u003c\u003c endl; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1295-f006-整数区间"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 ==输入== 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 ==输出== 输出符合条件的集合R中元素的个数。 ==样例输入== 4 3 6 2 4 0 2 4 7 ==样例输出== 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-46"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 ==输入== 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 ==输出== 输出符合条件的集合R中元素的个数。 ==样例输入== 4 3 6 2 4 0 2 4 7 ==样例输出== 4 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-46"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 ==输入== 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 ==输出== 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 ==样例输入== 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 ==样例输出== Case 1: 2 Case 2: 1 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector\u003cnode\u003e q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1296-f007-安装雷达"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 ==输入== 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 ==输出== 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 ==样例输入== 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 ==样例输出== Case 1: 2 Case 2: 1 AC代码 #include using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-47"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 ==输入== 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 ==输出== 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 ==样例输入== 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 ==样例输出== Case 1: 2 Case 2: 1 AC代码 #include using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-47"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? ==输入== 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 ==输出== 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 ==样例输入== 10 56 12 1 99 1000 234 33 55 99 812 ==样例输出== 532.00 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1297-f008-排队买饭"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? ==输入== 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 ==输出== 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 ==样例输入== 10 56 12 1 99 1000 234 33 55 99 812 ==样例输出== 532.00 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-48"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? ==输入== 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 ==输出== 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 ==样例输入== 10 56 12 1 99 1000 234 33 55 99 812 ==样例输出== 532.00 AC代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-48"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 ==输入== 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 ==输出== 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） ==样例输入== 6 40 6 18 11 13 19 11 ==样例输出== 3 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1298-f009-放书"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 ==输入== 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 ==输出== 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） ==样例输入== 6 40 6 18 11 13 19 11 ==样例输出== 3 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-49"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 ==输入== 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 ==输出== 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） ==样例输入== 6 40 6 18 11 13 19 11 ==样例输出== 3 AC代码 #include using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":null,"tags":["算法","NENUOJ","递归","查找","动态规划","搜索","贪心","排序"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#ac代码-49"},{"categories":["关于Hugo的一些设置"],"content":"增加了一个鼠标追尾的效果 QwQ 添加文件的方式参考上一篇~指路这篇 ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#"},{"categories":["关于Hugo的一些设置"],"content":" js文件：pointerfollow.js js 原文件来源：Canva’s Magic Mouse Effect (codepen.io) （我有稍微改了一些样式 qwq，写在代码里了。 ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#js文件"},{"categories":["关于Hugo的一些设置"],"content":" css文件： .star { position: fixed; z-index: 2; color: white; font-size: 1rem; animation-duration: 1500ms; animation-fill-mode: forwards; pointer-events: none; } @keyframes fall-1 { 0% { transform: translate(0px, 0px) rotateX(45deg) rotateY(30deg) rotateZ(0deg) scale(0.25); opacity: 0; } 5% { transform: translate(10px, -10px) rotateX(45deg) rotateY(30deg) rotateZ( 0deg ) scale(1); opacity: 1; } 100% { transform: translate(25px, 200px) rotateX(180deg) rotateY(270deg) rotateZ( 90deg ) scale(1); opacity: 0; } } @keyframes fall-2 { 0% { transform: translate(0px, 0px) rotateX(-20deg) rotateY(10deg) scale(0.25); opacity: 0; } 10% { transform: translate(-10px, -5px) rotateX(-20deg) rotateY(10deg) scale(1); opacity: 1; } 100% { transform: translate(-10px, 160px) rotateX(-90deg) rotateY(45deg) scale( 0.25 ); opacity: 0; } } @keyframes fall-3 { 0% { transform: translate(0px, 0px) rotateX(0deg) rotateY(45deg) scale(0.5); opacity: 0; } 15% { transform: translate(7px, 5px) rotateX(0deg) rotateY(45deg) scale(1); opacity: 1; } 100% { transform: translate(20px, 120px) rotateX(-180deg) rotateY(-90deg) scale( 0.5 ); opacity: 0; } } ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#css文件"},{"categories":["关于Hugo的一些设置"],"content":"今天摸鱼把网站的点击特效做了QwQ，选用的效果是烟花（/逆飞的流星🎆🎆，主要摸索了如何在Hugo里添加JavaScript代码 ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#"},{"categories":["关于Hugo的一些设置"],"content":" 添加js文件这次用到的两个js文件在这里： anime.min.js fireworks.js 在./static/下新建一个js文件夹，文件夹下新建两个js文件，命名为anime.min.js和fireworks.js，然后将上面两个文件的内容粘贴进去。 ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#添加js文件"},{"categories":["关于Hugo的一些设置"],"content":" 引入js文件在./layouts/partials/extend_head.html中添加如下代码： \u003cstyle type=\"text/css\"\u003e .fireworks { position: fixed; top: 0; left: 0; widows: 100%; height: 100%; z-index:99999999; pointer-events:none; /*这个样式可以解决正常点击事件不响应的问题*/ } \u003c/style\u003e \u003ccanvas class=\"fireworks\"\u003e \u003c/canvas\u003e \u003cscript src=\"/js/anime.min.js\" \u003e\u003c/script\u003e \u003cscript src=\"/js/fireworks.js\" \u003e\u003c/script\u003e ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#引入js文件"},{"categories":["关于Hugo的一些设置"],"content":" 简单设计assets/css/common/terms.css添加： .terms-tags{ padding-left: 0; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; } ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:1:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#简单设计"},{"categories":["关于Hugo的一些设置"],"content":" 添加权重在./layouts/_default/terms.html中，找到这段代码并在a标签插入data-weight属性 \u003cul class=\"terms-tags\"\u003e {{- $type := .Type }} {{- range $key, $value := .Data.Terms.Alphabetical }} {{- $name := .Name }} {{- $count := .Count }} {{- with site.GetPage (printf \"/%s/%s\" $type $name) }} \u003cli\u003e \u003ca data-weight=\"{{$count}}\" href=\"{{ .Permalink }}\"\u003e{{ .Name }} \u003csup\u003e\u003cstrong\u003e\u003csup\u003e{{ $count }}\u003c/sup\u003e\u003c/strong\u003e\u003c/sup\u003e \u003c/a\u003e \u003c/li\u003e {{- end }} {{- end }} \u003c/ul\u003e ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:2:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#添加权重"},{"categories":["关于Hugo的一些设置"],"content":" 字体大小按权重显示assets/css/common/terms.css中设计： .terms-tags a[data-weight=\"1\"] { --size: 1; } .terms-tags a[data-weight=\"2\"] { --size: 2; } .terms-tags a[data-weight=\"3\"] { --size: 3; } .terms-tags a[data-weight=\"4\"] { --size: 4; } .terms-tags a[data-weight=\"5\"] { --size: 5; } .terms-tags a[data-weight=\"6\"] { --size: 6; } .terms-tags a[data-weight=\"7\"] { --size: 7; } .terms-tags a[data-weight=\"8\"] { --size: 8; } .terms-tags a[data-weight=\"9\"] { --size: 9; } .terms-tags a { --size: 4; font-size: calc(var(--size) * 0.25rem + 1rem); /* font-size: 1.4rem; */ display: block; padding: 3px 10px; background: var(--tertiary); border-radius: 6px; transition: transform 0.1s; } ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:3:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#字体大小按权重显示"},{"categories":["关于Hugo的一些设置"],"content":" css伪随机字体色彩assets/css/common/terms.css中 .terms-tags li:nth-child(2n+1) a {color:#f7a400;} .terms-tags li:nth-child(3n+1) a {color:#3a9efd;} .terms-tags li:nth-child(4n+1) a {color:#3e4491;} .terms-tags li:nth-child(5n+1) a {color:#3e4491;} .terms-tags li:nth-child(6n+1) a {color:#3e4491;} 当然了也可以在js里搓qwq，可以参考这篇 ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:4:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#css伪随机字体色彩"},{"categories":["我们需要更多的鱼"],"content":" 拥有一个自己的小机器人不是超酷的么😎 本部分将从0开始介绍一个qq机器人的制作以及部署到服务器。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:0:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#"},{"categories":["我们需要更多的鱼"],"content":" 0.环境一览 开发环境：Windows11 python虚拟环境版本：3.10.9 nonebot cli版本：1.2.6 文本编辑器：VSCode 服务器环境：华为云 2核2G|系统盘40GB|峰值宽带3M|宝塔Linux面板8.0.0.1 Ubuntu版本：22.04.2 LTS (GNU/Linux 5.15.0-76-generic x86_64) ","date":"2023-12-06","objectID":"/posts/cq_bot/:0:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#0环境一览"},{"categories":["我们需要更多的鱼"],"content":" 1.NoneBot，启动！选择的聊天机器人框架是NoneBot2，官方使用文档在此：概览 | NoneBot ","date":"2023-12-06","objectID":"/posts/cq_bot/:0:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#1nonebot启动"},{"categories":["我们需要更多的鱼"],"content":" 脚手架nb-cli先在自己选择存放机器人的目录下打开vscode 推荐在虚拟环境下进行机器人的开发，这里先安装pipx 打开vscode终端，依次输入以下两行命令 python -m pip install --user pipx python -m pipx ensurepath 如果出现一些提示账户环境变量这样的WARNING，请关注，具体怎么调整环境变量另行搜索。 安装完成之后，关闭当前vscode窗口，重启vscode，虚拟环境生效。 重启之后，新建终端，在终端中输入以下命令安装脚手架 pipx install nb-cli 如果出现无法找到命令的错误提示。1.检查环境变量；2.重启VSCode；如果仍然不行：3.重启计算机，还是不行：4.找一个高手帮你debug 安装成功之后使用这个命令： nb --version 如果能返回脚手架版本信息，则代表安装成功 ","date":"2023-12-06","objectID":"/posts/cq_bot/:1:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#脚手架nb-cli"},{"categories":["我们需要更多的鱼"],"content":" 创建项目使用手脚架创建项目： nb create 该指令之后会一一系列询问帮助我们创建项目： [?] 选择一个要使用的模板: bootstrap (初学者或用户) # 可以安装商店的插件，之后也可以自己编写一些插件 [?] 项目名称: awesome-bot # 给你的bot取个名字，最好英文 [?] 要使用哪些驱动器? FastAPI (FastAPI 驱动器) # 一般都用这个 [?] 要使用哪些适配器? OneBot V11 (OneBot V11 协议) # V12似乎还不稳定 [?] 立即安装依赖? (Y/n) Yes [?] 创建虚拟环境? (Y/n) Yes 之后脚手架会帮我们自动创建并引入所需要的依赖包 最后选择安装内置插件echo，一个简单的复读插件用于初期测试机器人是否正常运行。 [?] 要使用哪些内置插件? echo # 注意这个插件要是没有安装，后续无法补装，只能重新创建一个机器人项目哩 接下来按照提示run一下项目就行 cd ./awesome-bot nb run --reload 现在run一下只是初始化，run成功之后ctrl+C终止进程，我们来到下一步编辑配置。 接下来的对机器人的构建都要在项目文件下，方便起见我们可以重新打开文件夹，使根目录是我们的awsome-bot 如果之前虚拟环境激活成功的话，进入这个项目目录下会自动进入本项目的虚拟环境中，就像这样： 有框框内显示的这个括号代表我们在本项目的虚拟环境下哩。 如果没有成功进入，可以试试在终端输入这个命令： ./.venv/Scripts/Activate （报错找不到路径的话就在自己的文件夹下找找这个activate脚本到底在哪里qwq 或者直接输入完整到activate脚本的路径名（从盘目录开始 或者找一个高手帮你debug ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#创建项目"},{"categories":["我们需要更多的鱼"],"content":" 编辑配置脚手架已经为我们自动创建了配置文件.env.prod 我们编辑它： DRIVER=~fastapi # 脚手架生成的 HOST=127.0.0.1 # 配置 NoneBot 监听的 IP / 主机名 PORT=5478 # 配置 NoneBot 监听的端口 COMMAND_START=[\"\"] # 配置命令起始字符 # COMMAND_SEP=[\".\"] # 配置命令分割字符 其中，HOST必须为127.0.0.1(localhost)，POST选择一个不被占用的限制端口即可，尽量不要使用8080,80,22,443这种热门端口 ","date":"2023-12-06","objectID":"/posts/cq_bot/:3:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#编辑配置"},{"categories":["我们需要更多的鱼"],"content":" 安装go-cqhttp插件go-cqhttp使我们用来运行bot机器人的插件，可以从nonebot商店获取安装，这里记录交互式安装的过程，其他方式可以参考nonebot文档获取商店内容 | NoneBot nb plugin install 按交互提示输入插件名： nonebot-plugin-gocqhttp 或者直接一句nb plugin install nonebot-plugin-gocqhttp ","date":"2023-12-06","objectID":"/posts/cq_bot/:4:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#安装go-cqhttp插件"},{"categories":["我们需要更多的鱼"],"content":" 登录机器人go-cqhttp插件安装完成之后，我们再nb run一下，激活插件的图形化界面。 复制这个网站到浏览器，或者按住Ctrl点击这步中的网址跳转到默认浏览器 我们点击左侧上方的添加账号，填入要用作机器人的qq号，密码留空，登录设备类型选择Android Watch点击提交 在进程这里点击启动 接下来在手机上扫描出现的二维码登录即可 如果出现当前协议不支持二维码登录这样的错误提示，可以先ctrl+c终止，然后在目录的./accounts/机器人的qq号/device.json中检查下方这一项是否是2，若不是，改为2，然后重新登录即可。 \"protocol\": 2, 登录成功之后我们对这个机器人qq私聊发送复读消息（因为前面设置的命令起始字符是空的，所以直接echo即可，如果起始设置是\"/“那就要写成”/echo xxx\" 若成功复读表明机器人部署成功。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:5:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#登录机器人"},{"categories":["我们需要更多的鱼"],"content":" 2.编写插件官方文档为我们提供了一个关于天气的响应，建议可以先写一下这个插件试水。 这里介绍了前期的准备插件编写准备 | NoneBot ","date":"2023-12-06","objectID":"/posts/cq_bot/:0:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#2编写插件"},{"categories":["我们需要更多的鱼"],"content":" 创建目录我们先在根目录下创建./awesome-bot/plugins目录，之后我们的插件都会在这个plugins目录下编写。 接下来在./pyproject.toml中添加plugin_dirs内容 [project] name = \"awesome-bot\" version = \"0.1.0\" description = \"awesome-bot\" readme = \"README.md\" requires-python = \"\u003e=3.8, \u003c4.0\" [tool.nonebot] adapters = [ { name = \"OneBot V11\", module_name = \"nonebot.adapters.onebot.v11\" } ] plugins = [\"nonebot_plugin_gocqhttp\"] plugin_dirs = [\"awesome-bot/plugins\"] # 修改的地方 builtin_plugins = [\"echo\"] 如果不小心忽略了这步import导致直接添加插件出错，可以试试把错误的文件删了，重新设置好之后重新打开项目文件 ","date":"2023-12-06","objectID":"/posts/cq_bot/:1:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#创建目录"},{"categories":["我们需要更多的鱼"],"content":" 创建插件接下来，使用交互式命令创建插件： $ nb plugin create [?] 插件名称: weather [?] 使用嵌套插件? (y/N) N [?] 输出目录: awesome_bot/plugins 这时候awesome_bot/plugins目录下多了一个weather文件夹。 项目树像这样(展示项目树：tree /f)： ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#创建插件"},{"categories":["我们需要更多的鱼"],"content":" 功能编写请参考： 事件响应器 | NoneBot 事件处理 | NoneBot 获取事件信息 | NoneBot 处理消息 | NoneBot 这些部分简单介绍了这个weather插件，请一定试过这个水再写其他的(( 建议：在尝试实现如爬虫等的功能时，请在其他地方调试好python代码再粘贴到插件中，注意数据的type等问题，关于如何爬虫可以参考一些爬虫教学博客((懒)) 本篇的示例awesome-bot脱敏处理之后开源至github 小机器人dodola的代码脱敏之后已经开源上传到本人的github上，仓库地址： https： https://github.com/Florae006/nonebotworks.git ssh： git@github.com:Florae006/nonebotworks.git github cli： gh repo clone Florae006/nonebotworks dodola小机器人实现的功能参考仓库中的readme.md，此处不再赘述。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:3:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#功能编写"},{"categories":["我们需要更多的鱼"],"content":" 3.部署到服务器","date":"2023-12-06","objectID":"/posts/cq_bot/:0:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#3部署到服务器"},{"categories":["我们需要更多的鱼"],"content":" DOCKER部署nonebot2的脚手架可以帮我们快速使用docker部署，具体操作参考：部署 | NoneBot docker可以帮助我们配置所有的开发环境使用的依赖。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:1:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#docker部署"},{"categories":["我们需要更多的鱼"],"content":" 直接部署如果不是很会用docker（比如我，我们也可以直接上传到服务器后再配置虚拟环境，进行机器人的部署 ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:0","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#直接部署"},{"categories":["我们需要更多的鱼"],"content":" 初始化部署这里使用的是宝塔面板+XShell远程桌面辅助我们配置部署 登录宝塔之后，点击左侧文件，在根目录文件下新建一个文件夹用于存放我们的机器人 在命令行中cd到这个文件夹下，给nonebot2机器人配置在linux下的环境（和window下类似 依次使用以下命令准备一些依赖： pip3 install nb-cli pip3 install pydantic loguru pygtrie httpx python-dotenv uvicorn fastapi requests selenium aiocqhttp ffmpeg aiohttp -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip3 install nonebot2 -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip3 install nonebot-plugin-apscheduler nonebot-adapter-cqhttp -i https://pypi.tuna.tsinghua.edu.cn/simple/ 在当前目录下(用来存放机器人的目录下)，命令行输入： nb create 根据脚手架的引导创建项目（参考前文部分的初始化设置 按照提示run一下，然后Ctrl+C退出： 然后我们修改配置文件.env.prod： FASTAPI_RELOAD=false HOST=0.0.0.0 PORT=36211 LOG_LEVEL=DEBUG DRIVER=~fastapi #指定驱动器，默认已有 SUPERUSERS=[\"2407445307\"] # 超级管理员QQ，即机器人主人QQ，改成自己的 COMMAND_START=[\"/\", \"\"] # 配置命令起始字符 COMMAND_SEP=[\".\"] # 配置命令分割字符 然后安装nonebot-plugin-gocqhttp插件 nb plugin install nonebot-plugin-gocqhttp 然后再run一下 然后打开这个网址（注意把这个0.0.0.0换成自己的服务器ip并把这个端口号从安全组开放出来，进行正常的扫码登录 这时候碰到的意外是：网络复杂拒绝登录。 没关系，这一步我们只是创建一下accounts及其文件罢了，我们可以这样处理这个问题： 在机器人项目的这个目录下./accounts/机器人qq号上传我们在本地测试环境下的有效登录的token文件：session.token（本地目录地址是一样的 然后重新启动一下机器人，应该就能正常访问了（可以测试一下复读功能 ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:1","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#初始化部署"},{"categories":["我们需要更多的鱼"],"content":" 上传插件经过前面的配置，我们获得了一个在linux下的机器人，接下来我们可以利用宝塔面板上传整个我们本地测试完的已经写完的插件： 在机器人项目的目录下上传整个我们在本地写的包含plugins文件夹的awesome-bot文件夹，并像之前那样修改pyproject.toml里的plugin _dirs。重新运行即可使用我们写的插件了。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:2","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#上传插件"},{"categories":["我们需要更多的鱼"],"content":" 导入虚拟环境配置如果是使用docker，那虚拟环境这块理论上不用我们操心，不过既然是直接部署，我们本地有的编程环境这个初始环境不一定有，这时候我们就要再配置一下虚拟环境中的依赖了。 我们先进入我们项目的虚拟环境： source .venv/bin/activate 然后在虚拟环境下安装我们需要的依赖就行 退出虚拟环境： deactivate 之后我们启动机器人，就能正常运行代码了。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:3","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#导入虚拟环境配置"},{"categories":["我们需要更多的鱼"],"content":" 后台挂起使用nohup命令挂起我们的命令，nohup的语法是：nohup 执行的命令 \u0026 nohup nb run \u0026 想要取消挂起的话，可以使用ps -ef |grep 端口号查看当前后台进程的pid，然后使用kill pid来解放这个进程。 ","date":"2023-12-06","objectID":"/posts/cq_bot/:2:4","series":null,"tags":["QQ机器人","服务器","Linux操作"],"title":"小机器人dodola，启动！","uri":"/posts/cq_bot/#后台挂起"},{"categories":["在学算法的日子里"],"content":"前言点评：本次题目难度不高 ","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#"},{"categories":["在学算法的日子里"],"content":" A 跳石头 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#a-跳石头"},{"categories":["在学算法的日子里"],"content":" [NOIP2015 提高组] 跳石头","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#noip2015-提高组-跳石头"},{"categories":["在学算法的日子里"],"content":" 题目背景NOIP2015 Day2T1 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目背景"},{"categories":["在学算法的日子里"],"content":" 题目描述一年一度的“跳石头”比赛又要开始了！ 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。 接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i,( 0 \u003c D_i \u003c L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式"},{"categories":["在学算法的日子里"],"content":" 输出格式一个整数，即最短跳跃距离的最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 25 5 2 2 11 14 17 21 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 4 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示"},{"categories":["在学算法的日子里"],"content":" 输入输出样例 1 说明将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入输出样例-1-说明"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于 $20%$的数据，$0 \\le M \\le N \\le 10$。 对于 $50%$ 的数据，$0 \\le M \\le N \\le 100$。 对于 $100%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \\le 10^9$。 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#数据规模与约定"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码"},{"categories":["在学算法的日子里"],"content":" B Secret Sport ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#b-secret-sport"},{"categories":["在学算法的日子里"],"content":" Secret Sport","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#secret-sport"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题面翻译"},{"categories":["在学算法的日子里"],"content":" 题目大意A,B两人玩游戏，游戏规则如下： 整场游戏有多轮，每轮游戏先胜 $X$ 局的人获胜，每场游戏先胜 $Y$ 局的人获胜。 你在场边观看了比赛，但是你忘记了 $X$ 和 $Y$ ，只记得总共比了 $1 \\le n \\le 20$ 局，和每局获胜的人，请判断谁获胜了。如果A获胜，输出 A ，如果B获胜，输出 B ，如果都有可能，输出 ? 。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目大意"},{"categories":["在学算法的日子里"],"content":" 题目描述Let’s consider a game in which two players, A and B, participate. This game is characterized by two positive integers, $ X $ and $ Y $ . The game consists of sets, and each set consists of plays. In each play, exactly one of the players, either A or B, wins. A set ends exactly when one of the players reaches $ X $ wins in the plays of that set. This player is declared the winner of the set. The players play sets until one of them reaches $ Y $ wins in the sets. After that, the game ends, and this player is declared the winner of the entire game. You have just watched a game but didn’t notice who was declared the winner. You remember that during the game, $ n $ plays were played, and you know which player won each play. However, you do not know the values of $ X $ and $ Y $ . Based on the available information, determine who won the entire game — A or B. If there is not enough information to determine the winner, you should also report it. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 输入格式Each test contains multiple test cases. The first line contains a single integer $ t $ $ (1 \\leq t \\leq 10^4) $ - the number of test cases. The description of the test cases follows. The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq 20) $ - the number of plays played during the game. The second line of each test case contains a string $ s $ of length $ n $ , consisting of characters $ \\texttt{A} $ and $ \\texttt{B} $ . If $ s_i = \\texttt{A} $ , it means that player A won the $ i $ -th play. If $ s_i = \\texttt{B} $ , it means that player B won the $ i $ -th play. It is guaranteed that the given sequence of plays corresponds to at least one valid game scenario, for some values of $ X $ and $ Y $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-1"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, output: $ \\texttt{A} $ — if player A is guaranteed to be the winner of the game. $ \\texttt{B} $ — if player B is guaranteed to be the winner of the game. $ \\texttt{?} $ — if it is impossible to determine the winner of the game. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-1"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 7 5 ABBAA 3 BBB 7 BBAAABA 20 AAAAAAAABBBAABBBBBAB 1 A 13 AAAABABBABBAB 7 BBBAAAA ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 A B A B A B A ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-1"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case, the game could have been played with parameters $ X = 3 $ , $ Y = 1 $ . The game consisted of $ 1 $ set, in which player A won, as they won the first $ 3 $ plays. In this scenario, player A is the winner. The game could also have been played with parameters $ X = 1 $ , $ Y = 3 $ . It can be shown that there are no such $ X $ and $ Y $ values for which player B would be the winner. In the second test case, player B won all the plays. It can be easily shown that in this case, player B is guaranteed to be the winner of the game. In the fourth test case, the game could have been played with parameters $ X = 3 $ , $ Y = 3 $ : In the first set, $ 3 $ plays were played: AAA. Player A is declared the winner of the set. In the second set, $ 3 $ plays were played: AAA. Player A is declared the winner of the set. In the third set, $ 5 $ plays were played: AABBB. Player B is declared the winner of the set. In the fourth set, $ 5 $ plays were played: AABBB. Player B is declared the winner of the set. In the fifth set, $ 4 $ plays were played: BBAB. Player B is declared the winner of the set. In total, player B was the first player to win $ 3 $ sets. They are declared the winner of the game. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-1"},{"categories":["在学算法的日子里"],"content":" 分析根据题意，其实每次都是赛到出现结果了才结束，所以每次的最后一局的胜负其实就是整场游戏的胜负。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 3e4 + 20; int p[maxn]; int n; string s; void solve() { cin \u003e\u003e n \u003e\u003e s; cout \u003c\u003c s.back() \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while(t--) solve(); return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C 众数 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#c-众数"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 初赛] 众数","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-初赛-众数"},{"categories":["在学算法的日子里"],"content":" 题目描述你有若干个 $[1,n]$ 内的正整数：对于 $1 \\le i \\le n$，你有 $a_i$ 个整数 $i$。设 $S = \\sum_{i=1}^n a_i$。 对于一个序列 $p_1,p_2,\\cdots,p_l$，定义其众数 $\\text{maj}(p_1,p_2,\\cdots,p_l)$ 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。 现在你需要把这 $S$ 个数排成一个序列 $b_1,b_2,\\cdots,b_S$，使得 $\\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i)$ 最大。输出该最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行一个整数 $n$，表示值域。 接下来一行 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，表示每种数的个数。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-2"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一行一个正整数表示 $\\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i)$ 的最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-2"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 1 3 2 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 17 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-2"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-2"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例解释-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#数据范围"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目来源"},{"categories":["在学算法的日子里"],"content":" 分析贪心，要让较大的数作为众数的次数最多。 构造排列时按照n~1的顺序排下去，每次先排列尽量满足上述想法的数。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; ll a[maxn], prea[maxn]; int main() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } ll num = 1; ll ans = 0; // prea[a[i]]:众数数量为a[i]时，当前众数i作为众数对结果的贡献 for (int i = n;i \u003e 0;i--) { while (num \u003c= a[i]) { prea[num] = prea[num - 1] + i; num++; } ans += prea[a[i]]; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D 大纲 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#d-大纲"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 大纲","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-决赛-大纲"},{"categories":["在学算法的日子里"],"content":" 题目描述小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。 ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。 知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。依赖关系不具有传递性。 你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立： 每个知识点的难度都是非负整数； 对于每个依赖其他知识点的知识点 $x$，设 $\\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\\max_x$，否则为 $\\max_x+1$。对于不依赖其他知识点的知识点，没有其他限制。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 输入格式本题有多组测试数据。第一行一个整数 $T$ 表示测试数据组数，接下来依次读入每组测试数据。 对于每组测试数据， 第一行一个整数 $n$ 表示知识点数量。 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，描述每个知识点的难度。若 $a_i = -1$ 表示知识点 $i$ 未确定难度，否则知识点 $i$ 的难度确定为 $a_i$。 接下来 $n-1$ 行每行两个整数 $u,v$，表示依赖关系构成的外向树中的一条有向边。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-3"},{"categories":["在学算法的日子里"],"content":" 输出格式对于每组测试数据输出一行：若难度是合理的，输出 Reasonable，否则输出 Unreasonable。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-3"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 3 0 -1 0 1 2 2 3 3 0 -1 0 1 2 1 3 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 Reasonable Unreasonable ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-3"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-3"},{"categories":["在学算法的日子里"],"content":" 样例 1 解释对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。 对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-解释"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于所有测试数据，$1 \\le T \\le 10^5$，$2 \\le n \\le 10^5$，$-1 \\le a_i \\le 10^9$，$1 \\le u,v \\le n$。 保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \\times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#数据规模与约定-1"},{"categories":["在学算法的日子里"],"content":" 后记大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。 ","date":"2023-12-02","objectID":"/posts/training0/:5:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#后记"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目来源-1"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:5:5","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:5:6","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E Chip and Ribbon ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#e-chip-and-ribbon"},{"categories":["在学算法的日子里"],"content":" Chip and Ribbon","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#chip-and-ribbon"},{"categories":["在学算法的日子里"],"content":" 题面翻译每次可以在一段长度为 $n$，初始值都为 $0$ 的序列中选取一段连续区间，并将区间内所有元素加 $1$，求最少操作数使得该序列与题目所给的序列所有元素相同，输出最少操作数减 $1$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题面翻译-1"},{"categories":["在学算法的日子里"],"content":" 题目描述There is a ribbon divided into $ n $ cells, numbered from $ 1 $ to $ n $ from left to right. Initially, an integer $ 0 $ is written in each cell. Monocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the $ 1 $ -st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions: move the chip to the next cell (i. e. if the chip is in the cell $ i $ , it is moved to the cell $ i+1 $ ). This action is impossible if the chip is in the last cell; choose any cell $ x $ and teleport the chip into that cell. It is possible to choose the cell where the chip is currently located. At the end of each turn, the integer written in the cell with the chip is increased by $ 1 $ . Monocarp’s goal is to make some turns so that the $ 1 $ -st cell contains the integer $ c_1 $ , the $ 2 $ -nd cell contains the integer $ c_2 $ , …, the $ n $ -th cell contains the integer $ c_n $ . He wants to teleport the chip as few times as possible. Help Monocarp calculate the minimum number of times he has to teleport the chip. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains one integer $ t $ ( $ 1 \\le t \\le 10^4 $ ) — the number of test cases. Each test case consists of two lines: the first line contains one integer $ n $ ( $ 1 \\le n \\le 2 \\cdot 10^5 $ ); the second line contains $ n $ integers $ c_1, c_2, \\dots, c_n $ ( $ 0 \\le c_i \\le 10^9 $ ; $ c_1 \\ge 1 $ ). It can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence $ c_1, c_2, \\dots, c_n $ . Additional constraint on the input: the sum of values of $ n $ over all test cases does not exceed $ 2 \\cdot 10^5 $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-4"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, print one integer — the minimum number of times Monocarp has to teleport the chip. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-4"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 4 4 1 2 2 1 5 1 0 1 0 1 5 5 4 3 2 1 1 12 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 2 4 11 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-4"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case of the example, Monocarp can perform the turns as follows: place the chip in the $ 1 $ -st cell; the numbers in the cells are $ [1, 0, 0, 0] $ ; move the chip to the next ( $ 2 $ -nd) cell; the numbers in the cells are $ [1, 1, 0, 0] $ ; move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 1, 1, 0] $ ; teleport the chip to the $ 2 $ -nd cell; the numbers in the cells are $ [1, 2, 1, 0] $ ; move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 2, 2, 0] $ ; move the chip to the next ( $ 4 $ -th) cell; the numbers in the cells are $ [1, 2, 2, 1] $ . ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-4"},{"categories":["在学算法的日子里"],"content":" 分析令连续的下一cell内数字加一的操作数是不限的，那么我们的目的就变成了画多少条这样的连续的“线”，能达到最终的目的，示意图如下： 在代码实现的时候，只要后一位的高度高于前一位，那么就需要增加：后一位高度-前一位高度 这么多的线，参考代码如下： ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 20; ll a[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; ll ans = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; if (a[i] \u003e a[i - 1]) ans += a[i] - a[i - 1]; } cout \u003c\u003c ans - 1 \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" F 着色 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#f-着色"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 着色","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-决赛-着色"},{"categories":["在学算法的日子里"],"content":" 题目背景远古的笔迹，远古的乐音，远古的历史，远古的 $K_{1000}$，若无人问津，便悄然褪色…… ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目背景-1"},{"categories":["在学算法的日子里"],"content":" 题目描述给出一个 $n$ 个节点的无向完全图，你需要给每条边标上一个 $0 \\sim 9$ 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 输入格式输入仅一行一个整数 $n$ 表示图的节点数。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-5"},{"categories":["在学算法的日子里"],"content":" 输出格式如果不存在方案，输出一行一个整数 -1。否则输出 $(n-1)$ 行，第 $i$ 行 $(n-i)$ 个字符，第 $i$ 行的第 $j$ 个字符表示 $(i,i+j)$ 的标号。若有多个方案，输出任意一个即可。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-5"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 4 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 012 34 5 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-5"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-5"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于所有测试数据，$2 \\le n \\le 1000$。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#数据规模与约定-2"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目来源-2"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" G Treasure Chest ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#g-treasure-chest"},{"categories":["在学算法的日子里"],"content":" Treasure Chest","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#treasure-chest"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题面翻译-2"},{"categories":["在学算法的日子里"],"content":" 题目描述给你一个数轴，一开始你的位置为 $0$，箱子在 $x$ 处，钥匙在 $y$ 处，$x\\neq y$。你需要通过一些操作打开宝箱。 当位置为 $i$ 时，你能执行以下操作： 花费 $1$ 秒，走向 $i+1$ 或 $i-1$； 花费 $0$ 秒，拿起 $i$ 处的钥匙或箱子，如果此处有的话； 花费 $0$ 秒，在 $i$ 处放下箱子； 花费 $0$ 秒，打开宝箱，如果箱子在 $i$ 处且你拿着钥匙的话。 另外给出限制：因为箱子很重，所以在整个过程中，扛着箱子的时间不得超过 $k$ 秒（放下再拿起箱子不会使其重置）。 现在给定 $x,y,k$，请问你打开箱子的最短用时为多少？ 每个测试点采用多组数据测试。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-6"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行一个整数 $t\\space(1\\le t\\le 100)$，表示数据组数。 对于每组数据：唯一一行三个整数 $x,y,k\\space(1\\le x,y\\le 100,x\\neq y,0\\le k\\le 100)$，分别表示初始时箱子的位置，钥匙的位置和你扛着箱子的最大时长。 ","date":"2023-12-02","objectID":"/posts/training0/:1:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-6"},{"categories":["在学算法的日子里"],"content":" 输出格式共 $t$ 行，第 $i$ 行一个整数表示第 $i$ 组数据的答案。 ","date":"2023-12-02","objectID":"/posts/training0/:1:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-6"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#说明提示"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#数据范围与约定"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例解释"},{"categories":["在学算法的日子里"],"content":" 题目描述Monocarp has found a treasure map. The map represents the treasure location as an OX axis. Monocarp is at $ 0 $ , the treasure chest is at $ x $ , the key to the chest is at $ y $ . Obviously, Monocarp wants to open the chest. He can perform the following actions: go $ 1 $ to the left or $ 1 $ to the right (spending $ 1 $ second); pick the key or the chest up if he is in the same point as that object (spending $ 0 $ seconds); put the chest down in his current point (spending $ 0 $ seconds); open the chest if he’s in the same point as the chest and has picked the key up (spending $ 0 $ seconds). Monocarp can carry the chest, but the chest is pretty heavy. He knows that he can carry it for at most $ k $ seconds in total (putting it down and picking it back up doesn’t reset his stamina). What’s the smallest time required for Monocarp to open the chest? ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-7"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the number of testcases. The only line of each testcase contains three integers $ x, y $ and $ k $ ( $ 1 \\le x, y \\le 100 $ ; $ x \\neq y $ ; $ 0 \\le k \\le 100 $ ) — the initial point of the chest, the point where the key is located, and the maximum time Monocarp can carry the chest for. ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-7"},{"categories":["在学算法的日子里"],"content":" 输出格式For each testcase, print a single integer — the smallest time required for Monocarp to open the chest. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-7"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 5 7 2 10 5 0 5 8 2 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 7 10 9 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-6"},{"categories":["在学算法的日子里"],"content":" 提示In the first testcase, Monocarp can open the chest in $ 7 $ seconds with the following sequence of moves: go $ 5 $ times to the right ( $ 5 $ seconds); pick up the chest ( $ 0 $ seconds); go $ 2 $ times to the right ( $ 2 $ seconds); pick up the key ( $ 0 $ seconds); put the chest down ( $ 0 $ seconds); open the chest ( $ 0 $ seconds). He only carries the chest for $ 2 $ seconds, which he has the stamina for. In the second testcase, Monocarp can pick up the key on his way to the chest. In the third testcase, Monocarp can’t use the strategy from the first testcase because he would have to carry the chest for $ 3 $ seconds, while he only has the stamina for $ 2 $ seconds. Thus, he carries the chest to $ 7 $ , puts it down, moves $ 1 $ to the right to pick up the key and returns $ 1 $ left to open the chest. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-6"},{"categories":["在学算法的日子里"],"content":" 分析分类讨论，要么在向右移动的时候就能把key带到chest的位置或者把chest带到key的位置，要么就把chest向右移动k个位置(离key最近)，然后拿key再折返回到chest位置。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int main() { int t;cin \u003e\u003e t; while (t--) { int x, y, k;cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; int ans; if (y \u003c= x)ans = x; else { if (y \u003c= x + k)ans = y; else { x += k; ans = y + (y - x); } } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" H 烂柯杯 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#h-烂柯杯"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 烂柯杯","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-决赛-烂柯杯"},{"categories":["在学算法的日子里"],"content":" 题目背景却说庞统迤逦前进，抬头见两山逼窄，树木丛杂；又值夏末秋初，枝叶茂盛。庞统心下甚疑，勒住马问：“此处是何地？”数内有新降军士，指道：“此处地名落凤坡。”庞统惊曰：“吾道号凤雏，此处名落凤坡，不利于吾。”令后军疾退。只听山坡前一声炮响，箭如飞蝗，只望骑白马者射来。可怜庞统竟死于乱箭之下。时年止三十六岁。后人有诗叹曰：“古岘相连紫翠堆，士元有宅傍山隈。儿童惯识呼鸠曲，闾巷曾闻展骥才。预计三分平刻削，长驱万里独徘徊。谁知天狗流星坠，不使将军衣锦回。”先是东南有童谣云：“一凤并一龙，相将到蜀中。才到半路里，凤死落坡东。风送雨，雨随风，隆汉兴时蜀道通，蜀道通时只有龙。” ——《三国演义》第六十三回：诸葛亮痛哭庞统 张翼德义释严颜 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目背景-2"},{"categories":["在学算法的日子里"],"content":" 题目描述$2023$ 年 $5$ 月 $4$ 日 $ \\sim 9$ 日，第一届“衢州烂柯杯”世界围棋公开赛本赛第一阶段的赛程在衢州顺利进行。作为疫情后第一场全程线下进行的世界围棋大赛，也是目前中国主办的唯一一项每年一届的世界围棋大赛，无疑引起了国内外广大围棋爱好者的广泛关注。 “羽客一枰无复见，青山留得烂柯名。”衢州是围棋圣地，流传着“王质遇仙”的故事，境内的烂柯山也因此闻名于天下。正因为此，“烂柯”也是围棋的别称之一，从古至今的许多围棋故事、书籍、弈谱等，也有不少化用了“烂柯”的典故，或以“烂柯”定名。 此次“烂柯杯”世界围棋大赛，是在保留原有的“烂柯杯”中国围棋冠军赛的基础上，创办的一项崭新的世界性围棋赛事，吸引了全世界围棋高手前来参加。其中，中国队派出了柯洁、辜梓豪、王星昊、丁浩、李钦诚等 $15$ 员大将参赛，韩国队 $8$ 人，日本队 $5$ 人，还有 $2$ 位棋手来自中国台湾、 $2$ 位棋手来自欧美地区。可以说，全世界最顶尖的围棋高手悉数相聚于此。 随着科技的发展，人工智能的巨大技术进步和网络传媒的全面普及，围棋这项来自中国的传统运动正在焕发出新的活力。在网络上，人们随时可以看到最新的赛事直播，以及人工智能的精准分析和各大围棋高手的细致解读。资源获取的便捷性使得人们对围棋的关注度空前上升，围棋不再是只有少部分懂棋的爱好者才能欣赏的“小众游戏”；围棋高手也不再只是一个神秘的身份，越来越多的围棋高手开始在网络上与棋迷近距离互动，普及围棋知识，讲解最新对局，赢得了一致好评。正如这次参赛的选手中，有一位棋手同时也是粉丝数达 $150$ 多万的网红主播，甚至还有一位棋手是一家网红餐厅的老板。 我们今天故事的主角正是这样一位有着传奇色彩的人物。作为一名清华大学本科在读的学生，同时也是一名顶尖围棋高手，他的一举一动无疑都会引起巨大的关注。此次他参加“烂柯杯”比赛，众人无一例外看好他的比赛前景，尤其是现在韩国围棋”第一人“申真谞九段的巅峰时期，他也被无数中国棋迷寄托以”狙击‘小申’“的重任。$5$ 月 $4$ 日抽签过后，没有任何人会怀疑他能不能赢下 $5$ 日的第一轮比赛，一些围棋高手更是直接放出了”大胜，不可能失败“的预言。 然而，$5$ 月 $5$ 日的比赛还是爆出了惊天大冷门。他在已经胜券在握，AI 胜率达到 $99%$ 的关头，接连选择了“弹幕最多的下法”，最终因为几招致命的失误葬送好局，落败于中国台湾棋手赖均辅八段。赛后，人们在震惊的同时，纷纷猜测本局失利的原因。有人说，他的状态低迷在前些年早已有所体现，“当你在 XX 的时候，小申在下棋”成了调侃他与申真谞战绩差距的一句名言；有人说，他在比赛之前的 $12$ 连胜战绩反而使他心态紧张，从而犯了优势下容易大意的老毛病；也有人拿出了“落凤坡”的典故，以证明他或许命中注定与“烂柯杯”八字不合……但或许，这样的变幻莫测和不可预料性，正是围棋的魅力所在。 请你根据以上所有信息，猜测本文的主角是谁。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-8"},{"categories":["在学算法的日子里"],"content":" 输入格式无输入。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-8"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一个由小写字母组成的字符串，表示上文中提到的主角的名字全拼。如若答案是马云，应当输出 mayun。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-8"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-7"},{"categories":["在学算法的日子里"],"content":" 提示主角的名字在题面中已经有所提及。 题面中一些看似无厘头的信息实际上是有价值的。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-8"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目来源-3"},{"categories":["在学算法的日子里"],"content":" 分析是签到题，输出\"kejie\"即可。 ","date":"2023-12-02","objectID":"/posts/training0/:5:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int main() { cout \u003c\u003c \"kejie\"; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" I 总投票数 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#i-总投票数"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 总投票数","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-决赛-总投票数"},{"categories":["在学算法的日子里"],"content":" 题目背景各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家： 非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！ 现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。 停止运营相关时间表如下： …… ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目背景-3"},{"categories":["在学算法的日子里"],"content":" 题目描述在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。 作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$ 个选项的玩家比例为 $P_i$（$1\\le i\\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有 $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有 $$ P_i-\\frac{1}{2}\\times 10^{-L}\\le\\frac{D_i}{K}\u003c P_i+\\frac{1}{2}\\times 10^{-L} $$ 显然，所有的 $D_i$ 必须是非负整数，而 $K=\\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足 $D_i$ 有非负整数解的最小的总投票数 $K$。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-9"},{"categories":["在学算法的日子里"],"content":" 输入格式输入的第一行包含一个正整数 $N$，表示投票的选项总数。保证 $1\\le N\\le 100$。 接下来 $N$ 行，每行包括一个 $[0, 1]$ 中的实数 $P_i$，表示选择第 $i$ 个选项的玩家比例。保证 $\\sum_{i=1}^N P_i =1$，所有 $P_i$ 均保留到小数点后第 $L$ 位，且 $1\\le L\\le 6$。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-9"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一个正整数，表示满足要求的最小总投票数 $K$。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-9"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 0.166667 0.333333 0.500000 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 6 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-7"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 7 0.041096 0.109589 0.109589 0.164384 0.301370 0.068493 0.205479 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 73 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-2"},{"categories":["在学算法的日子里"],"content":" 样例 #3","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #3 13 0.00155 0.03876 0.01584 0.05189 0.08099 0.06825 0.15658 0.10404 0.02640 0.14332 0.12941 0.15529 0.02768 ","date":"2023-12-02","objectID":"/posts/training0/:7:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #3 7766 ","date":"2023-12-02","objectID":"/posts/training0/:7:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-3"},{"categories":["在学算法的日子里"],"content":" 提示【样例解释 #1】 最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。 【样例解释 #2】 最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。 【样例解释 #3】 最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215$。 【数据范围】 对于所有测试数据，$1\\le N\\le 100$，$0\\le P_i\\le 1$，$\\sum_{i=1}^N P_i=1$，且 $P_i$ 最多统一保留到小数点后 $6$ 位。 【题目来源】 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:8:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-9"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:8:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:8:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" J Points and Minimum Distance ","date":"2023-12-02","objectID":"/posts/training0/:9:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#j-points-and-minimum-distance"},{"categories":["在学算法的日子里"],"content":" Points and Minimum Distance","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#points-and-minimum-distance"},{"categories":["在学算法的日子里"],"content":" 题面翻译给定长度为 $2n$ 的序列 $a$，你需要把这些数分为 $n$ 对，得到 $n$ 个坐标轴上的点。$a$ 中的每个数都要是某一个点的 $x$ 或 $y$ 坐标。注意有些点可能会重合。 之后，你可以选择从一个点出发，选择一条路径走过所有 $n$ 个点至少一次，在某个点处停下。 你需要求出路径总长度的最小值。本题中两点间距离为曼哈顿距离，即 $(x_1,y_1)$ 和 $(x_2,y_2)$ 间距离为 $|x_1-x_2|+|y_1-y_2|$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题面翻译-3"},{"categories":["在学算法的日子里"],"content":" 题目描述You are given a sequence of integers $ a $ of length $ 2n $ . You have to split these $ 2n $ integers into $ n $ pairs; each pair will represent the coordinates of a point on a plane. Each number from the sequence $ a $ should become the $ x $ or $ y $ coordinate of exactly one point. Note that some points can be equal. After the points are formed, you have to choose a path $ s $ that starts from one of these points, ends at one of these points, and visits all $ n $ points at least once. The length of path $ s $ is the sum of distances between all adjacent points on the path. In this problem, the distance between two points $ (x_1, y_1) $ and $ (x_2, y_2) $ is defined as $ |x_1-x_2| + |y_1-y_2| $ . Your task is to form $ n $ points and choose a path $ s $ in such a way that the length of path $ s $ is minimized. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-10"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the number of testcases. The first line of each testcase contains a single integer $ n $ ( $ 2 \\le n \\le 100 $ ) — the number of points to be formed. The next line contains $ 2n $ integers $ a_1, a_2, \\dots, a_{2n} $ ( $ 0 \\le a_i \\le 1,000 $ ) — the description of the sequence $ a $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-10"},{"categories":["在学算法的日子里"],"content":" 输出格式For each testcase, print the minimum possible length of path $ s $ in the first line. In the $ i $ -th of the following $ n $ lines, print two integers $ x_i $ and $ y_i $ — the coordinates of the point that needs to be visited at the $ i $ -th position. If there are multiple answers, print any of them. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-10"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 2 15 1 10 5 3 10 30 20 20 30 10 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 9 10 1 15 5 20 20 20 10 30 10 30 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-8"},{"categories":["在学算法的日子里"],"content":" 提示In the first testcase, for instance, you can form points $ (10, 1) $ and $ (15, 5) $ and start the path $ s $ from the first point and end it at the second point. Then the length of the path will be $ |10 - 15| + |1 - 5| = 5 + 4 = 9 $ . In the second testcase, you can form points $ (20, 20) $ , $ (10, 30) $ , and $ (10, 30) $ , and visit them in that exact order. Then the length of the path will be $ |20 - 10| + |20 - 30| + |10 - 10| + |30 - 30| = 10 + 10 + 0 + 0 = 20 $ . ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-10"},{"categories":["在学算法的日子里"],"content":" 分析构造题，根据题意可以推断，ans只分别与x集合的差值和、y集合差值和有关。显然，（大数-小数）+（大数-小数）的结果劣于（大数-大数）+（小数-小数）。 故此题，在进行排列后按序先分配x再分配y，直接统计x有序集合与y有序集合的差值即可（注意结果除去x，y交界的一对差）。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-9"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int a[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= 2 * n;i++) cin \u003e\u003e a[i]; sort(a + 1, a + 2 * n + 1); int ans = 0; for (int i = 2;i \u003c= 2 * n;i++) { ans += a[i] - a[i - 1]; } ans -= a[n + 1] - a[n]; cout \u003c\u003c ans \u003c\u003c endl; for (int i = 1;i \u003c= n;i++) cout \u003c\u003c a[i] \u003c\u003c \" \" \u003c\u003c a[2 * n + 1 - i] \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-9"},{"categories":["在学算法的日子里"],"content":" K 速战速决 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#k-速战速决"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 初赛] 速战速决","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#thupc-2023-初赛-速战速决"},{"categories":["在学算法的日子里"],"content":" 题目描述小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同： 有 $2n$ 张牌，其中对于整数 $1 \\le i \\le n$，牌面为 $i$ 的牌恰好有 $2$ 张。 游戏开始时，小 I 和小 J 各拿其中 $n$ 张牌组成双方的初始手牌。 维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作： 将手牌中的一张牌放在公共牌堆顶； 若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中； 若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。 小 J 是扑克萌新，所以会按照以下策略行动： 维护一个队列，初始将 $n$ 张手牌按照一定顺序放入队列中； 每次行动时，将队列开头的牌放在公共牌堆顶； 若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。 小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用最少的行动次数获胜，但他也是扑克萌新。所以给定小 J 队列中的 $n$ 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-11"},{"categories":["在学算法的日子里"],"content":" 输入格式每组数据的第一行一个整数 $n$ 表示牌面的种数。 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，从队头到队尾的顺序依次描述小 J 队列中的牌。 得到小 J 的 $n$ 张手牌也就得到了小 I 的 $n$ 张手牌，因此不会输入小 I 的手牌。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-11"},{"categories":["在学算法的日子里"],"content":" 输出格式如果小 I 不可能获胜，只需要输出一个整数 -1；否则第一行输出一个整数 $s$，表示你给出的策略中小 I 的行动次数。接下来一行 $s$ 个整数，依次描述每次行动时小 I 从手牌中放入公共牌堆的牌的牌面，两个数之间以一个空格分隔。注意你给出的策略要满足 $s$ 最小。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-11"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 1 3 3 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 3 2 1 2 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-9"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 1 1 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 -1 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-2-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-11"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例解释-1-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#子任务"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目来源-4"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-10"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-10"},{"categories":["在学算法的日子里"],"content":" L 滑雪 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#l-滑雪"},{"categories":["在学算法的日子里"],"content":" [SHOI2002] 滑雪","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#shoi2002-滑雪"},{"categories":["在学算法的日子里"],"content":" 题目描述Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然 $25$－$24$－$23$－$\\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-12"},{"categories":["在学算法的日子里"],"content":" 输入格式输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-12"},{"categories":["在学算法的日子里"],"content":" 输出格式输出区域中最长滑坡的长度。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-12"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 25 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-10"},{"categories":["在学算法的日子里"],"content":" 提示对于 $100%$ 的数据，$1\\leq R,C\\leq 100$。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-12"},{"categories":["在学算法的日子里"],"content":" 分析优先队列+线性dp 优先队列内排序按照高度从小到大，依次取出队首的点（高度最低的点），记为pos，更新从低处到pos的最长路径。 状态转移： $$ dp[xi][yi]=max(dp[xi][yi],dp[xi+1][yi]+1)\\ 其他三个点同理 $$ 同时记录最长的路径即可。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-11"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll rec[maxn][maxn]; ll dp[maxn][maxn]; struct POS { ll height; int x, y; POS(int hi, int xi, int yi) :height(hi), x(xi), y(yi) {} bool operator\u003c(const POS\u0026 P)const { return P.height \u003c height; } }; int main() { int r, c;cin \u003e\u003e r \u003e\u003e c; priority_queue\u003cPOS\u003epos; for (int i = 1;i \u003c= r;i++) { for (int j = 1;j \u003c= c;j++) { ll h;cin \u003e\u003e h; rec[i][j] = h; pos.push(POS(h, i, j)); dp[i][j] = 1; } } ll ans = 1; while (!pos.empty()) { auto tp = pos.top(); int xi = tp.x, yi = tp.y;ll hi = tp.height;pos.pop(); if (rec[xi + 1][yi] \u003c hi) { dp[xi][yi] = max(dp[xi + 1][yi] + 1, dp[xi][yi]); } if (rec[xi - 1][yi] \u003c hi) { dp[xi][yi] = max(dp[xi - 1][yi] + 1, dp[xi][yi]); } if (rec[xi][yi + 1] \u003c hi) { dp[xi][yi] = max(dp[xi][yi + 1] + 1, dp[xi][yi]); } if (rec[xi][yi - 1] \u003c hi) { dp[xi][yi] = max(dp[xi][yi - 1] + 1, dp[xi][yi]); } ans = max(ans, dp[xi][yi]); } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-11"},{"categories":["在学算法的日子里"],"content":" M Two Out of Three ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#m-two-out-of-three"},{"categories":["在学算法的日子里"],"content":" Two Out of Three","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#two-out-of-three"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题面翻译-4"},{"categories":["在学算法的日子里"],"content":" 题目描述给定一个数组 $a_1, a_2, …, a_n$。你需要找到一个数组 $b_1$, $b_2$, …, $b_n$，其中包含数字 $1, 2, 3$，使得以下三个条件中恰好有两个条件被满足： 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=2$。 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=3$。 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=2,b_j=3$。 如果不存在这样的数组 $b$，请报告不可以。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-13"},{"categories":["在学算法的日子里"],"content":" 输入格式每个测试点多测。第一行输入一个整数 $t$，表示数据组数。对于每一组数据： 第一行输入一个整数 $n$ $(1\\le n\\le 100)$，表示数组 $a$ 的长度。 第二行读入 $n$ 个整数 $a_1,a_2,…,a_n$ $(1\\le a_i\\le 100)$，代表数组 $a$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-13"},{"categories":["在学算法的日子里"],"content":" 输出格式对于每组数据输出一行。若无解，则输出 -1。否则输出一个由 $1,2,3$ 组成的数组 $b$，恰好满足两条性质。如果有多个合法数组，输出任一即可。 ","date":"2023-12-02","objectID":"/posts/training0/:1:3","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-13"},{"categories":["在学算法的日子里"],"content":" 说明/提示第一个数组 $a$，合法数组可以是 $b=[1,2,3,1,1,1]$。当 $i = 4,j = 2$ 时，满足性质一。当$i = 6,j = 3$ 时满足性质二。数组 $b$ 无法满足性质三，所以恰好满足两条，合法。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#说明提示-1"},{"categories":["在学算法的日子里"],"content":" 题目描述You are given an array $ a_1, a_2, \\ldots, a_n $ . You need to find an array $ b_1, b_2, \\ldots, b_n $ consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ such that exactly two out of the following three conditions are satisfied: There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 1 $ , $ b_j = 2 $ . There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 1 $ , $ b_j = 3 $ . There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 2 $ , $ b_j = 3 $ . If such an array does not exist, you should report it. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#题目描述-14"},{"categories":["在学算法的日子里"],"content":" 输入格式Each test contains multiple test cases. The first line contains a single integer $ t $ $ (1 \\leq t \\leq 500) $ — the number of test cases. Each test case is described as follows. The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq 100) $ — the length of the array $ a $ . The second line of each test case contains $ n $ integers $ a_1, a_2, \\ldots, a_n $ $ (1 \\leq a_i \\leq 100) $ — the elements of the array $ a $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输入格式-14"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, print -1 if there is no solution. Otherwise, print $ b_1, b_2, \\ldots, b_n $ — an array consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ that satisfies exactly two out of three conditions. If there are multiple possible answers, you can print any of them. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#输出格式-14"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 9 6 1 2 3 2 2 3 7 7 7 7 7 7 7 7 4 1 1 2 2 7 1 2 3 4 5 6 7 5 2 3 3 3 2 3 1 2 1 9 1 1 1 7 7 7 9 9 9 1 1 18 93 84 50 21 88 52 16 50 63 1 30 85 29 67 63 58 37 69 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输入-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 2 3 1 1 1 -1 3 2 2 1 -1 2 1 2 1 3 -1 1 1 2 2 1 2 2 3 3 -1 3 2 1 3 3 3 3 2 2 1 1 2 3 1 3 1 1 2 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#样例输出-1-11"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case, $ b = [1, 2, 3, 1, 1, 1] $ satisfies condition $ 1 $ because for $ i = 4 $ , $ j = 2 $ : $ a_i = a_j $ , $ b_i = 1 $ , and $ b_j = 2 $ . It also satisfies condition $ 2 $ because for $ i = 6 $ , $ j = 3 $ : $ a_i = a_j $ , $ b_i = 1 $ , and $ b_j = 3 $ . However, it does not satisfy condition $ 3 $ . In total, exactly two out of three conditions are satisfied. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#提示-13"},{"categories":["在学算法的日子里"],"content":" 分析构造题，根据分析，只有当数量超过2个的数的种数大于等于2，才有可能构造出符合要求的b数组。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#分析-12"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 120; int a[maxn]; // int cnt[maxn]; int n; void solve() { cin \u003e\u003e n; // fill(cnt, cnt + sizeof(cnt), 0); int cnt[maxn] = {}; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; cnt[a[i]]++; } int cntn = 0; for (int i = 1;i \u003c= 101;i++) { if (cnt[i] \u003e= 2) cntn++; } if (cntn \u003c 2) { cout \u003c\u003c -1 \u003c\u003c endl; return; } bool ck[maxn] = { false }; bool f = true; for (int i = 0;i \u003c n;i++) { int x = a[i]; if (cnt[x] \u003e= 2 \u0026\u0026 !ck[x]) { if (f) { cout \u003c\u003c 2 \u003c\u003c \" \"; f = false; } else { cout \u003c\u003c 3 \u003c\u003c \" \"; } ck[x] = true; } else { cout \u003c\u003c 1 \u003c\u003c \" \"; } } cout \u003c\u003c \"\\n\"; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题|23.11.29","uri":"/posts/training0/#参考代码-12"},{"categories":["在前端搬砖的日子里"],"content":" 1. jQuery对象","date":"2023-12-01","objectID":"/posts/jquery_notes/:1:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#1-jquery对象"},{"categories":["在前端搬砖的日子里"],"content":" jQuery使用","date":"2023-12-01","objectID":"/posts/jquery_notes/:1:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#jquery使用"},{"categories":["在前端搬砖的日子里"],"content":" Dom对象和jQuery包装集对象学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"src/assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 内容框架 --\u003e \u003cdiv id=\"mydiv\"\u003e文本\u003c/div\u003e \u003c/body\u003e \u003c!-- Dom对象 通过js方式获取的元素对象（document） JQuery对象 通过jQuery方法获取的元素对象，返回的是jQuery包装集 --\u003e \u003cscript type=\"text/javascript\"\u003e // Dom对象 // 单个的Dom对象 var divDom = document.getElementById(\"mydiv\"); console.log(divDom); // Dom对象数组 var divsDom = document.getElementsByTagName(\"div\") console.log(divsDom) // 会返回[]数组 // js获取不存在的元素时： var spanDom = document.getElementsByTagName(\"span\") console.log(spanDom) // 会返回空数组 var spanDom2 = document.getElementById(\"myspan\") console.log(spanDom2) console.log(\"============分割线============\") // jQuery对象 // 通过id选择获取元素对象 $(\"#id属性值\") var divJquery = $(\"#mydiv\"); console.log(divJquery) // jQuery获取不存在的元素时： var spanJquery = $(\"#myspan\") console.log(spanJquery) // 会返回空集合{} // Dom对象转为jQuery对象 // 利用$()方法进行包装即可 var divDomToJquery = $(divDom) console.log(divDomToJquery) // jQuery转Dom对象 // 因为jQuery对象是个对象的包装集，所以欲将jQuery对象转换为Dom对象，可以通过： // 1.获取包装集对象中指定下标的元素； var divJqueryToDom = divJquery[0] console.log(divJqueryToDom) // 2.通过遍历 $('#mydiv').each(function(){ var divJqueryToDom1 = this console.log(divJqueryToDom1) var divJqueryToDom2 = $(this) console.log(divJqueryToDom2) // 通过遍历jQuery对象数组得到的对象是Dom对象，可以通过$()转为jQuery对象 // 这里的this是Dom对象(divJqueryToDom1)，我们用$()方法将它转回jQuery对象(divJqueryToDom2)了 }) \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:1:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#dom对象和jquery包装集对象"},{"categories":["在前端搬砖的日子里"],"content":" 2. jQuery选择器","date":"2023-12-01","objectID":"/posts/jquery_notes/:2:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#2-jquery选择器"},{"categories":["在前端搬砖的日子里"],"content":" 2.1 基础选择器学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-02\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"mydiv1\"\u003eid选择器\u003cspan\u003espan中的内容\u003c/span\u003e\u003c/div\u003e \u003cdiv id=\"mydiv1\" class=\"blue\"\u003e元素选择器\u003c/div\u003e \u003cspan class=\"blue\"\u003e样式选择器\u003c/span\u003e \u003c/body\u003e \u003c!-- 基础选择器 id选择器 #id属性值 $(\"#id属性值\") 选择id为指定值元素对象(如果有多个同名id，则以第一个为准) 类选择器 .class属性值 $(\".class属性值\") 选择class为指定值元素对象 元素选择器 标签名/元素名 $(\"标签名/元素名\") 选择所有指定标签的元素对象 通用选择器 * $(\"*\") 选择页面中所有的元素对象 组合选择器 选择器1,选择器2,... $(\"选择器1,选择器2,...\") 选择指定选择器的元素对象 --\u003e \u003cscript type=\"text/javascript\"\u003e // id选择器 #id属性值 var mydiv = $(\"#mydiv1\") console.log(mydiv) // 1个 // 类选择器 .class属性值 var clas = $(\".blue\") console.log(clas) // 2个 // 元素选择器 标签名/元素名 var spans = $(\"span\") console.log(spans) // 2个 // 通用选择器 * var all = $(\"*\") console.log(all) // 12个 // 组合选择器 选择器1,选择器2,... var group = $(\"#mydiv1,div,.blue\") console.log(group) // 3个 \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:2:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#21-基础选择器"},{"categories":["在前端搬砖的日子里"],"content":" 2.2 层次选择器 选择器 名称 举例 后代选择器 ancestor descendant $(\"#parent div\")选择id为parent的元素的所有div元素 子代选择器 parent\u003echild $(\"#parent\u003ediv\")选择id为parent的直接div子元素 相邻选择器 prev+next $(\"#.blue + img\")选择css类为blue的下一个img元素 同辈选择器 prev~sibling $(\"#.blue ~ img\")选择css类为blue的之后的img元素 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-03\u003c/title\u003e \u003cstyle\u003e .testColor{ background: green; } .gray{ background: gray; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"parent\"\u003e 层次选择 \u003cdiv class=\"testColor\" id=\"child\"\u003e 父选择器 \u003cdiv class=\"gray\"\u003e子选择器\u003c/div\u003e \u003cimg src=\"../assets/img/16.webp\" alt=\"\" width=\"370px\" height=\"229px\"\u003e \u003cimg src=\"../assets/img/17.webp\" alt=\"\" width=\"370px\" height=\"229px\"\u003e \u003c/div\u003e \u003cdiv\u003e 选择器2\u003cdiv\u003e选择器2中的div\u003c/div\u003e \u003c/div\u003e \u003cp\u003ep元素\u003c/p\u003e \u003c/div\u003e \u003c/body\u003e \u003c!-- 层次选择器 后代选择器 格式：父元素 指定元素（空格隔开） 示例：$(\"父元素 元素\") 选择父元素的所有指定元素（包含第一代、第二代...） 子代选择器 格式：父元素 \u003e 指定元素（大于号隔开） 示例：$(\"父元素 \u003e 元素\") 选择父元素的所有第一代指定元素 相邻选择器 格式：父元素 + 指定元素（加号隔开） 示例：$(\"元素 + 指定元素\") 选择元素的下一个指定元素（只会查找下一个元素，如果元素不存在则获取不到） 同辈选择器 格式：元素 ~ 指定元素（波浪号隔开） 示例：$(\"元素 ~ 指定元素\") 选择元素的下面的所有指定元素 --\u003e \u003cscript type=\"text/javascript\"\u003e // 后代选择器 var hd = $(\"#parent div\") console.log(hd) // 4个 // 子代选择器 var zd = $(\"#parent \u003e div\") console.log(zd) // 2个 // 相邻选择器 var xl = $(\"#child + div\") console.log(xl) // 1个 // 假如相邻的不是指定元素，则返回的jQuery集是空的 var xl2 = $(\"child + p\") console.log(xl2) // 0个 // 同辈选择器 var tb = $(\".gray ~ img\") console.log(tb) // 2个 \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:2:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#22-层次选择器"},{"categories":["在前端搬砖的日子里"],"content":" 2.3 表单选择器 Forms 名称 举例 表单选择器 :input 查找所有的input元素：$(\":input\") 注意：会匹配所有的input、textarea和button元素。 文本框选择器 :text 查找所有文本框：$(\":text\") 密码框选择器 :password 查找所有密码框：$(\":password\") 单选按钮选择器 :radio 查找所有单选按钮：$(\":radio\") 复选框按钮选择器 :checkbox 查找所有复选框：$(\":checkbox\") 提交按钮选择器 :submit 查找所有提交按钮：$(\":submit\") 图像域选择器 :image 查找所有图像域：$(\":image\") 重置按钮选择器 :reset 查找所有重置按钮：$(\":reset\") 按钮选择器 :button 查找所有按钮：$(\":button\") 文件阈选择器 :file 查找所有文件阈：$(\":file\") 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-04\u003c/title\u003e \u003c/head\u003e \u003cbody style=\"text-align: center;\"\u003e \u003ch1\u003e表单选择器\u003c/h1\u003e \u003cform action=\"\" id=\"myform\" name=\"myform\" method=\"psot\"\u003e \u003cinput type=\"hidden\" name=\"uno\" id=\"\" value=\"9999\" disabled=\"disabled\"\u003e 姓名：\u003cinput type=\"text\" id=\"uname\" name=\"uname\" \u003e \u003cbr\u003e 密码：\u003cinput type=\"password\" id=\"upwd\" name=\"upwd\" value=\"123456\"\u003e \u003cbr\u003e 年龄：\u003cinput type=\"radio\" name=\"uage\" value=\"0\" checked=\"checked\"\u003e未成年嗷 \u003cinput type=\"radio\" name=\"uage\" value=\"1\"\u003e成年嗷 \u003cbr\u003e 爱好：\u003cinput type=\"checkbox\" name=\"ufav\" value=\"唱\"\u003e唱 \u003cinput type=\"checkbox\" name=\"ufav\" value=\"跳\"\u003e跳 \u003cinput type=\"checkbox\" name=\"ufav\" value=\"rap\"\u003erap \u003cinput type=\"checkbox\" name=\"ufav\" value=\"篮球\"\u003e篮球 \u003cbr\u003e 来自：\u003cselect name=\"ufrom\" id=\"ufrom\"\u003e \u003coption value=\"Gryffindor\"\u003eGryffindor\u003c/option\u003e \u003coption value=\"Hufflepuff\"\u003eHufflepuff\u003c/option\u003e \u003coption value=\"Ravenclaw\"\u003eRavenclaw\u003c/option\u003e \u003coption value=\"Slytherin\"\u003e\u003c/option\u003e \u003c/select\u003e \u003cbr\u003e 简介：\u003ctextarea name=\"uintro\" id=\"\" cols=\"30\" rows=\"10\"\u003e\u003c/textarea\u003e \u003cbr\u003e 头像：\u003cinput type=\"file\" name=\"\" id=\"\"\u003e \u003cbr\u003e \u003cinput type=\"image\" src=\"../assets/img/16.webp\" width=\"600px\" height=\"400px\"\u003e \u003cbr\u003e \u003cbutton type=\"submit\" onclick=\"return checkForm();\"\u003e提交\u003c/button\u003e \u003cbutton type=\"reset\"\u003e重置\u003c/button\u003e \u003c/form\u003e \u003c/body\u003e \u003c!-- 表单选择器 表单选择器 :input 查找所有的input元素：$(\":input\")注意：会匹配所有的input、textarea和button元素。 文本框选择器 :text 查找所有文本框：$(\":text\") 密码框选择器 :password 查找所有密码框：$(\":password\") 单选按钮选择器 :radio 查找所有单选按钮：$(\":radio\") 复选框按钮选择器 :checkbox 查找所有复选框：$(\":checkbox\") 提交按钮选择器 :submit 查找所有提交按钮：$(\":submit\") 图像域选择器 :image 查找所有图像域：$(\":image\") 重置按钮选择器 :reset 查找所有重置按钮：$(\":reset\") 按钮选择器 :button 查找所有按钮：$(\":button\") 文件阈选择器 :file 查找所有文件阈：$(\":file\")` --\u003e \u003cscript\u003e // 表单选择器 var inputs = $(\":input\") console.log(inputs) // 15个（input家族：input*11 + select*1 + textarea*1 + button*2） // 如果不加冒号(:)，就会是元素选择器 // 元素选择器 var inputs2 = $(\"input\") console.log(inputs2) // 11个（input元素*11） // 文本框选择器 var texts = $(\":text\") console.log(texts) // 1个 // 密码框选择器 var passwords = $(\":password\") console.log(passwords) // 1个 // 单选框选择器 var radioes = $(\":radio\") console.log(radioes) // 2个 // 复选框按钮选择器 var checkboxes = $(\":checkbox\") console.log(checkboxes) // 4个 // 提交按钮选择器 var submits = $(\":submit\") console.log(submits) // 1个 // 图像域按钮选择器 var images = $(\":image\") console.log(images) // 1个 // 重置按钮选择器 var resets = $(\":reset\") console.log(resets) // 1个 // 按钮选择器 var buttons = $(\":button\") console.log(buttons) // 2个 // 文件域选择器 var files = $(\":file\") console.log(files) // 1个 \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:2:3","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#23-表单选择器"},{"categories":["在前端搬砖的日子里"],"content":" 3. jQuery Dom操作jQuery也提供了对HTML节点的操作，而且在原生JS的基础上进行了优化，使用起来更加方便。 常用的从几个方面来操作： 查找元素（选择器已实现）； 创建节点元素； 访问和设置节点元素的值以及属性； 添加节点； 删除节点； 删除、添加、修改、设定节点的CSS样式； 注意：以下的操作只适用于jQuery对象 ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#3-jquery-dom操作"},{"categories":["在前端搬砖的日子里"],"content":" 3.1 操作元素的属性 方法 说明 举例 attr(属性名称) 获取指定的属性值 操作checkbox时，选中时返回checked，没有选择返回undefined。 attr('checked') attr('name') prop(属性名称) 获取具有true和false两个属性的属性值 prop('checked') 3.1.1 获取属性attr(\"属性名\") prop(\"属性名\") 3.1.2 设置属性attr(\"属性名\", \"属性值\") prop(\"属性名\", \"属性值\") 3.1.3 移除属性removeAttr(\"属性名\") 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-05\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cform action=\"\" id=\"myform\"\u003e \u003cinput type=\"checkbox\" name=\"ch\" id=\"aa\" sentence=\"first\" checked=\"checked\"\u003e悟已往之不谏 \u003cinput type=\"checkbox\" name=\"ch\" id=\"bb\" sentence=\"second\"\u003e知来者之可追 \u003c!-- 这里的sentence属性是我们自己添加的，并不是input元素原生的属性 --\u003e \u003c/form\u003e \u003c/body\u003e \u003c!-- 操作元素的属性 属性的分类： 固有属性：元素本身就有的属性（id\\name\\class\\...） 返回值是Boolean类型的属性：checked\\selected\\disabled 自定义属性：用户自己定义的属性 attr()和prop()的区别： 1. 如果是固有属性，attr()和prop()方法均可操作 2. 如果是自定义属性，attr()可操作，prop()不可操作 3. 如果是返回值是Boolean类型的属性 若设置了属性，attr()返回具体的值，prop()返回true 若未设置属性，attr()返回undefined，prop()返回false 1.获取属性 attr(\"属性名\") prop(\"属性名\") 2.设置属性 attr(\"属性名\", \"属性值\") prop(\"属性名\", \"属性值\") 3.移除属性 removeAttr(\"属性名\") 总结： 如果属性的类型是Boolean(checked\\selected\\disabled)，则使用prop()方法，否则使用attr()方法。 --\u003e \u003cscript\u003e // 获取name属性 // 固有属性：使用attr()和prop()都可以得到固有属性 var name = $(\"#aa\").attr(\"name\"); console.log(name) // ch var name2 = $(\"#aa\").prop(\"name\"); console.log(name2) // ch // 返回值是Boolean类型的属性： // 1. 元素设置了属性的：attr()返回具体的值，prop()返回true var ck1 = $(\"#aa\").attr(\"checked\") console.log(ck1) // checked var ck2 = $(\"#aa\").prop(\"checked\") console.log(ck2) // true // 2. 元素没有设置属性的：attr()返回undefined，prop()返回false var ck3 = $(\"#bb\").attr(\"checked\") console.log(ck3) // undefined var ck4 = $(\"#bb\").prop(\"checked\") console.log(ck4) // false // 自定义属性：attr()可获取，prop()不可获取 var sentence1 = $(\"#aa\").attr(\"sentence\") console.log(sentence1) // first var sentence2 = $(\"#aa\").prop(\"sentence\") console.log(sentence2) // undefined console.log(\"=======分割线=======\") // 设置属性 // 固有属性 $(\"#aa\").attr(\"value\", \"1\") $(\"#bb\").prop(\"value\", \"2\") // 返回值是Boolean类型的属性 $(\"#bb\").attr(\"checked\", \"checked\") $(\"#bb\").prop(\"checked\", false) // 自定义属性 $(\"#aa\").attr(\"writer\", \"陶渊明\") $(\"#aa\").prop(\"dynasty\", \"Jin\") // 这部分的运行结果可以通过Elements查看（属性操作结果1） // 只有attr()操作的writer被成功设置，prop()失败 // 移除属性 $(\"#aa\").removeAttr(\"checked\") // 结果就是\"悟已往之不谏\"显示不再被选中（属性操作结果2） \u003c/script\u003e \u003c/html\u003e 属性操作结果1： 属性操作结果2： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#31-操作元素的属性"},{"categories":["在前端搬砖的日子里"],"content":" 3.1 操作元素的属性 方法 说明 举例 attr(属性名称) 获取指定的属性值 操作checkbox时，选中时返回checked，没有选择返回undefined。 attr('checked') attr('name') prop(属性名称) 获取具有true和false两个属性的属性值 prop('checked') 3.1.1 获取属性attr(\"属性名\") prop(\"属性名\") 3.1.2 设置属性attr(\"属性名\", \"属性值\") prop(\"属性名\", \"属性值\") 3.1.3 移除属性removeAttr(\"属性名\") 学习代码： \u003c!DOCTYPE html\u003e 哆哆啦のJQuery学习笔记页面-05 悟已往之不谏 知来者之可追 属性操作结果1： 属性操作结果2： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#311-获取属性"},{"categories":["在前端搬砖的日子里"],"content":" 3.1 操作元素的属性 方法 说明 举例 attr(属性名称) 获取指定的属性值 操作checkbox时，选中时返回checked，没有选择返回undefined。 attr('checked') attr('name') prop(属性名称) 获取具有true和false两个属性的属性值 prop('checked') 3.1.1 获取属性attr(\"属性名\") prop(\"属性名\") 3.1.2 设置属性attr(\"属性名\", \"属性值\") prop(\"属性名\", \"属性值\") 3.1.3 移除属性removeAttr(\"属性名\") 学习代码： \u003c!DOCTYPE html\u003e 哆哆啦のJQuery学习笔记页面-05 悟已往之不谏 知来者之可追 属性操作结果1： 属性操作结果2： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#312-设置属性"},{"categories":["在前端搬砖的日子里"],"content":" 3.1 操作元素的属性 方法 说明 举例 attr(属性名称) 获取指定的属性值 操作checkbox时，选中时返回checked，没有选择返回undefined。 attr('checked') attr('name') prop(属性名称) 获取具有true和false两个属性的属性值 prop('checked') 3.1.1 获取属性attr(\"属性名\") prop(\"属性名\") 3.1.2 设置属性attr(\"属性名\", \"属性值\") prop(\"属性名\", \"属性值\") 3.1.3 移除属性removeAttr(\"属性名\") 学习代码： \u003c!DOCTYPE html\u003e 哆哆啦のJQuery学习笔记页面-05 悟已往之不谏 知来者之可追 属性操作结果1： 属性操作结果2： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#313-移除属性"},{"categories":["在前端搬砖的日子里"],"content":" 3.2 操作元素的样式元素的样式也是一种属性，由于样式用的特别多，所以对于样式除了当做属性处理外还可以有专门的方法进行处理。 方法 说明 attr(\"class\") 获取class属性的值，即样式名称 attr(\"class\", \"样式名\") 修改class属性的值，修改样式 addClass(\"样式名\") 添加样式的名称 css() 添加具体的样式 removeClass(class) 移除样式名称 增加元素的具体样式的格式： 1) css({'样式名1':'样式值1', '样式名2':'样式值2', '样式名3':'样式值3',...}) 例：css({\"background-color\": \"red\", \"color\": \"#fff\"}) 2) css(\"样式名\", \"样式值\") 例：css('color', 'black') 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-06\u003c/title\u003e \u003cstyle\u003e div{ padding: 8px; width: 180px; } .blue{ background: blue; } .larger{ font-size: 30px; } .green{ background: green; } /* .pink { background: pink; } */ \u003c/style\u003e \u003c/head\u003e \u003cbody style=\"text-align: center;\"\u003e \u003ch3\u003ecss()方法设置元素样式\u003c/h3\u003e \u003cdiv id=\"conBlue\" class=\"blue larger\"\u003eSo, get away.\u003c/div\u003e \u003cdiv id=\"conRed\"\u003eAnother way to feell what you didn't want yourself to know.\u003c/div\u003e \u003cdiv id=\"remove\" class=\"blue larger\"\u003eAnd let yourself go.\u003c/div\u003e \u003c/body\u003e \u003c!-- 操作元素的样式 attr(\"class\") 获取元素的class属性值 attr(\"class\", \"样式名\") 设置元素的样式（原本的样式会被新样式全部覆盖） addClass(\"样式名\") 添加样式（在原样式中添加样式，原本的样式会保留） css() 添加具体的样式（相当于添加行内样式，优先级高） removeClass(\"样式名\") 移除样式 --\u003e \u003cscript\u003e // attr(\"class\") 获取元素的样式名 var cla = $(\"#conBlue\").attr(\"class\") console.log(cla) // attr(\"class\", \"样式名\") 设置元素的样式 $(\"#conBlue\").attr(\"class\", \"green\") // 原本的样式会被全部覆盖 // addClass(\"样式名\") 添加样式 $(\"#conBlue\").addClass(\"larger\") $(\"#conBlue\").addClass(\"pink\") // 注意！.pink在style中的顺序会影响效果（CSS的默认显示顺序是后来居上），谁后定义显示谁（可见操作结果1） // css() 添加具体的样式（添加行内样式） $(\"#conRed\").css(\"font-size\", \"40px\") $(\"#conRed\").css({\"font-family\": \"Impact\", \"color\": \"orange\"}) // 可见操作结果2 // removeClass(\"样式名\") 移除样式 $(\"#remove\").removeClass(\"larger\") // 操作结果3 \u003c/script\u003e \u003c/html\u003e 操作结果1： 操作结果2： 操作结果3： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#32-操作元素的样式"},{"categories":["在前端搬砖的日子里"],"content":" 3.3 操作元素的内容对于元素还可以操作其中的内容，例如文本、值、甚至是html… 方法 说明 html() 获取元素的html内容 html(\"html, 内容\") 设定元素的html内容 text() 获取元素的文本内容，不包括html text(\"text 内容\") 设置元素的文本内容，不包括html val() 获取元素的value值 val('值') 设定元素的value值 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-07\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e\u003cspan\u003ehtml()和text()方法设置元素内容\u003c/span\u003e\u003c/h3\u003e \u003cdiv id=\"html\"\u003e\u003c/div\u003e \u003cdiv id=\"html2\"\u003e\u003c/div\u003e \u003cdiv id=\"html3\"\u003e\u003ch3\u003e============\u003c/h3\u003e\u003c/div\u003e \u003cdiv id=\"text\"\u003e\u003c/div\u003e \u003cdiv id=\"text2\"\u003e\u003c/div\u003e \u003cdiv id=\"text3\"\u003e\u003ch2\u003e《贺新郎》\u003c/h2\u003e\u003c/div\u003e \u003cinput type=\"text\" name=\"uname\" value=\"oops\" id=\"op\"\u003e \u003c/body\u003e \u003c!-- 操作元素的内容 html() 获取元素的内容，包含html标签（非表单元素） html(\"内容\") 设置元素的内容，包括html标签（非表单元素） text() 获取元素的纯文本内容，不识别HTML标签（所有的标签都会被当做字符串）（非表单元素） text(\"内容\") 设置元素的纯文本内容，不识别HTML标签（所有的标签都会被当做字符串）（非表单元素） val() 获取元素的value值（表单元素） val(\"值\") 设置元素的value值（表单元素） 表单元素： 文本框text、密码框password、单选框radio、复选框checkbox、隐藏阈hidden、文本域textarea、下拉框select、 非表单元素： div、span、h1~h6、table、tr、td、li、p等 --\u003e \u003cscript\u003e // html(\"内容\") 设置元素的内容，包括html标签（非表单元素） $(\"#html\").html(\"\u003ch2\u003e我见青山多妩媚\u003c/h2\u003e\") $(\"#html2\").html(\"料青山见我应如是\") // html() 获取元素的内容，包含html标签（非表单元素） var html = $(\"#html\").html() console.log(html) // 纯文本式的：\u003ch2\u003e我见青山多妩媚\u003ch2\u003e var html2 = $(\"#html2\").html() console.log(html2) // 料青山见我应如是 var html3 = $(\"#html3\").html() console.log(html3) // \u003ch3\u003e============\u003c/h3\u003e // 注意.html()方法将其中的html标签读出来了 // text(\"内容\") 设置元素的纯文本内容，不识别HTML标签（所有的标签都会被当做字符串）（非表单元素） $(\"#text\").text(\"\u003ch2\u003e情与貌\u003c/h2\u003e\") // 显示并没有识别html标签（见操作结果1） $(\"#text2\").text(\"略相似\") // text() 获取元素的纯文本内容，不识别HTML标签（所有的标签都会被当做字符串）（非表单元素） var text = $(\"#text\").text() console.log(text) // \u003ch2\u003e情与貌\u003c/h2\u003e var text2 = $(\"#text2\").text() console.log(text2) // 略相似 var text3 = $(\"#text3\").text() console.log(text3) // 《贺新郎》 // 注意，原本写在#text3中是有一个\u003ch2\u003e标签的，但是使用text()方法时并不会将该标签读成\"\u003ch2\u003e《贺新郎》\u003c/h2\u003e\" // val() 获取元素的值（表单元素） var val = $(\"#op\").val() console.log(val) // val(\"值\") 设置元素的value值（表单元素） $(\"#op\").val(\"星如雨\") \u003c/script\u003e \u003c/html\u003e 操作结果1： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:3","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#33-操作元素的内容"},{"categories":["在前端搬砖的日子里"],"content":" 3.4 创建元素在jQuery中创建元素很简单，直接使用核心函数即可 格式： $(\"元素内容\") 举例： $(\"\u003cp\u003e鹏北海，凤朝阳，又携书剑路茫茫。\u003c/p\u003e\") 代码操作示例 ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:4","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#34-创建元素"},{"categories":["在前端搬砖的日子里"],"content":" 3.5 添加元素 方法 说明 prepend(content) 在被选元素内部的开头插入元素或内容，被追加的content参数，可以是字符、HTML元素标记。 $(content).prependTo(selector) 把content元素或内容加入selector元素开头。 append(content) 在被选元素内部的结尾插入元素或内容，被追加的content参数，可以是字符、HTML元素标记。 $(content).appendTo(selector) 把content元素或内容插入selector元素内，默认是在尾部 before() 在元素前插入指定的元素或内容：$(selector).before(content)（兄弟级别） after() 在元素后插入指定的元素或内容：$(selector).after(content)（兄弟级别） 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-08\u003c/title\u003e \u003cstyle\u003e div{ margin: 10px 0px; } span{ color: white; padding: 8px; } .red{ background-color: red; } .blue{ background-color: blue; } .green{ background-color: green; } .pink{ background-color: pink; } .gray{ background-color: gray; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e.prepend()方法前追加内容\u003c/h3\u003e \u003ch3\u003e.prependTo()方法前追加内容\u003c/h3\u003e \u003ch3\u003e.append()方法后追加内容\u003c/h3\u003e \u003ch3\u003e.appendTo()方后前追加内容\u003c/h3\u003e \u003cspan class=\"red\"\u003e江畔何人初见月？江月何年初照人？\u003c/span\u003e \u003cspan class=\"blue\"\u003e藕丝秋色浅，人胜参差剪。\u003c/span\u003e \u003cdiv class=\"green\"\u003e \u003cspan\u003e江流宛转绕芳甸，月照花林皆似霰。\u003c/span\u003e \u003c/div\u003e \u003c/body\u003e \u003c!-- 创建元素和添加元素 创建元素 $(\"内容\") 添加元素 1. 前追加子元素 指定元素.prepend(内容) 在指定元素内部的最前面追加内容，内容可以是字符串、html元素或jQuery对象 $(内容).prependTo(指定元素) 把内容追加到指定元素内部的最前面，内容可以是字符串、html元素或jQuery对象 2. 后追加子元素 指定元素.append(内容) 在指定元素内部的最后面追加内容，内容可以是字符串、html元素或jQuery对象 $(内容).appendTo(指定元素) 把内容追加到指定元素内部的最后面，内容可以是字符串、html元素或jQuery对象 3. 前追加同级元素 before() 在指定元素的前面追加内容 4. 后追加同级元素 after() 在指定元素的后面追加元素 注意： 在添加元素时，如果元素本身不存在（新建的元素），此时会将元素追加到指定位置。 如果元素本身存在（已有元素），会将原来元素直接剪切设置到指定位置。 --\u003e \u003cscript\u003e // 创建元素 var p = \"\u003cp\u003e这是一个p标签\u003c/p\u003e\" console.log(p) // 是黑色字体的：\u003cp\u003e这是一个p标签\u003c/p\u003e，说明是字符串 console.log($(p)) // 是jQuery对象 // 添加元素 // 添加元素前要创建元素 // 1. 创建元素 var span = \"\u003cspan\u003e涟涟随波千万里，何处春江无月明。\u003c/span\u003e\" var span2 = \"\u003cspan\u003e春江潮水连海平，海上明月共潮生。\u003c/span\u003e\" // 得到指定元素，并在元素的内部最前面追加内容 $(\".green\").prepend(span) $(span2).prependTo($(\".green\")) var span3 = \"\u003cspan\u003e空里流霜不觉飞，汀上白沙看不见。\u003c/span\u003e\" var span4 = \"\u003cspan\u003e江天一色无纤尘，皎皎空中孤月轮。\u003c/span\u003e\" // 得到指定元素，并在元素的内部最后面追加内容 $(\".green\").append(span3) $(span4).appendTo($(\".green\")) // 将已存在内容追加到元素中 $(\".red\").appendTo($(\".green\")) // 同级追加 var sp1 = '\u003cspan class=\"pink\"\u003e江上柳如烟，雁飞残月天。\u003c/span\u003e' var sp2 = '\u003cspan class=\"gray\"\u003e双鬓隔香红，玉钗头上风。\u003c/span\u003e' $(\".blue\").before(sp1) $(\".blue\").after(sp2) \u003c/script\u003e \u003c/html\u003e 操作结果： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:5","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#35-添加元素"},{"categories":["在前端搬砖的日子里"],"content":" 3.6 删除元素学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-09\u003c/title\u003e \u003cstyle\u003e span{ color: white; padding: 8px; margin: 5px; float: left; } .green{ background-color: green; } .blue{ background-color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e删除元素\u003c/h3\u003e \u003cspan class=\"green\"\u003eGryffindor\u003c/span\u003e \u003cspan class=\"blue\"\u003eHufflepuff\u003c/span\u003e \u003cspan class=\"green\"\u003eRavenclaw\u003c/span\u003e \u003cspan class=\"blue\"\u003eSlytherin\u003c/span\u003e \u003c/body\u003e \u003c!-- 删除元素 remove() 删除元素及其对应的子元素，标签和内容一起删 指定元素.remove() empty() 清空元素内容，保留标签 指定元素.empty() --\u003e \u003cscript\u003e // 删除元素 $(\".green\").remove() // 操作效果1 // 清空元素 $(\".blue\").empty() // 操作效果1 \u003c/script\u003e \u003c/html\u003e 操作效果1： 初始状态: $(\".green\").remove()操作后： $(\".blue\").empty()操作后： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:6","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#36-删除元素"},{"categories":["在前端搬砖的日子里"],"content":" 3.7 遍历元素each() $(selector).each(function(index,element){})：遍历元素 参数function为遍历时的回调函数 index为遍历元素的序列号，从0开始 element是当前的元素，此时是dom元素 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-10\u003c/title\u003e \u003cstyle\u003e span { color: white; padding: 8px; margin: 5px; float: left; } .green { background-color: green; } .blue { background-color: blue; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e遍历元素 each()\u003c/h3\u003e \u003cspan class=\"green\"\u003eGryffindor\u003c/span\u003e \u003cspan class=\"green\"\u003eHufflepuff\u003c/span\u003e \u003cspan class=\"green\"\u003eRavenclaw\u003c/span\u003e \u003cspan class=\"green\"\u003eSlytherin\u003c/span\u003e \u003c/body\u003e \u003c!-- each() $(selector).each(function(index,element){})：遍历元素，形参index和element看需求决定写不写。 参数function为遍历时的回调函数 index为遍历元素的序列号，从0开始 element是当前的元素，此时是dom元素 --\u003e \u003cscript\u003e // 获取指定元素并遍历 $(\".green\").each(function(index, element){ console.log(index) console.log(element) console.log(this) console.log($(this)) //转成jQuery对象 }) // 操作结果1 \u003c/script\u003e \u003c/html\u003e 操作结果1： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:3:7","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#37-遍历元素"},{"categories":["在前端搬砖的日子里"],"content":" 4. jQuery事件","date":"2023-12-01","objectID":"/posts/jquery_notes/:4:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#4-jquery事件"},{"categories":["在前端搬砖的日子里"],"content":" 4.1 ready加载事件ready()类似于onLoad()事件 ready()可以写多个，按顺序执行 $(document).ready(function(){}) 语法： $(document).ready(function(){ xxxx }) 简写： $(function(){ xxxx }) 体会加载： 为了避免这种情况的发生，我们要将代码写到ready加载事件中 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-11\u003c/title\u003e \u003cscript\u003e // 获取元素 console.log($(\"#p1\")) // 发现是空的 // 代码从上往下执行，当这部分js代码写在开头时，网页的dom对象并没有加载完，所以是空的 // 预加载处理后： $(document).ready(function(){ console.log($(\"#p1\")) // 不是空的 }) // 另一种简写法： $(function(){ console.log($(\"#p1\")) }) \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cp id=\"p1\"\u003e文本\u003c/p\u003e \u003c/body\u003e \u003c!-- ready加载事件 预加载事件 当页面的dom结构加载完毕后执行 类似于js中load事件 语法： $(document).ready(function(){ xxxx }) 简写： $(function(){ xxxx }) --\u003e \u003cscript\u003e // 获取元素 console.log($(\"#p1\")) // 发现不是空的 \u003c/script\u003e \u003c/html\u003e 操作结果1： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:4:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#41-ready加载事件"},{"categories":["在前端搬砖的日子里"],"content":" 4.2 绑定事件为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 语法： $(selector.bind(eventType [, eventData], handler(eventObject))); eventType：是一个字符串类型的事件类型，就是你所需要绑定的事件。 ​ 这类型可以包括如下： ​ blur，focus，focusout，load，resize，scroll，unload，click，dblclick ​ mousedown，mouseup，mousemove，mouseover，mouseout，mouseenter ​ mouseleave，change，select，submit，keydown，keypress，keyup，error [, eventData]：传递的参数，格式：{名1: 值1, 名2: 值2} handler(eventObject)：该事件触发执行的函数。 4.2.1 简单的bind()事件 4.2.2 绑定多个事件学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-12\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003ebind()方法简单的绑定事件\u003c/h3\u003e \u003c!-- style=\"cursor: pointer;\"设置鼠标图标 --\u003e \u003cdiv id=\"test\" style=\"cursor: pointer;\"\u003e点击查看名言\u003c/div\u003e \u003cinput type=\"button\" name=\"\" id=\"btntest\" value=\"点击就会变得不可用了\"\u003e \u003chr\u003e \u003cbutton type=\"button\" id=\"btn1\"\u003e按钮1\u003c/button\u003e \u003cbutton type=\"button\" id=\"btn2\"\u003e按钮2\u003c/button\u003e \u003cbutton type=\"button\" id=\"btn3\"\u003e按钮3\u003c/button\u003e \u003cbutton type=\"button\" id=\"btn4\"\u003e按钮4\u003c/button\u003e \u003c/body\u003e \u003c!-- 绑定事件 bind绑定事件 为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 语法： $(selector.bind(eventType [, eventData], handler(eventObject))); eventType：是一个字符串类型的事件类型，就是你所需要绑定的事件。 [, eventData]：传递的参数，格式：{名1: 值1, 名2: 值2} handler(eventObject)：该事件触发执行的函数。 绑定单个事件： bind()绑定： $(\"元素\").bind(\"事件类型\", function(){ xxxx }) 直接绑定： $(\"元素\").事件名(function(){ xxxx }) 绑定多个事件： bind绑定： 1. 同时为多个事件绑定同一个函数 指定元素.bind(\"事件类型1 事件类型2 ...\", function(){ xxxx }) 2. 为元素绑定多个事件，并设置对应函数 指定元素.bind(\"事件类型1\", function(){ xxxx }).bind(\"事件类型2\", function(){ xxxx }); 3. 为元素绑定多个事件，并设置对应的函数 指定元素.bind({ \"事件类型1\": function(){ xxxx }, \"事件类型2\": function(){ xxxx } ... }) 直接绑定： 指定元素.事件名(function(){ xxxx }).事件名(function(){ xxxx }); --\u003e \u003cscript\u003e /* 1.确定为哪些元素绑定事件 获取元素 2.绑定什么事件（事件类型） 第一个参数：事件的类型 3.相应事件触发的（执行的操作） 第二个参数：函数 */ // 绑定单个事件 $(\"#test\").bind('click', function(){ // 主要不用写成onclick，\"on\"就是绑定的意思，也就是bind() console.log(\"救一人，便救全世界。\") }) // 原生js绑定事件 document.getElementById(\"test\").onclick = function(){ console.log(\"大海才是他的琴键。\") } // 直接绑定 $(\"#btntest\").click(function(){ // 禁用按钮 console.log(this) // this是绑定的按钮对象 $(this).prop('disabled', true); // 点击一次后按钮变灰，按钮被禁用 }) // 绑定多个事件 // 1. 同时为多个事件绑定同一个函数 $(\"#btn1\").bind('click mouseout',function () { console.log(\"按钮1的事件\") }) // 2. 为元素绑定多个事件，并设置对应函数 $(\"#btn2\").bind(\"click\", function(){ console.log(\"按钮2被点击了\") }).bind(\"mouseout\", function () { console.log(\"鼠标移开按钮2了\") }) // 3. 为元素绑定多个事件，并设置对应的函数 $(\"#btn3\").bind({ \"click\": function () { console.log(\"按钮3被点击了\") }, \"mouseout\":function(){ console.log(\"鼠标移开按钮3了\") } }) // 4. 直接绑定 $(\"#btn4\").click(function () { console.log(\"按钮4被点击了\") }).mouseout(function(){ console.log(\"鼠标移开按钮4了\") }) \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:4:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#42-绑定事件"},{"categories":["在前端搬砖的日子里"],"content":" 4.2 绑定事件为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 语法： $(selector.bind(eventType [, eventData], handler(eventObject))); eventType：是一个字符串类型的事件类型，就是你所需要绑定的事件。 ​ 这类型可以包括如下： ​ blur，focus，focusout，load，resize，scroll，unload，click，dblclick ​ mousedown，mouseup，mousemove，mouseover，mouseout，mouseenter ​ mouseleave，change，select，submit，keydown，keypress，keyup，error [, eventData]：传递的参数，格式：{名1: 值1, 名2: 值2} handler(eventObject)：该事件触发执行的函数。 4.2.1 简单的bind()事件 4.2.2 绑定多个事件学习代码： \u003c!DOCTYPE html\u003e 哆哆啦のJQuery学习笔记页面-12 bind()方法简单的绑定事件 点击查看名言 按钮1 按钮2 按钮3 按钮4 ","date":"2023-12-01","objectID":"/posts/jquery_notes/:4:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#421-简单的bind事件"},{"categories":["在前端搬砖的日子里"],"content":" 4.2 绑定事件为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。 语法： $(selector.bind(eventType [, eventData], handler(eventObject))); eventType：是一个字符串类型的事件类型，就是你所需要绑定的事件。 ​ 这类型可以包括如下： ​ blur，focus，focusout，load，resize，scroll，unload，click，dblclick ​ mousedown，mouseup，mousemove，mouseover，mouseout，mouseenter ​ mouseleave，change，select，submit，keydown，keypress，keyup，error [, eventData]：传递的参数，格式：{名1: 值1, 名2: 值2} handler(eventObject)：该事件触发执行的函数。 4.2.1 简单的bind()事件 4.2.2 绑定多个事件学习代码： \u003c!DOCTYPE html\u003e 哆哆啦のJQuery学习笔记页面-12 bind()方法简单的绑定事件 点击查看名言 按钮1 按钮2 按钮3 按钮4 ","date":"2023-12-01","objectID":"/posts/jquery_notes/:4:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#422-绑定多个事件"},{"categories":["在前端搬砖的日子里"],"content":" 5. jQuery Ajax异步无刷新！ ","date":"2023-12-01","objectID":"/posts/jquery_notes/:5:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#5-jquery-ajax"},{"categories":["在前端搬砖的日子里"],"content":" 5.1 $.ajax()jQuery调用Ajax的方法： 格式： $.ajax({}); 参数 说明 type 请求方式GET/POST url 请求地址url async 是否同步，默认是true表示异步 data 发送到服务器的数据 dataType 预期服务器返回的数据类型（默认是字符串型） contentType 设置请求头 success 请求成功时调用此函数 error 请求失败时调用此函数 这里推荐一个vscode中的插件：Live Server 它可以实时地反应网页的变化，安装后在html文件中右键选择open with live server即可使用 注意：要开服务器操作，否则会报跨域问题。 学习代码： JSON： [ { \"userId\": 1, \"userName\": \"Harry James Potter\", \"userSchool\": \"Gryffindor\", \"userAge\": 13 }, { \"userId\": 2, \"userName\": \"Hermione Jean Granger\", \"userSchool\": \"Gryffindor\", \"userAge\": 14 }, { \"userId\": 3, \"userName\": \"Ronald Bilius Weasley\", \"userSchool\": \"Gryffindor\", \"userAge\": 13 }, { \"userId\": 4, \"userName\": \"Percy Ignatius Weasley\", \"userSchool\": \"Gryffindor\", \"userAge\": 17 }, { \"userId\": 5, \"userName\": \"Remus Lupin\", \"userSchool\": \"Gryffindor\", \"userAge\": 33 }, { \"userId\": 6, \"userName\": \"Albus Percival Wulfric Brian Dumbledore\", \"userSchool\": \"Gryffindor\", \"userAge\": 112 } ] TXT: [ { \"userId\": 1, \"userName\": \"Harry James Potter\", \"userSchool\": \"Gryffindor\", \"userAge\": 13 }, { \"userId\": 2, \"userName\": \"Hermione Jean Granger\", \"userSchool\": \"Gryffindor\", \"userAge\": 14 }, { \"userId\": 3, \"userName\": \"Ronald Bilius Weasley\", \"userSchool\": \"Gryffindor\", \"userAge\": 13 }, { \"userId\": 4, \"userName\": \"Percy Ignatius Weasley\", \"userSchool\": \"Gryffindor\", \"userAge\": 17 }, { \"userId\": 5, \"userName\": \"Remus Lupin\", \"userSchool\": \"Gryffindor\", \"userAge\": 33 }, { \"userId\": 6, \"userName\": \"Albus Percival Wulfric Brian Dumbledore\", \"userSchool\": \"Gryffindor\", \"userAge\": 112 } ] HTML： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-13\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"btn\"\u003e查询数据\u003c/button\u003e \u003c/body\u003e \u003c!-- jquery调用Ajax的方法： 格式： $.ajax({}); 参数： type 请求方式GET/POST url 请求地址url async 是否同步，默认是true表示异步 data 发送到服务器的数据 dataType 预期服务器返回的数据类型 contentType 设置请求头 success 请求成功时调用此函数 error 请求失败时调用此函数 --\u003e \u003cscript\u003e // 请求.txt数据 $.ajax({ type: \"GET\", //请求方式 url: \"../assets/source/data.txt\", data:{ // 请求数据，json对象 uname: \"Hermione Jean Granger\" // 如果没有参数，则不需要设置 }, // 请求成功时调用的函数 success: function (data) { // 这里的data只是个形参 console.log(data) // 字符串 操作结果1 // 将字符串转换成json对象 var obj = JSON.parse(data); console.log(obj) // json对象（一个js数组） 操作结果2 // 这样可以直接使用数组下标去取值操作 } }) // 请求.json数据 $.ajax({ type: \"GET\", //请求方式 url: \"../assets/source/data.json\", data: { // 请求数据，json对象 // uname: \"Hermione Jean Granger\" // 如果没有参数，则不需要设置 }, dataType: \"json\", // 预期返回的数据类型，如果是json格式，我们接收到返回值时，会自动封装成json对象 // 请求成功时调用的函数 success: function (data) { // 这里的data只是个形参 console.log(data) // json对象（是一个js数组） 操作结果3 // 如果又使用JSON.parse()转换，会报错 /* var obj = JSON.parse(data); console.log(obj) */ // 所以使用dataType来规定后台返回的数据类型 // Dom操作 // 创建ul var ul = $(\"\u003cul\u003e\u003c/ul\u003e\") console.log(ul) // 遍历返回的数据数组 for (var i = 0; i \u003c data.length; i++){ // 得到数组中的每一个元素 var user = data[i] // 创建li元素 var li = \"\u003cli\u003e\"+user.userName+\"\u003c/li\u003e\" // 将li元素设置到ul元素中 ul.append(li) } console.log(ul) // 将ul设置到body标签中 $(\"body\").append(ul) // 操作结果4 } }) // 尝试来个点击事件~（点击显示学院） // 点击按钮，发送Ajax请求，将数据显示到页面中 // $(\"#btn\").click(function () { 这里面可以写下面的Ajax请求 }) $(\"#btn\").click(function () { $.ajax({ type: \"GET\", //请求方式 url: \"../assets/source/data.json\", data: {}, dataType: \"json\", // 请求成功时调用的函数 success: function (data) { console.log(data) // Dom操作 // 创建ul var ul = $(\"\u003cul\u003e\u003c/ul\u003e\") console.log(ul) // 遍历返回的数据数组 for (var i = 0; i \u003c data.length; i++) { // 得到数组中的每一个元素 var user = data[i] // 创建li元素 var li = \"\u003cli\u003e\" + user.userSchool + \"\u003c/li\u003e\" // 将li元素设置到ul元素中 ul.append(li) } console.log(ul) // 将ul设置到body标签中 $(\"body\").append(ul) // 操作结果5 } }) }) \u003c/script\u003e \u003c/html\u003e 操作结果1： 操作结果2： 操作结果3： 操作结果4： 操作结果5： ","date":"2023-12-01","objectID":"/posts/jquery_notes/:5:1","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#51-ajax"},{"categories":["在前端搬砖的日子里"],"content":" 5.2 $.get()和$.post()这是一个简单的GET请求功能以取代复杂的$.ajax() 请求成功时可调用回调函数。如果需要在出错时执行函数，请使用$.ajax() // 1.请求json文件，忽略返回值 $.get('url') // 2.请求json文件，传递参数，忽略返回值 $.get('url', {参数名1:参数值1, 参数名2:参数值2}) // 3.请求json文件，拿到返回值，请求成功后可拿到返回值 $.get('url',function(data){ xxxx }) // 4.请求json文件，传递参数，拿到返回值 $.get('url',{参数名1:参数值1, 参数名2:参数值2},function(data){ xxxx }) $.post()和$.get()语法一模一样 // 1.请求json文件，忽略返回值 $.get('url') // 2.请求json文件，传递参数，忽略返回值 $.get('url', {参数名1:参数值1, 参数名2:参数值2}) // 3.请求json文件，拿到返回值，请求成功后可拿到返回值 $.get('url',function(data){ xxxx }) // 4.请求json文件，传递参数，拿到返回值 $.get('url',{参数名1:参数值1, 参数名2:参数值2},function(data){ xxxx }) 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-14/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c!-- $.get(); 语法： $.get(\"请求地址\",\"请求参数\",function(形参){ xxxx }) $.post(); 语法： $.post(\"请求地址\",\"请求参数\",function(形参){ xxxx }) --\u003e \u003cscript\u003e // $.get() $.get(\"../assets/source/data.json\",{},function (data) { console.log(data) // 返回数组，和$.ajax()一样 }) // $.post() $.post(\"../assets/source/data.json\", {}, function (data) { console.log(data) // 返回数组，和$.ajax()一样 }) // 现在没有服务器，所以post请求会是404（Not Found） \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:5:2","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#52-get和post"},{"categories":["在前端搬砖的日子里"],"content":" 5.3 $.getJSON()表示请求返回的数据类型是json格式的Ajax请求。 $.getJSON('url',{参数名1:参数值1, 参数名2:参数值2},function(形参){ xxxx }) 学习代码： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- JQuery引入 --\u003e \u003cscript src=\"../assets/js/code.jquery.com_jquery-3.7.0.js\"\u003e\u003c/script\u003e \u003ctitle\u003e哆哆啦のJQuery学习笔记页面-14/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c!-- $.getJSON 语法： $.getJSON(\"请求地址\", \"请求参数\", function(形参){ xxxx }) 注：getJSON方式要求返回的数据格式满足json格式（json字符串） --\u003e \u003cscript\u003e $.getJSON(\"../assets/source/data.json\",{},function(data){ console.log(data) }) // 如果返回的数据不是json格式，则无法获取 \u003c/script\u003e \u003c/html\u003e ","date":"2023-12-01","objectID":"/posts/jquery_notes/:5:3","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#53-getjson"},{"categories":["在前端搬砖的日子里"],"content":" jQuery自定义函数怎样用jQuery自定义函数方法，用$可调用_jquery怎么自定义方法_weixin_43798882的博客-CSDN博客 ","date":"2023-12-01","objectID":"/posts/jquery_notes/:6:0","series":null,"tags":["前端","jQuery","JavaScript"],"title":"哆哆啦のjQuery学习笔记（超细）（23.07.28）","uri":"/posts/jquery_notes/#jquery自定义函数"},{"categories":["关于Hugo的一些设置"],"content":"这部分是2023/11/30更新的一些基础样式设置，包括到设置友链 ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:0","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#"},{"categories":["关于Hugo的一些设置"],"content":" 基础设置参考：Features · adityatelange/hugo-PaperMod Wiki (github.com) 我的初步设置一览： # 参考：https://www.sulvblog.cn/posts/blog/build_hugo/ # hugo.toml baseURL = \"https://florae006.github.io/\" # 绑定的域名 title = \"DODOLA's WareHouse\" paginate = 5 theme = \"hugo-PaperMod\" # 主题名字 languageCode = \"zh-cn\" # en-us enableInlineShortcodes = true # 允许内联短码 enableRobotsTXT = true # 允许爬虫抓取到搜索引擎 buildDrafts = false buildFuture = false buildExpired = false enableEmoji = true # 允许抓取emoji表情 pygmentsUseClasses = true hasCJKLanguage = true # 自动检测是否包含 中文日文韩文 如果文中使用较多中文引号可以开启 # googleAnalytics = \"\" # 谷歌统计 # copyright = \"\" [minify] disableXML = true [permalinks] post=\"/:title/\" [language.en] languageName=\"English\" weight=1 [[languages.en.menu.main]] name = \"🔍搜索\" url = \"search\" weight = 1 [[languages.en.menu.main]] name = \"🏡主页\" url = \"/\" weight = 2 [[languages.en.menu.main]] name = \"🐙文章\" url = \"posts\" weight = 3 [[languages.en.menu.main]] identifier=\"archives\" name = \"时间轴\" url = \"archives/\" weight = 20 [[languages.en.menu.main]] identifier=\"tags\" name = \"标签\" url = \"tags\" weight = 40 [[languages.en.menu.main]] identifier=\"about\" name = \"关于\" url = \"tags\" weight = 50 [[languages.en.menu.main]] identifier=\"links\" name = \"友链\" url = \"links\" weight = 60 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] [params.profileMode] enabled=true title=\"✧*｡ (ˊᗜˋ*) ✧*｡\" subtitle=\"⭐️INTJ/Acmer/前端/二次元⭐️\u003cbr/\u003eWit beyond measure is man's greatest treasure.\u003cbr/\u003e👋欢迎光临哆哆啦的小仓库\u003cbr/\u003e⭐️社交账号一览👇\" imageUrl=\"img/dodola.png\" imageTitle=\"DODOLA\" imageWidth=150 imageHeight=150 [[params.profileMode.buttons]] name=\"🧱建站\" url=\"posts/startsite\" [[params.profileMode.buttons]] name=\"👩🏻‍💻技术\" url=\"posts/tech\" [[params.profileMode.buttons]] name=\"📚书影音\" url=\"posts/beauty\" [[params.profileMode.buttons]] name=\"🌇生活\" url=\"posts/life\" [params] env = \"production\" description = \"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod\" author = \"DODOLA\" defaultTheme = \"auto\" disableThemeToggle=false # DateFormat=\"2006-01-02\" ShowShareButtons = true ShowReadingTime = true displayFullLangName = true ShowPostNavLinks = true ShowBreadCrumbs = true ShowCodeCopyButtons = true hideFooter=false ShowWordCounts=true visitCount=true ShowLastMod=true ShowRssButtonInSectionTermList = true ShowToc = true TocOpen=true comments=true images = [\"papermod-cover.png\"] [[params.socialIcons]] name = \"github\" url = \"https://github.com/Florae006\" # [[params.socialIcons]] # name = \"twitter\" # url = \"img/twitter.png\" # [[params.socialIcons]] # name = \"facebook\" # url = \"\" # [[params.socialIcons]] # name = \"instagram\" # url = \"img/instagram.png\" [[params.socialIcons]] name = \"QQ\" url = \"img/qq.png\" # [[params.socialIcons]] # name = \"WeChat\" # url = \"img/wechat.png\" [[params.socialIcons]] name = \"email\" url = \"mailto:flora_chen2021@163.com\" [[params.socialIcons]] name = \"RSS\" url = \"index.xml\" [params.label] text = \"DODOLA's WareHouse\" icon = \"#\" iconHeight = 35 [params.asset] favicon = \"img/dodola.jpg\" favicon16x16 = \"img/dodola.jpg\" favicon32x32 = \"img/dodola.jpg\" apple_touch_icon = \"dodola.jpg\" safari_pinned_tab = \"dodola.jpg\" [params.fuseOpts] isCaseSensitive = false shouldSort = true location = 0 distance = 1_000 threshold = 1 minMatchCharLength = 0 keys = [ \"title\", \"permalink\", \"summary\" ] [params.twikoo] version = \"1.4.11\" [taxonomies] category = \"categories\" tag = \"tags\" series = \"series\" [markup.goldmark.renderer] unsafe = true [markup.highlight] codeFences = true guessSyntax = true lineNos = true [privacy.vimeo] disabled = false simple = true [privacy.twitter] disabled = false enableDNT = true simple = true [privacy.instagram] disabled = false simple = true [privacy.youtube] disabled = false privacyEnhanced = true [services.instagram] disableInlineCSS = true [services.twitter] disableInlineCSS = true 呈现效果： ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:1","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#基础设置"},{"categories":["关于Hugo的一些设置"],"content":" 搜索功能实现PaperMod已集成 Fuse.js 实现搜索功能，相关Fuse.js的API 新建页面 hugo new search.md 修改内容 +++ title = 'Search' date = 2023-11-29T13:39:10+08:00 draft = false summary = 'search' placeholder= '搜索站内内容' layout = 'search' searchHidden = true +++ 如果想隐藏搜索关联框，可以设置这个参数： searchHidden = true 在hugo.toml中 # 设置identifier [[languages.en.menu.main]] identifier=\"Search\" name = \"🔍搜索\" url = \"search\" weight = 1 # 添加搜索参数 [[params.fuseOpt]] isCaseSensitive = false includeMatches = true shouldSort = true location = 0 distance = 1000 threshold = 0.4 minMatchCharLength = 0 keys=['title', 'permalink', 'summary', 'content'] 搜索页展示标签列表在./layouts/_default/search.html {{- if not (.Param \"hideSeries\")}} {{- $taxonomies := .Site.Taxonomies.series }} {{- if gt (len $taxonomies) 0 }} \u003ch2 style=\"margin-top: 32px\"\u003e{{- (.Param \"seriesTitle\") | default \"series\" }}\u003c/h2\u003e \u003cul class=\"terms-tags\"\u003e {{- range $name, $value := $taxonomies }} {{- $count := .Count }} {{- with site.GetPage (printf \"/series/%s\" $name) }} \u003cli\u003e \u003ca href=\"{{ .Permalink }}\"\u003e{{ .Name }} \u003csup\u003e\u003cstrong\u003e\u003csup\u003e{{ $count }}\u003c/sup\u003e\u003c/strong\u003e\u003c/sup\u003e \u003c/a\u003e \u003c/li\u003e {{- end }} {{- end }} \u003c/ul\u003e {{- end }} {{- end }} {{- end }}{{/* end main */}} \u003c!-- 在最后一行前加入上面的代码 --\u003e 在hugo.toml中检查是否有这项 [taxonomies] category = \"categories\" tag = \"tags\" series = \"series\" 效果： ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:2","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#搜索功能实现"},{"categories":["关于Hugo的一些设置"],"content":" 搜索功能实现PaperMod已集成 Fuse.js 实现搜索功能，相关Fuse.js的API 新建页面 hugo new search.md 修改内容 +++ title = 'Search' date = 2023-11-29T13:39:10+08:00 draft = false summary = 'search' placeholder= '搜索站内内容' layout = 'search' searchHidden = true +++ 如果想隐藏搜索关联框，可以设置这个参数： searchHidden = true 在hugo.toml中 # 设置identifier [[languages.en.menu.main]] identifier=\"Search\" name = \"🔍搜索\" url = \"search\" weight = 1 # 添加搜索参数 [[params.fuseOpt]] isCaseSensitive = false includeMatches = true shouldSort = true location = 0 distance = 1000 threshold = 0.4 minMatchCharLength = 0 keys=['title', 'permalink', 'summary', 'content'] 搜索页展示标签列表在./layouts/_default/search.html {{- if not (.Param \"hideSeries\")}} {{- $taxonomies := .Site.Taxonomies.series }} {{- if gt (len $taxonomies) 0 }} {{- (.Param \"seriesTitle\") | default \"series\" }} {{- range $name, $value := $taxonomies }} {{- $count := .Count }} {{- with site.GetPage (printf \"/series/%s\" $name) }} {{ .Name }} {{ $count }} {{- end }} {{- end }} {{- end }} {{- end }} {{- end }}{{/* end main */}} 在hugo.toml中检查是否有这项 [taxonomies] category = \"categories\" tag = \"tags\" series = \"series\" 效果： ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:2","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#新建页面"},{"categories":["关于Hugo的一些设置"],"content":" 搜索功能实现PaperMod已集成 Fuse.js 实现搜索功能，相关Fuse.js的API 新建页面 hugo new search.md 修改内容 +++ title = 'Search' date = 2023-11-29T13:39:10+08:00 draft = false summary = 'search' placeholder= '搜索站内内容' layout = 'search' searchHidden = true +++ 如果想隐藏搜索关联框，可以设置这个参数： searchHidden = true 在hugo.toml中 # 设置identifier [[languages.en.menu.main]] identifier=\"Search\" name = \"🔍搜索\" url = \"search\" weight = 1 # 添加搜索参数 [[params.fuseOpt]] isCaseSensitive = false includeMatches = true shouldSort = true location = 0 distance = 1000 threshold = 0.4 minMatchCharLength = 0 keys=['title', 'permalink', 'summary', 'content'] 搜索页展示标签列表在./layouts/_default/search.html {{- if not (.Param \"hideSeries\")}} {{- $taxonomies := .Site.Taxonomies.series }} {{- if gt (len $taxonomies) 0 }} {{- (.Param \"seriesTitle\") | default \"series\" }} {{- range $name, $value := $taxonomies }} {{- $count := .Count }} {{- with site.GetPage (printf \"/series/%s\" $name) }} {{ .Name }} {{ $count }} {{- end }} {{- end }} {{- end }} {{- end }} {{- end }}{{/* end main */}} 在hugo.toml中检查是否有这项 [taxonomies] category = \"categories\" tag = \"tags\" series = \"series\" 效果： ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:2","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#搜索页展示标签列表"},{"categories":["关于Hugo的一些设置"],"content":" 添加图标PaperMod原有的图标一览： https://github.com/adityatelange/hugo-PaperMod/wiki/Icons 添加自定义图标找到这个文件：./layouts/partials/svg.html，在里面插入这样一段（插在哪里看原来的上下文应该能看出来，这是长长的if else…）： \u003c!-- 这里的icon_name填自定义的检索name --\u003e {{- else if (eq $icon_name \"xxx\") -}} \u003c!-- 这里粘贴想要的svg --\u003e \u003csvg\u003e \u003c!-- 注意，要是想要图标的颜色根据主题进行变化，要在svg标签内写上 fill=\"currentColor\" --\u003e ... \u003c/svg\u003e 找想要的图标可以在这，复制svg就行： # 阿里巴巴矢量图标库 https://www.iconfont.cn/ 之后在hugo.toml中这样使用（和原生的用法一模一样）： [[params.socialIcons]] name = \"douban\" url = \"\" ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:3","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#添加图标"},{"categories":["关于Hugo的一些设置"],"content":" 添加图标PaperMod原有的图标一览： https://github.com/adityatelange/hugo-PaperMod/wiki/Icons 添加自定义图标找到这个文件：./layouts/partials/svg.html，在里面插入这样一段（插在哪里看原来的上下文应该能看出来，这是长长的if else…）： {{- else if (eq $icon_name \"xxx\") -}} ... 找想要的图标可以在这，复制svg就行： # 阿里巴巴矢量图标库 https://www.iconfont.cn/ 之后在hugo.toml中这样使用（和原生的用法一模一样）： [[params.socialIcons]] name = \"douban\" url = \"\" ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:3","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#添加自定义图标"},{"categories":["关于Hugo的一些设置"],"content":" 设置友链在根目录下.\\assets\\css\\extended\\blank.css中添加样式内容，\\extended\\blank.css是可以覆盖已有的样式的地方，同理，我们也可以在其中添加我们想要的样式，另外，我们也可以在\\extended\\下新建一个fiendlink.css来写入友链卡片的样式，这是设置的友链的样式： .friend-url { text-decoration: none !important; box-shadow: none !important; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%!important; padding: 2px; margin-top: 20px !important; margin-left: 14px !important; background-color: #fff; } .friend-div { overflow: auto; height: 100px; width: 49%; display: inline-block !important; border-radius: 5px; background: none; -webkit-transition: all ease-out 0.3s; -moz-transition: all ease-out 0.3s; -o-transition: all ease-out 0.3s; transition: all ease-out 0.3s; } .dark .friend-div:hover { background: var(--code-bg); } .friend-div:hover { /* background: var(--theme); */ background: #e4e4e4; /* 我设置了随机背景色彩，后面有提到捏 */ transition: transform 1s; -webkit-transform: scale(1.1); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1.1); } .friend-div:hover .friend-div-left img { transition: 0.9s !important; -webkit-transition: 0.9s !important; -moz-transition: 0.9s !important; -o-transition: 0.9s !important; -ms-transition: 0.9s !important; transform: rotate(360deg) !important; -webkit-transform: rotate(360deg) !important; -moz-transform: rotate(360deg) !important; -o-transform: rotate(360deg) !important; -ms-transform: rotate(360deg) !important; } .friend-div-left { width: 92px; float: left; margin-right: -5px; } .friend-div-right { margin-top: 18px; margin-right: 18px; } .friend-name { text-overflow: ellipsis; font-size: 100%; margin-bottom: 5px; color: var(--primary); } .friend-info { text-overflow: ellipsis; font-size: 70%; color: var(--primary); } @media screen and (max-width: 600px) { .friend-info { display: none; } .friend-div-left { width: 84px; margin: auto; } .friend-div-right { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friend-name { font-size: 18px; } } 在.\\layouts\\shortcodes\\下新建一个friend.html填入以下内容： {{- if .IsNamedParams -}} \u003ca target=\"_blank\" href={{ .Get \"link\" }} title={{ .Get \"name\" }} class=\"friend-url\"\u003e \u003cdiv class=\"friend-div\"\u003e \u003cdiv class=\"friend-div-left\"\u003e \u003cimg class=\"myfriend\" src={{ .Get \"avatar\" }} /\u003e \u003c/div\u003e \u003cdiv class=\"friend-div-right\"\u003e \u003cdiv class=\"friend-name\"\u003e{{- .Get \"name\" -}}\u003c/div\u003e \u003cdiv class=\"friend-info\"\u003e{{- .Get \"description\" -}}\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/a\u003e {{- end }} 之后在.\\content\\下的links.md写下这样的内容： 这样就能展现友链啦，像这样： 实现随机背景色如果想要每次都获得不同的背景，可以试试在friend.html下添加这样的js代码： \u003cscript\u003e window.onload=function () { const randomHex = () =\u003e `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 0.5)`; var friendArr=document.getElementsByClassName(\"friend-div\"),temp=[]; for(var i=0;i\u003cfriendArr.length;i++){ friendArr[i].style.background=randomHex(); } } \u003c/script\u003e 这段代码的意思就是在加载完毕之后给名片的卡片背景添加不同的色彩 ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:4","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#设置友链"},{"categories":["关于Hugo的一些设置"],"content":" 设置友链在根目录下.\\assets\\css\\extended\\blank.css中添加样式内容，\\extended\\blank.css是可以覆盖已有的样式的地方，同理，我们也可以在其中添加我们想要的样式，另外，我们也可以在\\extended\\下新建一个fiendlink.css来写入友链卡片的样式，这是设置的友链的样式： .friend-url { text-decoration: none !important; box-shadow: none !important; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%!important; padding: 2px; margin-top: 20px !important; margin-left: 14px !important; background-color: #fff; } .friend-div { overflow: auto; height: 100px; width: 49%; display: inline-block !important; border-radius: 5px; background: none; -webkit-transition: all ease-out 0.3s; -moz-transition: all ease-out 0.3s; -o-transition: all ease-out 0.3s; transition: all ease-out 0.3s; } .dark .friend-div:hover { background: var(--code-bg); } .friend-div:hover { /* background: var(--theme); */ background: #e4e4e4; /* 我设置了随机背景色彩，后面有提到捏 */ transition: transform 1s; -webkit-transform: scale(1.1); -moz-transform: scale(1.2); -ms-transform: scale(1.2); -o-transform: scale(1.2); transform: scale(1.1); } .friend-div:hover .friend-div-left img { transition: 0.9s !important; -webkit-transition: 0.9s !important; -moz-transition: 0.9s !important; -o-transition: 0.9s !important; -ms-transition: 0.9s !important; transform: rotate(360deg) !important; -webkit-transform: rotate(360deg) !important; -moz-transform: rotate(360deg) !important; -o-transform: rotate(360deg) !important; -ms-transform: rotate(360deg) !important; } .friend-div-left { width: 92px; float: left; margin-right: -5px; } .friend-div-right { margin-top: 18px; margin-right: 18px; } .friend-name { text-overflow: ellipsis; font-size: 100%; margin-bottom: 5px; color: var(--primary); } .friend-info { text-overflow: ellipsis; font-size: 70%; color: var(--primary); } @media screen and (max-width: 600px) { .friend-info { display: none; } .friend-div-left { width: 84px; margin: auto; } .friend-div-right { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friend-name { font-size: 18px; } } 在.\\layouts\\shortcodes\\下新建一个friend.html填入以下内容： {{- if .IsNamedParams -}} ","date":"2023-11-30","objectID":"/posts/basic_setting/:0:4","series":null,"tags":["CSS","Hugo"],"title":"第壹话|基本样式","uri":"/posts/basic_setting/#实现随机背景色"},{"categories":["关于Hugo的一些设置"],"content":"这部分记录的是个人网站的初步构建以及成功渲染到个人github Page的过程 使用环境 开发环境：Windows 11 Hugo版本：Hugo v0.114.0 Git版本： 2.43.0.windows.1 Theme：PaperMod 时间：2023/11/29 ","date":"2023-11-29","objectID":"/posts/build_hugo/:0:0","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#"},{"categories":["关于Hugo的一些设置"],"content":" Github配合Git的基础使用这部分我在网上找到一篇非常细致的文章，贴在这里： 手把手教你用git上传项目到GitHub（图文并茂，这一篇就够了），相信你一定能成功！！ - 知乎 (zhihu.com) 这篇文章虽是2020年的，但是步骤细致，跟着走下来不会有什么问题，有几个注意点如下： 由于一些原因，GitHub创建仓库后的默认分支从原来的Master更名为Main，但是许多其他教程还是习惯上使用Master做默认分支，同时，Git的默认分支似乎并没有同时更新成为Main，所以我们在进行push/pull等命令的时候要注意当期的branch是否合适，这里介绍了如何在Git中增加/切换/删除/合并分支等操作 有一些Github界面有更新，与教程中不太一致，但是只是位置不太一样，找的时候按照图中的名字寻找就行。 ","date":"2023-11-29","objectID":"/posts/build_hugo/:1:0","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#github配合git的基础使用"},{"categories":["关于Hugo的一些设置"],"content":" Git常用操作命令记录 git的分支管理 git branch 返回当前操作在哪个分支下，同时也可以得到当前项目下的其他分支的信息，该信息在git bash界面窗口也可以在最右侧小括号中得到 git branch \u003cbranchname\u003e git checkout -b \u003cbranchname\u003e 创建分支 git checkout \u003caimbranchname\u003e 切换分支到aimbranch 提交代码 git add . git commit -m \"提交描述\" git push origin \u003c远程分支名\u003e # 使用git push -u origin \u003c远程分支名\u003e之后，以后每次上传只需要git push就够了(少写两个单词的意义) 远程分支名按照之前构建的关联填 ","date":"2023-11-29","objectID":"/posts/build_hugo/:1:1","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#git常用操作命令记录"},{"categories":["关于Hugo的一些设置"],"content":" Git常用操作命令记录 git的分支管理 git branch 返回当前操作在哪个分支下，同时也可以得到当前项目下的其他分支的信息，该信息在git bash界面窗口也可以在最右侧小括号中得到 git branch git checkout -b 创建分支 git checkout 切换分支到aimbranch 提交代码 git add . git commit -m \"提交描述\" git push origin \u003c远程分支名\u003e # 使用git push -u origin \u003c远程分支名\u003e之后，以后每次上传只需要git push就够了(少写两个单词的意义) 远程分支名按照之前构建的关联填 ","date":"2023-11-29","objectID":"/posts/build_hugo/:1:1","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#git的分支管理"},{"categories":["关于Hugo的一些设置"],"content":" Git常用操作命令记录 git的分支管理 git branch 返回当前操作在哪个分支下，同时也可以得到当前项目下的其他分支的信息，该信息在git bash界面窗口也可以在最右侧小括号中得到 git branch git checkout -b 创建分支 git checkout 切换分支到aimbranch 提交代码 git add . git commit -m \"提交描述\" git push origin \u003c远程分支名\u003e # 使用git push -u origin \u003c远程分支名\u003e之后，以后每次上传只需要git push就够了(少写两个单词的意义) 远程分支名按照之前构建的关联填 ","date":"2023-11-29","objectID":"/posts/build_hugo/:1:1","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#提交代码"},{"categories":["关于Hugo的一些设置"],"content":" 选择静态博客框架hugoHugo的特点： Hugo 是一个基于Go 语言的框架，可但中文文档和博客少，而且旧模板和新Hugo的兼容性也不好，它可以快速方便的创建自己的博客。 Hugo 支持Markdown 语法，我们可以将自己的文章写成Markdown 的格式，放在我们用Hugo 创建的博客系统中，从而展示给他人。 ==HUGO中文文档== https://www.gohugo.org/doc/commands/hugo/ ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:0","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#选择静态博客框架hugo"},{"categories":["关于Hugo的一些设置"],"content":" Hugo安装在Windows中安装： 1.首先安装choco包管理，需要在==管理员权限==下运行cmd，执行如下命令： # step 1: powershell -NoProfile -ExecutionPolicy unrestricted -Command \"iex ((new-object net.webclient).DownloadString('https://chocolatey.org/install.ps1'))\" # step 2: # 设置环境变量 SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 2.choco安装成功之后，我们就可以使用choco安装hugo： # 非科学上网可能安装比较慢，但是也不是不行 choco install hugo -confirm 3.检查是否安装成功： hugo version # 如果可以显示版本号等信息，则为安装成功 4.MacOs和Linux中安装 # MacOs brew install hugo # Linux snap install hugo # 如果是Ubuntu版本，也可以使用apt安装，不过apt中的hugo可能不是最新版本，会限制一些主题，这种情况下也可以到hugo的github仓库中用如下命令安装： dpkg -i \u003cpackage.deb\u003e ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:1","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#hugo安装"},{"categories":["关于Hugo的一些设置"],"content":" 创建站点在想要设置站点的路径下，在命令行输入： hugo new site blogsitename 就可以创建一个名为blogsitename的站点 目录结构： $ tree /f F:. │ .hugo_build.lock │ hugo.toml # 博客站点的配置文件 │ ├───archetypes │ default.md ├───assets ├───content # 博客文章所在目录 ├───data ├───i18n ├───layouts # 网站布局 ├───resources ├───static # 静态内容存放 └───themes # 博客的主题 ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:2","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#创建站点"},{"categories":["关于Hugo的一些设置"],"content":" 新建页面和文章新建页面： hugo new about.md 该文件会出现在./content/about.md 创建文章： hugo new posts/myfirst.md 改文件会出现在./content/posts/myfirst.md 放在posts是为了方便聚合页面 这两个md文件中，要把draft一行去掉或者写成draft = false，draft的意思是草稿，在生成时不会出现。 三行线之间的内容会被hugo 解析，作为当前文章的一些属性。 更多关于文章的初始设置如下： --- title: \"文章标题\" # 文章标题 author: \"作者\" # 文章作者 description : \"描述信息\" # 文章描述信息 date: 2015-09-28 # 文章编写日期 lastmod: 2015-04-06 # 文章修改日期 draft: false showtoc = false # 单独设置本篇博客是否显示目录 tags = [ # 文章所属标签 \"文章标签1\", \"文章标签2\" ] categories = [ # 文章所属标签 \"文章分类1\", \"文章分类2\", ] keywords = [ # 文章关键词 \"Hugo\", \"static\", \"generator\", ] next: /tutorials/github-pages-blog # 下一篇博客地址 prev: /tutorials/automated-deployments # 上一篇博客地址 --- 这里是Markdown 正文 有的可能和我一样是这样的结构：title = \"Myfirst\" ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:3","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#新建页面和文章"},{"categories":["关于Hugo的一些设置"],"content":" 下载主题hugo特意没有给我们预设主题，所以我们去官网挑选一个主题吧 https://themes.gohugo.io/ 把终端的路径调整到博客文件夹的themes目录下，比如我选择的主题是PaperMod，我们在命令行输入如下： git clone https://github.com/adityatelange/hugo-PaperMod.git 然后在themes文件夹下会出现如下文件目录： └───hugo-PaperMod ├───.github │ ├───ISSUE_TEMPLATE │ └───workflows ├───assets │ ├───css │ │ ├───common │ │ ├───core │ │ ├───extended │ │ ├───hljs │ │ └───includes │ └───js ├───i18n ├───images └───layouts ├───partials │ └───templates ├───shortcodes └───_default └───_markup 使用主题的方法： 先转到根目录下，再使用命令： cd .. hugo -t \u003cthemename\u003e themename要和themes文件夹下的目标主题名字一致（如果是从git上下载再移动到themes目录下，可能会带有-master这样的后缀，因为一些奇怪的原因可能会对什么地方有影响，假如出现了这种情况把名字后的-master去掉就行） 之后在hugo.toml中修改： # hugo.toml theme = \"hugo-PaperMod\" # 主题名字 ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:4","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#下载主题"},{"categories":["关于Hugo的一些设置"],"content":" 预览主题在根目录下使用命令： hugo server 此时生成的是静态文件，生成很快（这就是GO！），只要server不关就会一直监控文件变化，自动生成静态文件~~（不过要是由于编辑内容时因为自己过于抽象的代码行为而导致无法排错，重新开一次就行，不必管他~~ 按照命令的反馈结果打开http://localhost:1313/就能看到本地预览啦 ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:5","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#预览主题"},{"categories":["关于Hugo的一些设置"],"content":" 一些小工具好用的yaml转toml工具 https://tooltt.com/yaml2toml/ ","date":"2023-11-29","objectID":"/posts/build_hugo/:2:6","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#一些小工具"},{"categories":["关于Hugo的一些设置"],"content":" 本地Hugo项目部署到Github Page","date":"2023-11-29","objectID":"/posts/build_hugo/:3:0","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#本地hugo项目部署到github-page"},{"categories":["关于Hugo的一些设置"],"content":" 启动博客前面预览主题的时候已经尝试过hugo了，这里（稍微）正式一点的提一下它吧。 在终端命令行直接输入下方内容就能在本地预览了，本地预览地址是：localhost:1313 hugo server -D 输入hugo可以生成public文件夹，这个文件夹可以部署到云服务器或者托管到github上。 注意：输入hugo的生成方式只会往public文件夹里添加内容，但是不会删除外部已经不存在而public里面还存在的文件，所以一般还可以用下方第二条命令，这个命令可以保证每次生成的public都是全新的，会覆盖原来的。 hugo hugo -F --cleanDestinationDir ","date":"2023-11-29","objectID":"/posts/build_hugo/:3:1","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#启动博客"},{"categories":["关于Hugo的一些设置"],"content":" 新建仓库 在github上创建一个与 username 同名的空仓库，命名格式必须是：username.github.io ，不包含任何内容（readme.md也不要） 在Hugo项目的public目录下（hugo后生成）中依次执行以下命令： git init # 初始化仓库 git remote add origin https://github.com/自己的/自己的.github.io.git git add . git commit -m \"first commit\" git push -u origin main 之后的更新： git add . git status git commit -m \"new post xxx\" git push ","date":"2023-11-29","objectID":"/posts/build_hugo/:3:2","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#新建仓库"},{"categories":["关于Hugo的一些设置"],"content":" 使用GitHub Action自动发布文章使用 main 分支发布文章，使用一个新的 source 分支进行写作，写作完成后上传 source ，GitHub Action 自动将 source 分支的 publish 文件夹拷贝到 main 分支，从而完成文章的发布。 这部分后补吧（嗯我想想… 参考：使用 Hugo 搭建个人网站（博客、个人主页）并发布到 Github 上 - 知乎 (zhihu.com) ","date":"2023-11-29","objectID":"/posts/build_hugo/:3:3","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#使用github-action自动发布文章"},{"categories":["关于Hugo的一些设置"],"content":" 印象深刻的bug无法显示样式QAQ 控制台报错信息： Failed to find a valid digest in the 'integrity' attribute for resource 'xxxxxx.css' ,The resource has been blocked. 首先这一看就是链接路径报错，但是我寻思我也没改什么路径哇，只增减不查改的，所以这个可能是PaperMod当前版本中的一个问题，废话不多说，我们定位到这个bug： 路径：.\\themes\\hugo-PaperMod\\layouts\\partials\\header.html 这个位置： 然后把integrity=\"{{ $stylesheet.Data.Integrity }}\"改为integrity=\"\"。 同时也可以在hugo.toml中加这一句： [params] env = \"production\" description = \"Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod\" ... disableFingerprinting = true #### 这一句 ... 报错消失，本地运行正常，挂载部署到github Page也是正常显示样式了。 参考：解决 hugo 中关于 integrity 的错误 | Choi’s Notes (smc.im) ","date":"2023-11-29","objectID":"/posts/build_hugo/:3:4","series":null,"tags":["TOML","Hugo"],"title":"第零话|Hugo建站","uri":"/posts/build_hugo/#印象深刻的bug"},{"categories":[],"content":" 你好哇，很高兴认识你，这里是 DODOLA’s WareHouse 现在更名为Doごみ箱。 🎐站长信息： 昵称：哆哆啦(DODOLA) 刷新地点：杭州/长春 职业：学生，NENU2022级本科在读 爱好：阅读/电影/音乐/音乐剧/Coding/小提琴/旅游/逛展/单机游戏/麻将/云二次元 废话：一个标准的特立独行INTJer，不变的终身学习者，兴趣广泛，好奇泛滥，涉猎多开坑多但是会慢慢填坑的qwq，喜欢深究根本，努力不咕咕，目前就读于东北师范大学的计科(中外合作)专业，先贤有言：“教学相长也”，在写上传到本站的笔记时会注意书写逻辑，欢迎各位佬的批评指正🙇‍♀️🙇‍♀️。 最近重看之前的博客，感觉博客的废话含量还是挺多的。。 联系方式：163.com or gmail 🪁本站信息： 建站日期：2023/11/28 建站理念：简洁有用，文风可爱，不定期更新 本站简介：本站会用来保存站长的电子笔记，涉及书评/影评/复习笔记/算法学习/前端学习/日记分享…etc，或许就是个杂七杂八的电子小仓库，欢迎您的访问！非常欢迎友链互链，相互交流！很高兴认识你~ 框架： 博客框架：Hugo v0.114.0 主题：PaperMod 2024/07 更换为DoIt 源码仓库：GitHub 线路信息 初始域名：florae006.github.io 主域名：dodolalorc.cn ","date":"2023-11-28","objectID":"/about/:0:0","series":[],"tags":["关于"],"title":"🍅关于","uri":"/about/#你好哇"}]