[{"categories":null,"content":" A 智乃的博弈游戏","date":"2025-02-16","objectID":"/posts/nc25wd3/:1:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#a-智乃的博弈游戏"},{"categories":null,"content":" 题意有一堆$n$个石子，每次可以拿走$x$个石子，要求$x$是一个不大于$n$且与$n$互质的数，当面对$1$时选手获胜，询问智乃（先手玩家）能否获胜。 数据范围 $1\\leq n\\leq 1e18$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:1:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意"},{"categories":null,"content":" 题意有一堆$n$个石子，每次可以拿走$x$个石子，要求$x$是一个不大于$n$且与$n$互质的数，当面对$1$时选手获胜，询问智乃（先手玩家）能否获胜。 数据范围 $1\\leq n\\leq 1e18$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:1:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围"},{"categories":null,"content":" 思路必胜点是剩余 1，则 2 是必败点，两个选手都不希望对手面对 1，都希望对手面对 2。 如果当前剩余$n$是奇数，则选手一定可以操作将剩余数量变成偶数（只拿一个）。面对偶数的选手，能选的互质的数一定是一个奇数，偶数减去奇数会变成奇数，下一轮回到奇数的情况，如果某一方保持偶数，一定会到剩余$2$的情况，也就是必败点。 于是本题博弈和初始状态的奇偶性相关。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:1:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路"},{"categories":null,"content":" 代码 n = int(input()) if n \u0026 1: print(\"Yes\") else: print(\"No\") ","date":"2025-02-16","objectID":"/posts/nc25wd3/:1:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码"},{"categories":null,"content":" B 智乃的质数手串","date":"2025-02-16","objectID":"/posts/nc25wd3/:2:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#b-智乃的质数手串"},{"categories":null,"content":" 题意有一个环形的手串，第一个小球的编号是$0$，上面有一个数字$a_0$…第$n$个小球的编号是$n-1$，上面有一个数字$a_{n-1}$。 遵循以下规则： 手串上只有一个小球，则可以直接取下。 若当前小球上的数字和其顺时针相邻的下一个小球的数字相加的和是一个质数，则可以拿下当前的小球。 给出手串的结构，请问是否可以将小球全部取下来，取下来的合法序号顺序是什么？ 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e5$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:2:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-1"},{"categories":null,"content":" 题意有一个环形的手串，第一个小球的编号是$0$，上面有一个数字$a_0$…第$n$个小球的编号是$n-1$，上面有一个数字$a_{n-1}$。 遵循以下规则： 手串上只有一个小球，则可以直接取下。 若当前小球上的数字和其顺时针相邻的下一个小球的数字相加的和是一个质数，则可以拿下当前的小球。 给出手串的结构，请问是否可以将小球全部取下来，取下来的合法序号顺序是什么？ 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e5$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:2:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-1"},{"categories":null,"content":" 思路当手串是链状的时候，若要将第一个取下来，则需要将序号大于 1 的第一个小球前的所有小球取下来，或者第二个小球前的所有小球取下来…很明显这是一个栈的结构，当将要入栈的小球可以和栈顶的数构成质数，则进行pop操作，知道栈为空或不能构成质数，才停止操作，将小球入栈。 而在环状手串上，需要维护一个长度为$n$的区间，在这个区间上测试是否存在栈的大小只剩 1 的情况，当栈底的小球的序号与栈顶的序号超过$n$的区间长度，需要将栈底的pop，这个数据结构需要支持两端的pop操作，应当使用deque模拟操作。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:2:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-1"},{"categories":null,"content":" 代码 #include \u003cbits/stdc++.h\u003e using namespace std; typedef double ld; typedef unsigned long ul; typedef long long ll; typedef unsigned long long ull; typedef pair\u003cll, ll\u003e pll; const ll maxn = 2e6 + 50; ll lowbit(ll x) { return x \u0026 -x; } ll a[maxn], b[maxn], c[maxn], d[maxn]; ll pre[maxn], suf[maxn]; ll diff[maxn]; bool vis[maxn]; vector\u003cll\u003e primes; bool isprime[maxn]; void init_prime() { ll w = maxn - 1; for (ll i = 0; i \u003c= w; i++) { isprime[i] = true; } isprime[0] = isprime[1] = false; for (ll i = 2; i \u003c= w; i++) { if (!isprime[i]) continue; for (ll j = 2 * i; j \u003c= w; j += i) { isprime[j] = false; } } } vector\u003cvector\u003cll\u003e\u003e factors; void init_factor() { ll w = maxn - 1; factors.assign(w + 1, vector\u003cll\u003e()); for (ll i = 1; i \u003c= w; i++) { for (ll j = i; j \u003c= w; j += i) { factors[j].push_back(i); } } } void solve() { ll n; cin \u003e\u003e n; for (ll i = 0; i \u003c n; i++) { cin \u003e\u003e a[i]; a[i + n] = a[i]; } deque\u003cpll\u003e q; ll pos = -1; for (ll i = 0; i \u003c 2 * n; i++) { while (!q.empty() \u0026\u0026 isprime[a[i] + q.back().first]) { q.pop_back(); } while (!q.empty() \u0026\u0026 i - q.front().second + 1 \u003e n) { q.pop_front(); } q.push_back({a[i], i}); if (q.size() == 1 \u0026\u0026 i \u003e= n) { pos = i % n; // 最后一个入栈的数 break; } } if (pos == -1) { cout \u003c\u003c \"No\\n\"; return; } cout \u003c\u003c \"Yes\\n\"; q.clear(); for (ll i = pos + 1; i \u003c= pos + n; i++) { while (!q.empty() \u0026\u0026 isprime[a[i] + q.back().first]) { cout \u003c\u003c q.back().second \u003c\u003c ' '; q.pop_back(); } q.push_back({a[i], i % n}); } cout \u003c\u003c q.back().second \u003c\u003c '\\n'; } void init() { init_prime(); } int main(void) { ios::sync_with_stdio(false); cin.tie(0); ll _t = 1; init(); while (_t--) { solve(); } return 0; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:2:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-1"},{"categories":null,"content":" C 智乃的 Notepad(Easy version)","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#c-智乃的-notepadeasy-version"},{"categories":null,"content":" 题意有$n$个字符串，需要将它们都单独呈现在显示屏上，只能使用$26$个字母和退格键(\\b可以删去一个字符)，提问至少需要敲几下键盘？ 数据范围 $1\\leq n\\leq 1e5$ $m=1$ $\\sum|s_i|\\leq 1e6$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-2"},{"categories":null,"content":" 题意有$n$个字符串，需要将它们都单独呈现在显示屏上，只能使用$26$个字母和退格键(\\b可以删去一个字符)，提问至少需要敲几下键盘？ 数据范围 $1\\leq n\\leq 1e5$ $m=1$ $\\sum|s_i|\\leq 1e6$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-2"},{"categories":null,"content":" 思路当两个单词前缀相同时，对比分别打印两个单词，可以减少一个公共前缀的长度的次数，最后可以把最长的单词留在屏幕上。 若建立字典树，答案就是字典树上边的数量的两倍减去最长单词的长度。 也可以根据字典序排序，也可以把前缀相同的放在相邻的位置。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-2"},{"categories":null,"content":" 代码：字典序排序 void solve() { ll n, m; cin \u003e\u003e n \u003e\u003e m; ll mx = 0; vector\u003cstring\u003e v; for (ll i = 1; i \u003c= n; i++) { string s; cin \u003e\u003e s; v.push_back(s); mx = max((ll)s.size(), mx); } sort(v.begin(), v.end()); while (m--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; ll ans = v[0].size() * 2; for (ll i = 1; i \u003c n; i++) { ll j = 0; ans += v[i].size() * 2; while (j \u003c (ll)v[i - 1].size() \u0026\u0026 j \u003c (ll)v[i].size() \u0026\u0026 v[i - 1][j] == v[i][j]) { j++; } ans -= j * 2; } cout \u003c\u003c ans - mx \u003c\u003c '\\n'; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码字典序排序"},{"categories":null,"content":" 代码：字典树 ll tot = 0; ll tree[maxn][26]; bool exist[maxn]; void insert(string s, ll n) { ll p = 0; for (ll i = 0; i \u003c n; i++) { ll c = s[i] - 'a'; if (!tree[p][c]) { tree[p][c] = ++tot; } p = tree[p][c]; } exist[p] = true; } void solve() { ll n, m; cin \u003e\u003e n \u003e\u003e m; ll mx = 0; for (ll i = 1; i \u003c= n; i++) { string s; cin \u003e\u003e s; insert(s, s.size()); mx = max((ll)s.size(), mx); } while (m--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; ll ans = tot * 2 - mx; cout \u003c\u003c ans \u003c\u003c '\\n'; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:3:4","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码字典树"},{"categories":null,"content":" D 智乃的 Notepad(Hard version)","date":"2025-02-16","objectID":"/posts/nc25wd3/:4:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#d-智乃的-notepadhard-version"},{"categories":null,"content":" 题意情景同 C 题，在此版本，需要支持$m$次查询，得到完成打印区间$[l,r]$内的单词需要的最少操作次数。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq m\\leq qe5$ $\\sum|s_i|\\leq 1e6$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:4:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-3"},{"categories":null,"content":" 题意情景同 C 题，在此版本，需要支持$m$次查询，得到完成打印区间$[l,r]$内的单词需要的最少操作次数。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq m\\leq qe5$ $\\sum|s_i|\\leq 1e6$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:4:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-3"},{"categories":null,"content":" 思路离线处理查询的区间，范围$[l,r]$内的操作数是以$[l,r]$内的单词建立的字典树的边数 ×2-最长单词长度，考虑字典树的建树过程，每个单词会覆盖前若干个单词的部分前缀，在覆盖的过程中，前面的单词的贡献的点数部分转移到当前的单词上，将字符串的序号看作不同的颜色，在着色的过程中，更新各个颜色对应的贡献，在加入新的单词$i$时，可以计算所有以$i$为右端点的查询区间的答案。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:4:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-3"},{"categories":null,"content":" 代码 ll lowbit(ll x) { return (x) \u0026 (-x); } ll n, m; ll a[maxn], b[maxn], c[maxn]; ll bitree[maxn]; // BIT树 void update(ll p, ll x) { // 单点修改a[p]+=x while (p \u0026\u0026 p \u003c= n) { bitree[p] += x; p += lowbit(p); } } ll query(ll n) { ll ans = 0, p = n; while (p) { ans += bitree[p]; p -= lowbit(p); } return ans; } ll query(ll l, ll r) { return query(r) - query(l - 1); } ll tot = 0; ll tree[maxn][26], clr[maxn]; void insert(string s, ll t) { ll n = s.size(); s = \" \" + s; ll p = 0; for (ll i = 1; i \u003c= n; i++) { ll c = s[i] - 'a'; if (!tree[p][c]) { tree[p][c] = ++tot; } p = tree[p][c]; if (clr[p]) { update(clr[p], -1); } clr[p] = t; // 当前颜色 update(clr[p], 1); } } // ST表 ll dp[maxn][50]; // 0/1:最小值/最大值 void rmq_st(ll n, vector\u003cll\u003e \u0026v) { for (ll i = 1; i \u003c= n; i++) { dp[i][0] = v[i]; // 2^0 } ll m = log(1 * n) / log(2.0); for (ll j = 1; j \u003c= m; j++) { ll t = n - (1 \u003c\u003c j) + 1; for (ll i = 1; i \u003c= t; i++) { dp[i][j] = max(dp[i][j - 1], dp[i + (1 \u003c\u003c (j - 1))][j - 1]); } } } ll rmq_query(ll l, ll r) { // 从l开始,长度为r的区间最大值 ll k = log(1.0 * (r - l + 1)) / log(2.0); ll mx = max(dp[l][k], dp[r - (1 \u003c\u003c k) + 1][k]); return mx; } void solve() { cin \u003e\u003e n \u003e\u003e m; vector\u003cstring\u003e s(n + 1); vector\u003cll\u003e sz(n + 1); for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e s[i]; sz[i] = s[i].size(); } rmq_st(n, sz); vector\u003carray\u003cll, 3\u003e\u003e v; for (ll i = 1; i \u003c= m; i++) { ll l, r; cin \u003e\u003e l \u003e\u003e r; v.push_back({r, l, i}); } sort(v.begin(), v.end()); ll cr = 0; for (auto [r, l, i] : v) { while (cr \u003c r) { cr++; insert(s[cr], cr); } a[i] = 2 * query(l, r) - rmq_query(l, r); } for (ll i = 1; i \u003c= m; i++) { cout \u003c\u003c a[i] \u003c\u003c '\\n'; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:4:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-2"},{"categories":null,"content":" E 智乃的小球","date":"2025-02-16","objectID":"/posts/nc25wd3/:5:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#e-智乃的小球"},{"categories":null,"content":" 题意在水平线上有$n$个小球，每个小球有一个初始速度，记向右为正，小球的初始速度要么为$1m/s$，要么为$-1m/s$，其质量都相同，坐标为$p_i$。询问在足够长的时间内，能否发生$k$次碰撞，以及第$k$次碰撞发生的时间。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq k\\leq 1e9$ $0\\leq p_i\\leq 1e9,v_i\\in {-1,1}$ 保证一开始所有的小球位置不同。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:5:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-4"},{"categories":null,"content":" 题意在水平线上有$n$个小球，每个小球有一个初始速度，记向右为正，小球的初始速度要么为$1m/s$，要么为$-1m/s$，其质量都相同，坐标为$p_i$。询问在足够长的时间内，能否发生$k$次碰撞，以及第$k$次碰撞发生的时间。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq k\\leq 1e9$ $0\\leq p_i\\leq 1e9,v_i\\in {-1,1}$ 保证一开始所有的小球位置不同。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:5:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-4"},{"categories":null,"content":" 思路根据高中物理常识，易得，当两个质量相同的小球相向碰撞，会交换彼此的速度。由于本题中所有小球的速度都是$1m/s$或$-1m/s$，可以把交换速度看作两个小球互相穿过对方，依然按照原来的速度向前运动。 也就是说，本题询问若干向右的小球和向左的小球能相遇多少次，这个值可以枚举某个方向的小球的初始位置，再在另一个方向的小球中二分查找当前的小球会遇到多少相向的小球，再对时间进行二分。 第$k$次碰撞的时刻的值大概率是浮点数，在二分时间的时候注意精度不要太小，容易超时。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:5:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-4"},{"categories":null,"content":" 代码 void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cld\u003e v1, v2; for (ll i = 1; i \u003c= n; i++) { ll p, v; cin \u003e\u003e p \u003e\u003e v; if (v == 1) v1.push_back(p); else v2.push_back(p); } sort(v1.begin(), v1.end()), sort(v2.begin(), v2.end()); // k可行性 ll mk = 0; for (ll pi : v1) { mk += v2.end() - upper_bound(v2.begin(), v2.end(), pi); } if (k \u003e mk) { cout \u003c\u003c \"No\\n\"; return; } auto check = [\u0026](ld t) { // 这段时间内的碰撞次数 ll tot = 0; t /= 1e7; for (ll pi : v1) { ll t1 = v2.end() - lower_bound(v2.begin(), v2.end(), pi); ll t2 = v2.end() - lower_bound(v2.begin(), v2.end(), pi + 2 * t); ll ti = t1 - t2; tot += ti; } return tot; }; ll l = 0, r = 1e16; while (l + 1 \u003c r) { // [l,r] ll mid = (l + r) / 2; if (check(mid) \u003e= k) { r = mid; } else { l = mid; } } cout \u003c\u003c \"Yes\\n\"; cout \u003c\u003c fixed \u003c\u003c setprecision(9) \u003c\u003c 1.0 * l / 1e7 \u003c\u003c '\\n'; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:5:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-3"},{"categories":null,"content":" F 智乃的捉迷藏","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#f-智乃的捉迷藏"},{"categories":null,"content":" 题意在三角形的三个角和三条边着 6 个位置分别设计放多少人，人数总和是$n$，让 A、B、C 三个人分别能看到 a、b、c 数量的人。 数据范围 $1\\leq n\\leq 20$ $1\\leq a,b,c\\leq n$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-5"},{"categories":null,"content":" 题意在三角形的三个角和三条边着 6 个位置分别设计放多少人，人数总和是$n$，让 A、B、C 三个人分别能看到 a、b、c 数量的人。 数据范围 $1\\leq n\\leq 20$ $1\\leq a,b,c\\leq n$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-5"},{"categories":null,"content":" 思路赛时是直接冲了 6 重循环，暴力 for 遍历枚举 6 个位置的数量可以通过此题（注意边界）。 也可以仅枚举 3 个顶点的位置，计算三边位置的值，判断成立条件。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-5"},{"categories":null,"content":" 代码：枚举 6 位 void solve() { ll n, a, b, c; cin \u003e\u003e n \u003e\u003e a \u003e\u003e b \u003e\u003e c; bool flag = false; for (ll i = 0; i \u003c= n; i++) { for (ll j = 0; j + i \u003c= n; j++) { for (ll k = 0; k + j + i \u003c= n; k++) { for (ll x = 0; x + k + j + i \u003c= n; x++) { for (ll y = 0; y + x + k + j + i \u003c= n; y++) { ll z = n - (y + x + k + j + i); if (x + y + z == a \u0026\u0026 z + i + j == b \u0026\u0026 x + k + j == c) { flag = true; break; } } if (flag) break; } if (flag) break; } if (flag) break; } if (flag) break; } if (flag) { cout \u003c\u003c \"Yes\\n\"; } else { cout \u003c\u003c \"No\\n\"; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码枚举-6-位"},{"categories":null,"content":" 代码：枚举 3 位 void solve() { ll n, a, b, c; cin \u003e\u003e n \u003e\u003e a \u003e\u003e b \u003e\u003e c; for (ll i = 0; i \u003c= n; i++) { for (ll j = 0; i + j \u003c= n; j++) { for (ll k = 0; i + j + k \u003c= n; k++) { // 枚举1 3 5号位置 ll x = a - i - j, y = b - j - k, z = c - i - k; if (x \u003e= 0 \u0026\u0026 y \u003e= 0 \u0026\u0026 z \u003e= 0 \u0026\u0026 (i + j + k + x + y + z == n)) { cout \u003c\u003c \"Yes\\n\"; return; } } } } cout \u003c\u003c \"No\\n\"; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:6:4","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码枚举-3-位"},{"categories":null,"content":" G 智乃与模数","date":"2025-02-16","objectID":"/posts/nc25wd3/:7:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#g-智乃与模数"},{"categories":null,"content":" 题意对一个正整数$n$，选择所有$1\\leq i\\leq n$的$i$作为模数，记录余数序列，再将余数序列降序排列，求前$k$大的数之和。 数据范围 $1\\leq k\\leq n\\leq 1e9$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:7:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-6"},{"categories":null,"content":" 题意对一个正整数$n$，选择所有$1\\leq i\\leq n$的$i$作为模数，记录余数序列，再将余数序列降序排列，求前$k$大的数之和。 数据范围 $1\\leq k\\leq n\\leq 1e9$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:7:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-6"},{"categories":null,"content":" 思路分块，枚举商，在商比较小的时候，商是连续有值的，当商比较大的时候，可能会出现商和商之间不再连续，如$n=5$时，商为$1$的有${5,4,3}$，商为$2$的有${2}$，商为$3,4$的集合都是空的，商为$5$的集合是${1}$，对每个商相同的集合，可以发现其余数符合等差数列的规律，公差是商的值。商不连续的情况的数值范围比较小，可以通过打表记录这部分的余数。 二分找出第$k$大的余数的值，再在每个按商分块的集合中，利用等差数列公式，计算余数大于等于$k$的余数之和，再减去多算的数量（这部分多算的数都是余数数值为$k$的数）。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:7:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-6"},{"categories":null,"content":" 代码 void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cpll\u003e v; vector\u003cll\u003e w; for (ll i = 1; i \u003c= n; i++) { if (n / (n / i) == i) { ll l = n / (i + 1) + 1, r = n / i; v.push_back({l, r}); } else { v.push_back({1, n / i}); for (ll j = 1; j \u003c= n / i; j++) { // 打表商不连续的部分 w.push_back(n % j); } break; } } sort(w.begin(), w.end()); ll ans = 0ll, cnt = 0ll; auto check = [\u0026](ll x) { // 统计有多少大于等于k的 ll ret = 0ll; ans = 0ll; for (auto \u0026[l, r] : v) { ll s = n / r, t = (r - l + 1); if (n / l != s) { for (auto p = lower_bound(w.begin(), w.end(), x); p != w.end(); p++) { ret++; ans += *p; } break; } ll at = n % l, a1 = n % r, d = s; if (x \u003c= a1) { ll j = t; ret += j, ans += (at + a1) * j / 2; continue; } ll ti = (x - a1) / d + 2 - ((x - a1) % d == 0); ll j = max(0ll, t - ti + 1); ret += j, ans += (at + a1 + (t - j) * d) * j / 2; } cnt = ret; return ret; }; ll l = 0, r = n; while (l + 1 \u003c r) { ll mid = (l + r) / 2; if (check(mid) \u003e= k) { l = mid; } else { r = mid; } } ans -= (cnt - k) * l; cout \u003c\u003c ans \u003c\u003c '\\n'; } 类似题：因数个数和 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:7:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-4"},{"categories":null,"content":" H 智乃与黑白树","date":"2025-02-16","objectID":"/posts/nc25wd3/:8:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#h-智乃与黑白树"},{"categories":null,"content":" 题意一棵节点数为$n$的黑白树，每个节点为黑色或白色，定义一棵黑白树的权值是树中所有黑色节点到白色节点的简单路径长度之和，路径长度是路径中经过边的数量。 询问如果切掉第$i$条边，产生的两棵子树的权值分别是多少？ 数据范围 $2\\leq n\\leq 1e5$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:8:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-7"},{"categories":null,"content":" 题意一棵节点数为$n$的黑白树，每个节点为黑色或白色，定义一棵黑白树的权值是树中所有黑色节点到白色节点的简单路径长度之和，路径长度是路径中经过边的数量。 询问如果切掉第$i$条边，产生的两棵子树的权值分别是多少？ 数据范围 $2\\leq n\\leq 1e5$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:8:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-7"},{"categories":null,"content":" 思路换根更新以$i$为根的子树的权值。 flowchart TB c1((p))-.连接.-\u003ea1((v)) subgraph 子树v a1--\u003ea2((s1)) a1--\u003ea3((s2)) end subgraph 当前的树p c1--\u003ec2((s1)) c1--\u003ec3((s2)) end 如图，当前的操作是将子树$v$的信息更新到以$p$为根的树上，记以$i$为根的子树的黑/白色节点数是$num[i][0/1]$，子树$i$中的黑/白色节点到根$i$的距离之和是$g[i][0/1]$，$f[i]$为子树$i$的权值，那么在 dfs 递归更新的时候，转移是： void pushup(ll rt, ll p) { // 更新以rt为根，p为子节点的信息 f[rt] += f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] + (num[p][0] + g[p][0]) * num[rt][1] + (num[p][1] + g[p][1]) * num[rt][0]; g[rt][0] += num[p][0] + g[p][0], g[rt][1] += num[p][1] + g[p][1]; num[rt][0] += num[p][0], num[rt][1] += num[p][1]; } 而删边的时候转移是反过来： void cutlink(ll rt, ll p) { // 切断rt为父节点的子树p g[rt][0] -= num[p][0] + g[p][0], g[rt][1] -= num[p][1] + g[p][1]; num[rt][0] -= num[p][0], num[rt][1] -= num[p][1]; f[rt] -= f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] + (num[p][0] + g[p][0]) * num[rt][1] + (num[p][1] + g[p][1]) * num[rt][0]; } 在切边的时候，按顺序换根，更新权值。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:8:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-7"},{"categories":null,"content":" 代码 ll f[maxn], g[maxn][2], num[maxn][2], clr[maxn]; ll fa[maxn]; vector\u003cvector\u003cll\u003e\u003e tree; void add_edge(ll u, ll v) { tree[u].push_back(v); tree[v].push_back(u); } void pushup(ll rt, ll p) { // 更新以rt为根，p为子节点的信息 f[rt] += f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] + (num[p][0] + g[p][0]) * num[rt][1] + (num[p][1] + g[p][1]) * num[rt][0]; g[rt][0] += num[p][0] + g[p][0], g[rt][1] += num[p][1] + g[p][1]; num[rt][0] += num[p][0], num[rt][1] += num[p][1]; } void cutlink(ll rt, ll p) { // 切断rt为父节点的子树p g[rt][0] -= num[p][0] + g[p][0], g[rt][1] -= num[p][1] + g[p][1]; num[rt][0] -= num[p][0], num[rt][1] -= num[p][1]; f[rt] -= f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] + (num[p][0] + g[p][0]) * num[rt][1] + (num[p][1] + g[p][1]) * num[rt][0]; } void dfs(ll p, ll fr) { fa[p] = fr; num[p][clr[p]]++; for (auto v : tree[p]) { if (v == fr) continue; dfs(v, p); pushup(p, v); } } void solve() { ll n; string s; cin \u003e\u003e n \u003e\u003e s; s = \" \" + s; for (ll i = 1; i \u003c= n; i++) { clr[i] = s[i] == 'w'; } tree.assign(n + 1, vector\u003cll\u003e()); vector\u003cpll\u003e ve; for (ll i = 1; i \u003c= n - 1; i++) { ll u, v; cin \u003e\u003e u \u003e\u003e v; add_edge(u, v); ve.push_back({u, v}); } ll cur = 1; // 当前根节点 dfs(cur, -1); for (auto [u, v] : ve) { ll p; if (fa[v] == u) p = v; else p = u; vector\u003cpll\u003e w; while (p != cur) { w.push_back({fa[p], p}); // 要切除的边 p = fa[p]; } reverse(w.begin(), w.end()); for (ll k = 0; k \u003c (ll)w.size(); k++) { auto [i, j] = w[k]; // 将i\u003c-j变成j-\u003ei cutlink(i, j); if (k == (ll)w.size() - 1) cout \u003c\u003c f[u] \u003c\u003c ' ' \u003c\u003c f[v] \u003c\u003c '\\n'; pushup(j, i); fa[i] = j; cur = j; } } } 类似提：树学 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:8:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-5"},{"categories":null,"content":" I 智乃的兔子跳","date":"2025-02-16","objectID":"/posts/nc25wd3/:9:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#i-智乃的兔子跳"},{"categories":null,"content":" 题意在坐标${x_1,x_2,\\dots ,x_n}$上各有一个胡萝卜，这$n$个胡萝卜的坐标各不重合，兔子要选择一个起始坐标$p$和一个跳跃步长$k$，以获得最多的胡萝卜个数。求出获得最多胡萝卜的$p$和$k$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq x_i\\leq 1e9$ $0\\leq p\\leq 1e9$ $2\\leq k\\leq 1e9$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:9:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-8"},{"categories":null,"content":" 题意在坐标${x_1,x_2,\\dots ,x_n}$上各有一个胡萝卜，这$n$个胡萝卜的坐标各不重合，兔子要选择一个起始坐标$p$和一个跳跃步长$k$，以获得最多的胡萝卜个数。求出获得最多胡萝卜的$p$和$k$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq x_i\\leq 1e9$ $0\\leq p\\leq 1e9$ $2\\leq k\\leq 1e9$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:9:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-8"},{"categories":null,"content":" 思路随机化算法，如果每个坐标上都有胡萝卜，设计步长为 2，可以获得$\\max (奇数个数,偶数个数)$个胡萝卜，任选两个胡萝卜，在最佳方案中的概率会大于$\\frac{1}{2}\\times \\frac{1}{2}$，随机选择两个胡萝卜，枚举其距离的质因数，更新最优的方案，随机的次数不超过可行的时间复杂度即可。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:9:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-8"},{"categories":null,"content":" 代码 void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } if (n == 1) { cout \u003c\u003c a[1] \u003c\u003c \" 2\\n\"; return; } ll ans = 0, pi = a[1], ki = 2; auto update = [\u0026](ll p, ll k) { ll cnt = 0; for (ll i = 1; i \u003c= n; i++) { if ((a[i] - p) % k == 0) cnt++; } if (cnt \u003e ans) { ans = cnt; pi = p, ki = k; } }; auto check = [\u0026](ll x, ll y) { x = a[x], y = a[y]; ll d = abs(y - x); ll k = d; ll p = x % k; for (ll t = 2; t * t \u003c= d; t++) { if (d % t == 0) { while (d % t == 0) d /= t; k = t; p = x % k; update(p, k); } } if (d \u003e 1) { k = d; p = x % k; update(p, k); } }; random_device rd; mt19937 gen(rd()); uniform_int_distribution\u003c\u003e rnd(1, n); ll tot = 100; while (tot--) { ll i = rnd(gen); ll j = rnd(gen); while (i == j) { j = rnd(gen); } if (abs(a[i] - a[j]) \u003c= 1) continue; check(i, j); } cout \u003c\u003c pi \u003c\u003c ' ' \u003c\u003c ki \u003c\u003c '\\n'; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:9:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-6"},{"categories":null,"content":" J 智乃画二叉树","date":"2025-02-16","objectID":"/posts/nc25wd3/:10:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#j-智乃画二叉树"},{"categories":null,"content":" 题意使用\\、/、_画六边形二叉树，形似： 要去掉不存在的节点，并用一圈*区分范围。 数据范围 $1\\leq n\\leq 99$ $1\\leq k\\leq 7$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:10:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-9"},{"categories":null,"content":" 题意使用\\、/、_画六边形二叉树，形似： 要去掉不存在的节点，并用一圈*区分范围。 数据范围 $1\\leq n\\leq 99$ $1\\leq k\\leq 7$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:10:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-9"},{"categories":null,"content":" 思路先画出满二叉树，再根据树的结构填写序号和删去节点。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:10:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-9"},{"categories":null,"content":" 代码 ll a[maxn], b[maxn]; ll fa[maxn]; ll tot; pll tree[400]; ll w(ll i) { if (i == 1) return 4; return (w(i - 1) + 1) \u003c\u003c 1; } ll h(ll i) { return 3 * (1ll \u003c\u003c (i - 1)); } ll H, W; char maz[200][400]; void paint() { // 满二叉树 memset(maz, ' ', sizeof(maz)); vector\u003cpll\u003e v; for (ll j = 0; j \u003c 3; j++) { for (ll i = 1; i \u003c= W; i++) { char c = ' '; if ((j == 0 \u0026\u0026 i % 6 == 1) || (j == 1 \u0026\u0026 i % 6 == 4) || (j == 2 \u0026\u0026 i % 12 == 7)) { c = '\\\\'; } else if ((j == 0 \u0026\u0026 i % 6 == 4) || (j == 1 \u0026\u0026 i % 6 == 1) || (j == 2 \u0026\u0026 i % 12 == 4)) { c = '/'; } else if ((j == 0 || j == 2) \u0026\u0026 (i % 6 == 2 || i % 6 == 3)) { c = '_'; } else if (j == 1 \u0026\u0026 i % 6 == 2) { c = '0'; } maz[H - j][i] = c; if (j == 2 \u0026\u0026 (i % 12 == 4 || i % 12 == 7)) { v.push_back({H - j, i}); } } } while (v.size() \u003e= 2) { while (v.size() \u003e= 2 \u0026\u0026 v[1].second - v[0].second \u003e 3) { // 延长线 vector\u003cpll\u003e tmp; for (ll i = 0; i \u003c (ll)v.size(); i++) { pll p = v[i]; char c = maz[p.first][p.second]; if (i % 2 == 0) p.first -= 1, p.second += 1; else p.first -= 1, p.second -= 1; maz[p.first][p.second] = c; tmp.push_back(p); } v = tmp; } vector\u003cpll\u003e tmp; for (ll i = 0; i + 1 \u003c (ll)v.size(); i += 2) { pll p = v[i]; p.first -= 1; maz[p.first][p.second] = '\\\\', maz[p.first][p.second + 1] = '_', maz[p.first][p.second + 2] = '_', maz[p.first][p.second + 3] = '/', p.first -= 1; maz[p.first][p.second] = '/', maz[p.first][p.second + 1] = '0', maz[p.first][p.second + 3] = '\\\\'; p.first -= 1; maz[p.first][p.second + 1] = maz[p.first][p.second + 2] = '_'; if (i % 4 == 0) { p.second += 3; maz[p.first][p.second] = '/'; tmp.push_back(p); } else { maz[p.first][p.second] = '\\\\'; tmp.push_back(p); } } v = tmp; } maz[v.front().first][v.front().second] = ' '; tot = 1; for (ll i = 1; i \u003c= H; i++) { for (ll j = 1; j \u003c= W; j++) { if (maz[i][j] == '0') { tree[tot++] = {i, j}; } } } } void dfs(ll p, ll i) { if (p \u003c 10) maz[tree[i].first][tree[i].second] = p + '0'; else maz[tree[i].first][tree[i].second] = p / 10 + '0', maz[tree[i].first][tree[i].second + 1] = p % 10 + '0'; if (a[p] != -1) dfs(a[p], i * 2); if (b[p] != -1) dfs(b[p], i * 2 + 1); } ll nI, I, nJ, J; void cut_zero() { for (ll i = 1; i \u003c tot; i++) { pll p = tree[i]; if (maz[p.first][p.second] != '0') { I = max(I, p.first + 1); J = max(J, p.second + 2); nI = min(nI, p.first - 1); nJ = min(nJ, p.second - 1); continue; } // 删掉六边形 maz[p.first][p.second] = maz[p.first][p.second - 1] = maz[p.first][p.second + 2] = ' '; maz[p.first + 1][p.second - 1] = maz[p.first + 1][p.second] = maz[p.first + 1][p.second + 1] = maz[p.first + 1][p.second + 2] = ' '; maz[p.first - 1][p.second] = maz[p.first - 1][p.second + 1] = ' '; // 删掉延长线 char c = maz[p.first - 1][p.second - 1]; if (c == ' ') { c = maz[p.first - 1][p.second + 2]; p.first -= 1, p.second += 2; } else { p.first -= 1, p.second -= 1; } while (c != ' ' \u0026\u0026 maz[p.first][p.second] == c) { maz[p.first][p.second] = ' '; if (c == '/') p.first -= 1, p.second += 1; else p.first -= 1, p.second -= 1; } } } void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; for (ll i = 1; i \u003c= n; i++) { fa[i] = -1; } H = h(k), W = w(k); paint(); for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; if (a[i] != -1) fa[a[i]] = i; if (b[i] != -1) fa[b[i]] = i; } ll rt = -1; for (ll i = 1; i \u003c= n; i++) { if (fa[i] == -1) { rt = i; break; } } // 填数 dfs(rt, 1); // 删 nI = H, nJ = W, I = 1, J = 1; cut_zero(); // 打印 for (ll i = nI - 1; i \u003c= I + 1; i++) { for (ll j = nJ - 1; j \u003c= J + 1; j++) { if (i == nI - 1 || i == I + 1 || j == nJ - 1 || j == J + 1) { cout \u003c\u003c '*'; } else { cout \u003c\u003c maz[i][j]; } } cout \u003c\u003c '\\n'; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:10:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-7"},{"categories":null,"content":" K 智乃的逆序数","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#k-智乃的逆序数"},{"categories":null,"content":" 题意定义一个紧密排序数组：将数组元素按照从小到大排序后，相邻元素之间的差值是$1$。当两个数组没有任何相同元素，则这两个数组是不相交的。 现在有$n$个互不相交的紧密数组，用这些数组中的元素组合成一个逆序数恰好为$k$的新数组，要求新数组中的数之间保持各自在原来数组中的相对顺序。 数据范围 $1\\leq n\\leq 1000$ $0\\leq k\\leq 1e6$ $1\\leq a_{i,j}\\leq 1e9$ 测试文件的数组长度之和不超过$10^3$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-10"},{"categories":null,"content":" 题意定义一个紧密排序数组：将数组元素按照从小到大排序后，相邻元素之间的差值是$1$。当两个数组没有任何相同元素，则这两个数组是不相交的。 现在有$n$个互不相交的紧密数组，用这些数组中的元素组合成一个逆序数恰好为$k$的新数组，要求新数组中的数之间保持各自在原来数组中的相对顺序。 数据范围 $1\\leq n\\leq 1000$ $0\\leq k\\leq 1e6$ $1\\leq a_{i,j}\\leq 1e9$ 测试文件的数组长度之和不超过$10^3$ ","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-10"},{"categories":null,"content":" 思路新数组中不改变数字之间在原数组中的相对顺序，且这些数组不会相交，那么每个数组是一个范围在$[l,r]$的数的排列，不管怎么改变他们在新数组中的位置，这个小排列中的数形成的逆序数对对数不会减少或增加，当按照最小值排序依次填入新数组时，就是逆序数最小的新数组。 数组之间按照最小值为第一关键字升序排序，如果排序序号较大的数组中的元素放在序号小的数组中的数前面，会增加逆序数。最多的逆序数是数组按照逆序填入新数组时，从大到小枚举数组，计算元素需要向前移动几个位置能恰好满足$k$，也可以按组进行冒泡排序，合法的冒泡排序交换的次数就是增加的逆序数的数量。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-10"},{"categories":null,"content":" 代码：枚举 pair\u003cvector\u003cll\u003e, ll\u003e inverse_num(vector\u003cll\u003e v) { // 归并排序求逆序数 ll n = v.size(); if (n \u003c= 1) return {v, 0}; ll mid = n / 2; vector\u003cll\u003e vl, vr; for (ll i = 0; i \u003c n; i++) { if (i \u003c mid) vl.push_back(v[i]); else vr.push_back(v[i]); } auto [arr_l, invl] = inverse_num(vl); auto [arr_r, invr] = inverse_num(vr); ll nl = arr_l.size(), nr = arr_r.size(); arr_l.push_back(inf), arr_r.push_back(inf); ll i = 0, j = 0; vector\u003cll\u003e arr; ll inv = invl + invr; while (i \u003c nl || j \u003c nr) { if (arr_l[i] \u003c= arr_r[j]) { inv += j; arr.push_back(arr_l[i]); i++; } else { arr.push_back(arr_r[j]); j++; } } return {arr, inv}; } void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cvector\u003cll\u003e\u003e v; vector\u003carray\u003cll, 3\u003e\u003e info; ll tot_len = 0; ll min_ans = 0, max_ans = 0; for (ll i = 0; i \u003c n; i++) { ll m; cin \u003e\u003e m; tot_len += m; vector\u003cll\u003e w(m); for (auto \u0026j : w) { cin \u003e\u003e j; } v.push_back(w); ll ni = inverse_num(w).second; info.push_back({*min_element(w.begin(), w.end()), m, i}); min_ans += ni, max_ans += ni; } // 每个数组的最小元素，大小，位置 sort(info.begin(), info.end()); for (ll i = 0; i \u003c n; i++) { auto [l, m, idx] = info[i]; if (i == 0) { pre[i] = m; } else { pre[i] = pre[i - 1] + m; } } for (ll i = n - 1; i \u003e= 0; i--) { auto [l, m, idx] = info[i]; max_ans += (pre[i] - m) * m; } if (k \u003c min_ans || k \u003e max_ans) { cout \u003c\u003c \"No\\n\"; return; } cout \u003c\u003c \"Yes\\n\"; ll ans = min_ans, i = n - 1, p = 0; ll las = -1; vector\u003cll\u003e arr(tot_len, -1); while (ans \u003c k \u0026\u0026 i \u003c n \u0026\u0026 i \u003e= 0) { auto [l, m, idx] = info[i]; auto w = v[idx]; if (ans + (pre[i] - m) * m \u003c= k) { // 数组idx放在首位 for (ll j = p; j \u003c= p + m - 1; j++) { arr[j] = w[j - p]; } p += m; ans += (pre[i] - m) * m; i--; continue; } ll t = (k - ans) / (pre[i] - m); // 完整挪动t个数 for (ll j = p; j \u003c= p + t - 1; j++) { arr[j] = w[j - p]; } p += t; ll ti = (pre[i] - m) * (t + 1) - (k - ans); arr[p + ti] = w[t]; las = t + 1; break; } for (ll j = 0; j \u003c i; j++) { auto [l, m, idx] = info[j]; for (auto e : v[idx]) { while (arr[p] != -1 \u0026\u0026 p + 1 \u003c tot_len) p++; arr[p++] = e; } } for (ll j = las == -1 ? 0 : las; i \u003c n \u0026\u0026 i \u003e= 0 \u0026\u0026 j \u003c info[i][1]; j++) { auto [l, m, idx] = info[i]; ll e = v[idx][j]; while (arr[p] != -1 \u0026\u0026 p + 1 \u003c tot_len) p++; arr[p++] = e; } for (auto i : arr) { cout \u003c\u003c i \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码枚举"},{"categories":null,"content":" 代码：冒泡排序 void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; vector\u003cvector\u003cll\u003e\u003e v; vector\u003carray\u003cll, 3\u003e\u003e info; ll min_ans = 0, tot = 0; for (ll i = 0; i \u003c n; i++) { ll m, l = inf; cin \u003e\u003e m; tot += m; vector\u003cll\u003e w(m); for (auto \u0026j : w) { cin \u003e\u003e j; l = min(l, j); } v.push_back(w); ll ni = 0; for (ll t = 0; t \u003c m; t++) { for (ll f = t + 1; f \u003c m; f++) { ni += (w[t] \u003e w[f]); } } min_ans += ni; info.push_back({l, m, i}); } if (k \u003c min_ans) { cout \u003c\u003c \"No\\n\"; return; } // 进行一定次数的冒泡排序 sort(info.begin(), info.end()); k -= min_ans; vector\u003cpll\u003e arr; for (ll i = 0; i \u003c n; i++) { ll idx = info[i][2]; for (ll j : v[idx]) { arr.push_back({j, idx}); } } for (ll i = 0; i \u003c tot \u0026\u0026 k \u003e 0; i++) { for (ll j = 0; j \u003c tot - 1; j++) { if (arr[j].first \u003c arr[j + 1].first \u0026\u0026 arr[j].second != arr[j + 1].second \u0026\u0026 k \u003e 0) { k--; swap(arr[j], arr[j + 1]); } else if (k \u003c= 0) { break; } } } if (k \u003e 0) { cout \u003c\u003c \"No\\n\"; return; } cout \u003c\u003c \"Yes\\n\"; for (auto i : arr) { cout \u003c\u003c i.first \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:11:4","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码冒泡排序"},{"categories":null,"content":" L 智乃的三角遍历","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#l-智乃的三角遍历"},{"categories":null,"content":" 题意由三角形构成的平面图，给出层数，找出一条遍历所有边的欧拉回路。 数据范围","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-11"},{"categories":null,"content":" 题意由三角形构成的平面图，给出层数，找出一条遍历所有边的欧拉回路。 数据范围","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-11"},{"categories":null,"content":" 思路$n$比较小，可以打表存答案输出。 法 2：要找出一种可以在任意层数上复刻的遍历思路，下图是一种思路，每次先向下遍历连到下层的点，再回复到右端点。 法 3：递归搜索，类比汉诺塔，如果想完成 1→2→3→1 的顺序，需要先把以 2 为上顶点的三角形遍历完，指针回复到 2 号位置，继续完成 2→3，遍历 3 为上顶点的三角形，最后回到 1。 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-11"},{"categories":null,"content":" 代码：某种顺序 void solve() { ll n; cin \u003e\u003e n; vector\u003cll\u003e v; ll p = 1; v.push_back(p); for (ll i = 1; i \u003c= n; i++) { p += i; v.push_back(p); } while (p + 1 \u003c 1 + (n + 1 + 1) * (n + 1) / 2) { p++; v.push_back(p); } for (ll x = n + 1; x \u003e= 2; x--) { p -= x; ll pi = p; v.push_back(p); while (p \u003e 1 + (x - 2) * (x - 1) / 2) { v.push_back(p + x - 1); p--; v.push_back(p); } while (p + 1 \u003c= pi) { p++; v.push_back(p); } } cout\u003c\u003c\"Yes\\n\"; for (auto i : v) { cout \u003c\u003c i \u003c\u003c ' '; } cout \u003c\u003c \"\\n\"; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码某种顺序"},{"categories":null,"content":" 代码：递归 vector\u003cll\u003e ans; vector\u003cvector\u003cpll\u003e\u003e G; ll tot; void add_edge(ll p1, ll p2) { vis[tot] = false; G[p1].push_back({p2, tot}); // 终点和这条边的编号 G[p2].push_back({p1, tot++}); } void dfs(ll p) { for (auto i : G[p]) { if (vis[i.second]) continue; vis[i.second] = true; dfs(i.first); } ans.push_back(p); } void solve() { ll n; cin \u003e\u003e n; G.assign((n + 1) * (n + 2) / 2 + 1, vector\u003cpll\u003e()); for (ll i = 1; i \u003c= n; i++) { // 第i层 for (ll j = 1; j \u003c= i; j++) { ll p1 = (i - 1) * i / 2 + j; ll p2 = p1 + i, p3 = p1 + i + 1; add_edge(p1, p2); add_edge(p2, p3); add_edge(p3, p1); } } dfs(1); cout \u003c\u003c \"Yes\\n\"; for (auto i : ans) { cout \u003c\u003c i \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:12:4","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码递归"},{"categories":null,"content":" M 智乃的牛题","date":"2025-02-16","objectID":"/posts/nc25wd3/:13:0","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#m-智乃的牛题"},{"categories":null,"content":" 题意判断输入的长度为 8 的字符串能不能重组字符顺序组成nowcoder。 数据范围无 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:13:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#题意-12"},{"categories":null,"content":" 题意判断输入的长度为 8 的字符串能不能重组字符顺序组成nowcoder。 数据范围无 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:13:1","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#数据范围-12"},{"categories":null,"content":" 思路无 ","date":"2025-02-16","objectID":"/posts/nc25wd3/:13:2","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#思路-12"},{"categories":null,"content":" 代码 void solve() { string s; cin \u003e\u003e s; map\u003cchar, ll\u003e mp; for (auto c : s) { mp[c]++; } if (mp['n'] == 1 \u0026\u0026 mp['o'] == 2 \u0026\u0026 mp['w'] == 1 \u0026\u0026 mp['c'] == 1 \u0026\u0026 mp['d'] == 1 \u0026\u0026 mp['e'] == 1 \u0026\u0026 mp['r'] == 1) { cout \u003c\u003c \"happy new year\\n\"; } else { cout \u003c\u003c \"I AK IOI\\n\"; } } ","date":"2025-02-16","objectID":"/posts/nc25wd3/:13:3","series":null,"tags":null,"title":"2025牛客暑寒假多校训练营Day3（完結）","uri":"/posts/nc25wd3/#代码-8"},{"categories":["在学算法的日子里"],"content":" A 一起奏响历史之音！","date":"2025-02-06","objectID":"/posts/nc25wd2/:1:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#a-一起奏响历史之音"},{"categories":["在学算法的日子里"],"content":" 题意中国传统五声调中包含 1、2、3、5、6，判断一个乐谱是否仅由全部或部分五声调铺成。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:1:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意"},{"categories":["在学算法的日子里"],"content":" 思路按题意判断即可。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:1:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { bool flag = true; set\u003cll\u003e st = {1, 2, 3, 5, 6}; ll x; while (cin \u003e\u003e x) { if (st.find(x) == st.end()) { flag = false; } } if (flag) { cout \u003c\u003c \"YES\\n\"; } else { cout \u003c\u003c \"NO\\n\"; } } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:1:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码"},{"categories":["在学算法的日子里"],"content":" B 能去你家蹭口饭吃吗","date":"2025-02-06","objectID":"/posts/nc25wd2/:2:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#b-能去你家蹭口饭吃吗"},{"categories":["在学算法的日子里"],"content":" 题意给出一个数组$a$，找到一个整数，要求整数尽可能大，但是至少要比数组中一半数量的数小。 数据范围 $1\\leq n\\leq 5e5$ $1\\leq a_i\\leq 1e6$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:2:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给出一个数组$a$，找到一个整数，要求整数尽可能大，但是至少要比数组中一半数量的数小。 数据范围 $1\\leq n\\leq 5e5$ $1\\leq a_i\\leq 1e6$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:2:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路如果数组长度为奇数，则取中位数-1，即$a[n-n/2]-1$。 如果数组长度为偶数，则取下标更大的中位数-1，即$a[n/2+1]-1$。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:2:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } sort(a + 1, a + 1 + n); if (n \u0026 1) cout \u003c\u003c a[n - n / 2] - 1 \u003c\u003c '\\n'; else cout \u003c\u003c a[n / 2 + 1] - 1 \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:2:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-1"},{"categories":["在学算法的日子里"],"content":" D 字符串里串","date":"2025-02-06","objectID":"/posts/nc25wd2/:3:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#d-字符串里串"},{"categories":["在学算法的日子里"],"content":" 题意定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。 给出字符串$s$，求其可爱度。 数据范围 $3\\leq m \\leq 2e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:3:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。 给出字符串$s$，求其可爱度。 数据范围 $3\\leq m \\leq 2e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:3:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路$b$是不连续子串，可以设计$a$和$b$仅最后一位或开头一位的在原串中的位置不同，那么只需要寻找符合条件的数量大于等于 2 的字母，并比较分别去掉两端得到的最长的串的长度。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:3:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; string s; cin \u003e\u003e n \u003e\u003e s; s = \" \" + s; map\u003cchar, vector\u003cll\u003e\u003e mp; for (ll i = 1; i \u003c= n; i++) { char c = s[i]; mp[c].push_back(i); } ll ans = 0; for (auto [c, v] : mp) { if (v.size() \u003e= 2) { ll m = v.size(); ans = max(ans, v[m - 2]); } } for (auto [c, v] : mp) { if (v.size() \u003e= 2) { ll m = v.size(); ans = max(ans, n - v[1] + 1); } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:3:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-2"},{"categories":["在学算法的日子里"],"content":" C 字符串外串","date":"2025-02-06","objectID":"/posts/nc25wd2/:4:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#c-字符串外串"},{"categories":["在学算法的日子里"],"content":" 题意定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。构造长度为$n$的由小写字母组成的字符串，使其可爱度为$m$，或报告没有这样的合法字符串。 数据范围 $3\\leq m\\leq n\\leq n\\leq 2e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:4:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。构造长度为$n$的由小写字母组成的字符串，使其可爱度为$m$，或报告没有这样的合法字符串。 数据范围 $3\\leq m\\leq n\\leq n\\leq 2e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:4:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路$a,b$两种字符串至少要有 1 位对应原串的位置不同，当$n=m$时显然无解。 设字符串$t$是$a,b$左端对齐之后公共的部分，长度为$m-1$，小写字母只有 26 个，当$n-m\\gt 26$时，不管怎么填后$n-m$的字母，都不可能与让所有在$i\\geq m$的范围内的字母只出现一次，出现多次则可爱度会增加。按照这样的思路构造前$m-1$长度的字符串，并保证在后一半的部分中字符$s[m-1]$出现且仅出现一次。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:4:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, m; cin \u003e\u003e n \u003e\u003e m; if (n - m \u003c 1) { cout \u003c\u003c \"NO\\n\"; return; } string s; if (m == n - 1) { for (ll i = 1; i \u003c= n; i++) { if (i == n - 1 || i == n) { s.push_back('b'); } else { s.push_back('a'); } } } else if (n - m \u003c= 26) { for (ll i = 0; i \u003c n; i++) { s.push_back('a' + i % 26); } s.back() = s[m - 1]; } else { cout \u003c\u003c \"NO\\n\"; return; } cout \u003c\u003c \"YES\\n\" \u003c\u003c s \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:4:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-3"},{"categories":["在学算法的日子里"],"content":" E 一起走很长的路！","date":"2025-02-06","objectID":"/posts/nc25wd2/:5:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#e-一起走很长的路"},{"categories":["在学算法的日子里"],"content":" 题意一列多米诺骨牌，质量是$a_i$，有$q$次询问，询问一个区间$[l,r]$，推倒第$l$位的多米诺骨牌，如果$\\sum_{i=l}^{i-1}\\geq a_i$，则第$a_i$块可以顺利倒下，为了使第$r$块可以顺利倒下，可以进行一种操作：选择某个多米诺骨牌，将其质量+1 或-1，对每个询问返回最少的可以推倒$r$的操作数。 数据范围 $1\\leq n,q\\leq 2e5$ $1\\leq a_i\\leq 1e9$ $1\\leq l\\leq r\\leq n$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:5:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意一列多米诺骨牌，质量是$a_i$，有$q$次询问，询问一个区间$[l,r]$，推倒第$l$位的多米诺骨牌，如果$\\sum_{i=l}^{i-1}\\geq a_i$，则第$a_i$块可以顺利倒下，为了使第$r$块可以顺利倒下，可以进行一种操作：选择某个多米诺骨牌，将其质量+1 或-1，对每个询问返回最少的可以推倒$r$的操作数。 数据范围 $1\\leq n,q\\leq 2e5$ $1\\leq a_i\\leq 1e9$ $1\\leq l\\leq r\\leq n$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:5:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路对于一个区间，如果要进行操作时，肯定是将+1 加在第$l$位的牌上。 当$l=1$时，容易直到，想要第$i$块牌倒下，需要$\\max(a_i-pre_{i-1},0)$的操作次数，$pre_i$是前$i$项的质量和，故在整个区间上，只需要取$\\max(a_i-pre_{i-1}),(l+1\\leq i\\leq r)$。 在区间$[l,r]$中，如果要推倒第$i$块牌，则需要构造新的以$l$为左端点的$pre$，这个$pre$的值可以由$pre_i-pre_{l-1}$推倒，代入上式，则答案是$\\max(a_i-(pre_i-pre_{l-1}))$。用某种数据结构维护区间最大值。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:5:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 // ST表 ll dp[maxn][30]; void rmq_st(ll n) { for (ll i = 1; i \u003c= n; i++) { dp[i][0] = b[i]; // 2^0 } ll m = log(1 * n) / log(2.0); for (ll j = 1; j \u003c= m; j++) { ll t = n - (1 \u003c\u003c j) + 1; for (ll i = 1; i \u003c= t; i++) { dp[i][j] = max(dp[i][j - 1], dp[i + (1 \u003c\u003c (j - 1))][j - 1]); } } } ll rmq_find(ll l, ll r) { // 从l开始,长度为r的区间 ll k = log(1.0 * (r - l + 1)) / log(2.0); return max(dp[l][k], dp[r - (1 \u003c\u003c k) + 1][k]); } void solve() { ll n, q; cin \u003e\u003e n \u003e\u003e q; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] + a[i]; b[i] = a[i] - pre[i - 1]; } rmq_st(n); while (q--) { ll l, r; cin \u003e\u003e l \u003e\u003e r; if (l == r) { cout \u003c\u003c \"0\\n\"; continue; } // ans=max(a[i]-(pre[i]-pre[l-1])) ll t = rmq_find(l + 1, r) + pre[l - 1]; // [l+1,r]需要推倒 ll ans = max(t, 0ll); cout \u003c\u003c ans \u003c\u003c '\\n'; } } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:5:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-4"},{"categories":["在学算法的日子里"],"content":" F 一起找神秘的数！","date":"2025-02-06","objectID":"/posts/nc25wd2/:6:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#f-一起找神秘的数"},{"categories":["在学算法的日子里"],"content":" 题意在区间$[l,r]$中找到两个数$x,y$，使之满足$x+y=(x\\ordinarycolon y)+(x \\land y)+(x \\oplus y)$，求这样的数对的数量。 数据范围 $1\\leq T \\leq 2e5$ $0\\leq l\\leq r\\leq 1e18$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:6:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意在区间$[l,r]$中找到两个数$x,y$，使之满足$x+y=(x\\ordinarycolon y)+(x \\land y)+(x \\oplus y)$，求这样的数对的数量。 数据范围 $1\\leq T \\leq 2e5$ $0\\leq l\\leq r\\leq 1e18$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:6:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路打表猜结论，发现只有$x=y$时等式成立。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:6:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll l, r; cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c r - l + 1 \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:6:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-5"},{"categories":["在学算法的日子里"],"content":" G 一起铸最好的剑！","date":"2025-02-06","objectID":"/posts/nc25wd2/:7:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#g-一起铸最好的剑"},{"categories":["在学算法的日子里"],"content":" 题意在$m$的幂次中找到最接近$n$的数。 数据范围 $1\\leq T \\leq 1e5$ $1\\leq n,m\\leq 1e9$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:7:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意在$m$的幂次中找到最接近$n$的数。 数据范围 $1\\leq T \\leq 1e5$ $1\\leq n,m\\leq 1e9$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:7:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路模拟。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:7:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-6"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, m; cin \u003e\u003e n \u003e\u003e m; if (m == 1) { cout \u003c\u003c \"1\\n\"; return; } p[0] = 1, p[1] = m; ll pi = 1; ll mx = abs(p[pi] - n); ll i = 1; for (; p[i] \u003c= n; i++) { if (abs(p[i] - n) \u003c mx) { pi = i; mx = abs(p[i] - n); } p[i + 1] = p[i] * m; } if (abs(p[i] - n) \u003c mx) { pi = i; mx = abs(p[i] - n); } cout \u003c\u003c pi \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:7:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-6"},{"categories":["在学算法的日子里"],"content":" H 一起画很大的圆！","date":"2025-02-06","objectID":"/posts/nc25wd2/:8:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#h-一起画很大的圆"},{"categories":["在学算法的日子里"],"content":" 题意在矩形的边界上找三个不共线的点，使得过这三个点确定的圆的面积最大。 数据范围 $-1e6\\leq a,b,c,d\\leq 1e6$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:8:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意在矩形的边界上找三个不共线的点，使得过这三个点确定的圆的面积最大。 数据范围 $-1e6\\leq a,b,c,d\\leq 1e6$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:8:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路合适的点的候选在矩形的四个直角附近一个单位长度的点中选，暴力枚举三个点，并判断取半径最大的圆。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:8:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-7"},{"categories":["在学算法的日子里"],"content":" 代码 ld getcir2(pll p1, pll p2, pll p3) { auto [x1, y1] = p1; auto [x2, y2] = p2; auto [x3, y3] = p3; ld r; ld a = x1 - x2, b = y1 - y2, c = x1 - x3, d = y1 - y3; ld e = ((x1 * x1 - x2 * x2) + (y1 * y1 - y2 * y2)) / 2.0; ld f = ((x1 * x1 - x3 * x3) + (y1 * y1 - y3 * y3)) / 2.0; ld det = b * c - a * d; if (fabs(det) \u003c 1e-5) { r = -1; return r; } ld x0 = -(d * e - b * f) / det; ld y0 = -(a * f - c * e) / det; r = hypot(x1 - x0, y1 - y0); return r; } void solve() { ll a, b, c, d; cin \u003e\u003e a \u003e\u003e b \u003e\u003e c \u003e\u003e d; vector\u003cpll\u003e v = { {a, c}, {a + 1, c}, {a, c + 1}, {a, d}, {a + 1, d}, {a, d - 1}, {b, c}, {b - 1, c}, {b, c + 1}, {b, d}, {b - 1, d}, {b, d - 1}, }; pll p1 = {a, c}, p2 = {a + 1, c}, p3 = {a, c + 1}; ld r = getcir2(p1, p2, p3); for (ll i = 0; i \u003c (ll)v.size(); i++) { for (ll j = 0; j \u003c (ll)v.size(); j++) { for (ll k = 0; k \u003c (ll)v.size(); k++) { ld ri = getcir2(v[i], v[j], v[k]); if (ri != -1 \u0026\u0026 r \u003c ri) { r = ri; p1 = v[i], p2 = v[j], p3 = v[k]; } } } } cout \u003c\u003c p1.first \u003c\u003c ' ' \u003c\u003c p1.second \u003c\u003c '\\n'; cout \u003c\u003c p2.first \u003c\u003c ' ' \u003c\u003c p2.second \u003c\u003c '\\n'; cout \u003c\u003c p3.first \u003c\u003c ' ' \u003c\u003c p3.second \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:8:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-7"},{"categories":["在学算法的日子里"],"content":" I","date":"2025-02-06","objectID":"/posts/nc25wd2/:9:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#i"},{"categories":["在学算法的日子里"],"content":" 题意 数据范围","date":"2025-02-06","objectID":"/posts/nc25wd2/:9:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意 数据范围","date":"2025-02-06","objectID":"/posts/nc25wd2/:9:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路","date":"2025-02-06","objectID":"/posts/nc25wd2/:9:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-8"},{"categories":["在学算法的日子里"],"content":" 代码","date":"2025-02-06","objectID":"/posts/nc25wd2/:9:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-8"},{"categories":["在学算法的日子里"],"content":" J 数据时间？","date":"2025-02-06","objectID":"/posts/nc25wd2/:10:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#j-数据时间"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个数据，每条数据由user_id、login_date、login_time组成，表示员工号，登录日期和登录时间。员工号是不超过$1e20$的整数，登录日期是一个YYYY-MM-DD模式的日期，登录时间是hh:mm:ss模式的时间。 现在查询h年m月的员工在通勤时间（07:00:00-09:00:00和18:00:00-20:00:00）、午休时间（11:00:00-13:00:00）和临睡时间（22:00:00-01:00:00）的登录人次情况，同一个人在同一个时间段的多次登录算作一人次。时间段均包含边界。 数据范围 $1\\leq n\\leq 1e5$ $2000\\leq h\\leq 2030;1\\leq m\\leq 12$ $1\\leq user_{id}\\leq 10^{20}$ 日期和时间的格式如题意所述。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:10:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-9"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个数据，每条数据由user_id、login_date、login_time组成，表示员工号，登录日期和登录时间。员工号是不超过$1e20$的整数，登录日期是一个YYYY-MM-DD模式的日期，登录时间是hh:mm:ss模式的时间。 现在查询h年m月的员工在通勤时间（07:00:00-09:00:00和18:00:00-20:00:00）、午休时间（11:00:00-13:00:00）和临睡时间（22:00:00-01:00:00）的登录人次情况，同一个人在同一个时间段的多次登录算作一人次。时间段均包含边界。 数据范围 $1\\leq n\\leq 1e5$ $2000\\leq h\\leq 2030;1\\leq m\\leq 12$ $1\\leq user_{id}\\leq 10^{20}$ 日期和时间的格式如题意所述。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:10:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路按题意模拟。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:10:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-9"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, h, m; cin \u003e\u003e n \u003e\u003e h \u003e\u003e m; map\u003cstring, vector\u003cpair\u003cstring, string\u003e\u003e\u003e mp; map\u003cstring, bool\u003e mp1, mp2, mp3; for (ll i = 1; i \u003c= n; i++) { string id, t; ll dy, dm, dd; char c; cin \u003e\u003e id \u003e\u003e dy \u003e\u003e c \u003e\u003e dm \u003e\u003e c \u003e\u003e dd \u003e\u003e t; if (dy == h \u0026\u0026 dm == m) { string s = t; ll st = ((s[0] - '0') * 10 + (s[1] - '0')) * 3600 + ((s[3] - '0') * 10 + (s[4] - '0')) * 60 + (s[6] - '0') * 10 + (s[7] - '0'); if ((st \u003e= 7 * 3600 \u0026\u0026 st \u003c= 9 * 3600)||(st \u003e= 18 * 3600 \u0026\u0026 st \u003c= 20 * 3600)) { mp1[id] = true; } else if (st \u003e= 11 * 3600 \u0026\u0026 st \u003c= 13 * 3600) { mp2[id] = true; } else if ((st \u003e= 22 * 3600 \u0026\u0026 st \u003c= 24 * 3600) || (st \u003e= 0 * 3600 \u0026\u0026 st \u003c= 1 * 3600)) { mp3[id] = true; } } } cout \u003c\u003c mp1.size() \u003c\u003c ' ' \u003c\u003c mp2.size() \u003c\u003c ' ' \u003c\u003c mp3.size() \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:10:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-9"},{"categories":["在学算法的日子里"],"content":" K 可以分开吗？","date":"2025-02-06","objectID":"/posts/nc25wd2/:11:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#k-可以分开吗"},{"categories":["在学算法的日子里"],"content":" 题意有一块$n\\times m$的方块组成的矩阵，其中有一些蓝色方块，其余为灰色方块，定义两块方块的连通的：只有当两块方块在四连通方向有共边。 当一个蓝色极大连通块可以脱离矩阵时，其任何蓝色方块不与任何灰色方块有共边。现在先在矩阵中通过移除灰色方块，取出一个蓝色极大连通块，求最少的操作次数。 数据范围 $1\\leq n,m\\leq 500$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:11:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-10"},{"categories":["在学算法的日子里"],"content":" 题意有一块$n\\times m$的方块组成的矩阵，其中有一些蓝色方块，其余为灰色方块，定义两块方块的连通的：只有当两块方块在四连通方向有共边。 当一个蓝色极大连通块可以脱离矩阵时，其任何蓝色方块不与任何灰色方块有共边。现在先在矩阵中通过移除灰色方块，取出一个蓝色极大连通块，求最少的操作次数。 数据范围 $1\\leq n,m\\leq 500$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:11:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-9"},{"categories":["在学算法的日子里"],"content":" 思路并查集。 遍历所有的蓝色方块，并查集维护每个蓝色方块寻找它属于的蓝色极大连通块，再通过遍历这些连通块的每个小方块的周围四格，统计需要敲掉的灰色方块的数量。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:11:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-10"},{"categories":["在学算法的日子里"],"content":" 代码 ll n, m; ll a[maxn], b[maxn]; ll fa[maxn]; char maz[600][600]; ll find(ll x) { if (fa[x] == x) { return x; } return fa[x] = find(fa[x]); } void merge(ll u, ll v) { ll fu = find(u), fv = find(v); if (fu == fv) { return; } fa[fu] = fv; } vector\u003cpll\u003e dxy = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; void solve() { cin \u003e\u003e n \u003e\u003e m; for (ll i = 0; i \u003c= (n + 5) * (m + 5); i++) { fa[i] = i; } vector\u003cpll\u003e v; for (ll i = 1; i \u003c= n; i++) { for (ll j = 1; j \u003c= m; j++) { cin \u003e\u003e maz[i][j]; if (maz[i][j] == '1') { v.push_back({i, j}); } } } // 并查集 for (auto [x, y] : v) { for (auto [dx, dy] : dxy) { ll px = dx + x, py = dy + y; if (maz[px][py] == '1') { merge((px - 1) * m + py, (x - 1) * m + y); } } } map\u003cll, vector\u003cpll\u003e\u003e mp; for (auto i : v) { ll x = (i.first - 1) * m + i.second; ll fx = find(x); mp[fx].push_back(i); } ll res = n * m - v.size(); for (auto [i, vi] : mp) { set\u003cpll\u003e st; for (auto [x, y] : vi) { for (auto [dx, dy] : dxy) { ll px = dx + x, py = dy + y; if (px \u003c 1 || px \u003e n || py \u003c 1 || py \u003e m) continue; if (maz[px][py] == '0') { st.insert({px, py}); } } } res = min(res, (ll)st.size()); } cout \u003c\u003c res \u003c\u003c '\\n'; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:11:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-10"},{"categories":["在学算法的日子里"],"content":" L","date":"2025-02-06","objectID":"/posts/nc25wd2/:12:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#l"},{"categories":["在学算法的日子里"],"content":" 题意 数据范围","date":"2025-02-06","objectID":"/posts/nc25wd2/:12:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-11"},{"categories":["在学算法的日子里"],"content":" 题意 数据范围","date":"2025-02-06","objectID":"/posts/nc25wd2/:12:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-10"},{"categories":["在学算法的日子里"],"content":" 思路","date":"2025-02-06","objectID":"/posts/nc25wd2/:12:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-11"},{"categories":["在学算法的日子里"],"content":" 代码","date":"2025-02-06","objectID":"/posts/nc25wd2/:12:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-11"},{"categories":["在学算法的日子里"],"content":" M 那是我们的影子","date":"2025-02-06","objectID":"/posts/nc25wd2/:13:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#m-那是我们的影子"},{"categories":["在学算法的日子里"],"content":" 题意在$3\\times n$的矩阵中，每个格子要么是$1\\sim 9$的数字，要么是?。求将所有的?填入$1\\sim 9$的数字，任意$3\\times 3$的九宫格中的数字都不重复，求合法的填写方式的数量，答案对$1e9+7$取模。 数据范围 $3\\leq n\\leq 1e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:13:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#题意-12"},{"categories":["在学算法的日子里"],"content":" 题意在$3\\times n$的矩阵中，每个格子要么是$1\\sim 9$的数字，要么是?。求将所有的?填入$1\\sim 9$的数字，任意$3\\times 3$的九宫格中的数字都不重复，求合法的填写方式的数量，答案对$1e9+7$取模。 数据范围 $3\\leq n\\leq 1e5$ ","date":"2025-02-06","objectID":"/posts/nc25wd2/:13:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#数据范围-11"},{"categories":["在学算法的日子里"],"content":" 思路易知，所有$i\\mod 3$相同的列的数字组成都是一样的。 几种无合法解的情况： 某一列有重复的数字 某个$i\\mod 3$的组中数字的种数多于 3 种 排除不合法的情况后，进行排列组合，将所有九宫格的数字位置情况汇总成一个标准九宫格后，里面有一些位置依然是?，数字不确定，这些不确定的$k$个位置对应$k$个没有出现过的数字，将其分成$3$组，分别对应每列的空缺位，这样的组合方法有$\\binom{k}{col_0}\\times \\binom{k-col_0}{col_1}\\times \\binom{k-col_0-col_1}{col_2}$种。 完成上面这一步之后，相当于九宫格的每列对应的数集合是确定的。接下来遍历每一列，乘上在空缺位上的全排列数。 ","date":"2025-02-06","objectID":"/posts/nc25wd2/:13:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#思路-12"},{"categories":["在学算法的日子里"],"content":" 代码 #include \u003cbits/stdc++.h\u003e using namespace std; typedef double ld; typedef unsigned long ul; typedef long long ll; typedef unsigned long long ull; typedef pair\u003cll, ll\u003e pll; const ll maxn = 2e6 + 50; const ll inf = 0x3f3f3f3f3f; const ll mo998 = 998244353; const ll mo1e9 = 1000000007; ll qpow(ll a, ll b) { ll ret = 1; while (b) { if (b \u0026 1) ret = (ret * a) % mo1e9; a = a * a % mo1e9; b \u003e\u003e= 1; } return ret; } ll inv(ll x) { return qpow(x, mo1e9 - 2); } // 逆元求组合数 ll fz[maxn], fm[maxn]; ll C(ll n, ll m) { if (n \u003c m) return 0ll; if (n == m) return 1ll; return fz[n] * fm[m] % mo1e9 * fm[n - m] % mo1e9; } ll A(ll x, ll y) { return fz[x] * C(x, y) % mo1e9; } ll maz[5][maxn]; void solve() { ll n; cin \u003e\u003e n; vector\u003cstring\u003e s(4); cin \u003e\u003e s[1] \u003e\u003e s[2] \u003e\u003e s[3]; // 第0,3,6...相同，i%3相同的数字组成一模一样 vector\u003cset\u003cll\u003e\u003e col(5, set\u003cll\u003e()); // 第0/1/2列的数字 vector\u003cll\u003e q(n + 10, 0ll); // 每列的?数量 for (ll i = 0; i \u003c n; i++) { set\u003cll\u003e tmp; for (ll t = 1; t \u003c= 3; t++) { char c = s[t][i]; if (c != '?') { maz[t][i] = c - '0'; if (tmp.count(maz[t][i])) { // 列有重复 cout \u003c\u003c \"0\\n\"; return; } tmp.insert(maz[t][i]); col[i % 3].insert(maz[t][i]); if (col[i % 3].size() \u003e 3) { // 种数不合法 cout \u003c\u003c \"0\\n\"; return; } } else { maz[t][i] = -1; q[i]++; } } } set\u003cll\u003e usd; for (ll i = 0; i \u003c 3; i++) { for (auto j : col[i]) { usd.insert(j); } } vector\u003cll\u003e v = { 3 - (ll)col[0].size(), 3 - (ll)col[1].size(), 3 - (ll)col[2].size(), }; ll tot = v[0] + v[1] + v[2]; if (tot + usd.size() != 9) { cout \u003c\u003c \"0\\n\"; return; } ll ans = 1ll * C(tot, v[0]) * C(tot - v[0], v[1]) % mo1e9; for (ll i = 0; i \u003c n; i++) { ll k = q[i]; ans = ans * A(k, k) % mo1e9; } cout \u003c\u003c ans \u003c\u003c '\\n'; } void init() { ll w = maxn - 10; fz[0] = fm[0] = 1; for (ll i = 1; i \u003c= w; i++) { fz[i] = fz[i - 1] * i % mo1e9; } fm[w] = inv(fz[w]); for (ll i = w - 1; i \u003e= 1; i--) { fm[i] = fm[i + 1] * (i + 1) % mo1e9; } } int main(void) { ios::sync_with_stdio(false); cin.tie(0); ll _t = 1; cin \u003e\u003e _t; cin.get(); init(); while (_t--) solve(); return 0; } ","date":"2025-02-06","objectID":"/posts/nc25wd2/:13:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day2","uri":"/posts/nc25wd2/#代码-12"},{"categories":["在学算法的日子里"],"content":" A 茕茕孑立之影","date":"2025-01-23","objectID":"/posts/nc25wd1/:1:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#a-茕茕孑立之影"},{"categories":["在学算法的日子里"],"content":" 题意找一个不超过$1e18$的数$x$，使得$x$既不是任何$a_i$的倍数，也不是任何$a_i$的因数。若没有输出$-1$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:1:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意"},{"categories":["在学算法的日子里"],"content":" 题意找一个不超过$1e18$的数$x$，使得$x$既不是任何$a_i$的倍数，也不是任何$a_i$的因数。若没有输出$-1$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:1:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路观察到，如果数组中有$1$则不存在这样的数。 $1\\leq a_i\\leq 1e9$，而$1\\leq x\\leq 1e18$，有解时任意数=输出一个大于$1e9$的质数即可。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:1:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } sort(a + 1, a + 1 + n); if (a[1] == 1) { cout \u003c\u003c \"-1\\n\"; } else { cout \u003c\u003c \"100000007\\n\"; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:1:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码"},{"categories":["在学算法的日子里"],"content":" B 一气贯通之刃","date":"2025-01-23","objectID":"/posts/nc25wd1/:2:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#b-一气贯通之刃"},{"categories":["在学算法的日子里"],"content":" 题意给一棵树，寻找一条简单路径，使之遍历树上所有的顶点，输出起点和终点。如果没有这样的解则输出$-1$。 简单路径是指这样一条路径，其经过的顶点和边互不相同。 数据范围 $2\\leq n\\leq 1e5$ $1\\leq u_i,v_i\\leq n,u_i\\neq v_i$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:2:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给一棵树，寻找一条简单路径，使之遍历树上所有的顶点，输出起点和终点。如果没有这样的解则输出$-1$。 简单路径是指这样一条路径，其经过的顶点和边互不相同。 数据范围 $2\\leq n\\leq 1e5$ $1\\leq u_i,v_i\\leq n,u_i\\neq v_i$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:2:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路只有整个树是一条链时，从一个叶子节点到另一个叶子节点，才能有符合要求的简单路径。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:2:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 ll deg[maxn]; void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n - 1; i++) { ll u, v; cin \u003e\u003e u \u003e\u003e v; deg[u]++, deg[v]++; } vector\u003cll\u003e v; for (ll i = 1; i \u003c= n; i++) { if (deg[i] == 1) { v.push_back(i); } } if (v.size() != 2) { cout \u003c\u003c \"-1\\n\"; } else { cout \u003c\u003c v[0] \u003c\u003c ' ' \u003c\u003c v[1] \u003c\u003c '\\n'; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:2:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-1"},{"categories":["在学算法的日子里"],"content":" C 兢兢业业之移","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#c-兢兢业业之移"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n\\times n$的 01 矩阵，$n$是偶数，其中有刚好$\\frac{n^2}{4}$个1，请将这些 1 全部移动到矩阵左上角的位置，即$1\\leq i\\leq \\frac{n}{2},q\\leq j\\leq \\frac{n}{2}$的位置，规定移动只能与共边的方格交换，交换次数不超过$\\frac{n^3}{2}$。 数据范围 $2\\leq n\\leq 100$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n\\times n$的 01 矩阵，$n$是偶数，其中有刚好$\\frac{n^2}{4}$个1，请将这些 1 全部移动到矩阵左上角的位置，即$1\\leq i\\leq \\frac{n}{2},q\\leq j\\leq \\frac{n}{2}$的位置，规定移动只能与共边的方格交换，交换次数不超过$\\frac{n^3}{2}$。 数据范围 $2\\leq n\\leq 100$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路考虑一条移动路径将 1 移动到左上角某个 0 的位置，如果这个路径上有其他的 1，显然移动路径中间的 1 到同样的目标 0 位置的次数是更小的。 从左上角坐标点进行 bfs，最先碰到的 1 是最近的，还原 bfs 的路径。还原 bfs 的路径可以通过存储 bfs 时拓展的父节点来回溯获得。 或者考虑寻找最短路时，路径只可能是直线或者直角线，假设路径需要“拐弯”才能到达某个 1，那这个“拐弯”的地方肯定是 1。这样的路径的长度正好是曼哈顿距离，$n$比较小，可以遍历所有的 1 来选择举例要填的 0 最近的点。还原路径的时候按照先纵向再横向或者先横向再纵向都可以。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 1：曼哈顿距离 ll n; map\u003cpll, bool\u003e vis; vector\u003cpii\u003e dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; vector\u003carray\u003cll, 4\u003e\u003e ans; void solve() { cin \u003e\u003e n; ans.clear(), vis.clear(); vector\u003cpll\u003e v; for (ll i = 1; i \u003c= n; i++) { for (ll j = 1; j \u003c= n; j++) { char c; cin \u003e\u003e c; if (c == '1') { v.push_back({i, j}); } } } auto dis = [\u0026](pll p1, pll p2) { return abs(p1.first - p2.first) + abs(p1.second - p2.second); }; for (ll i = 1; i \u003c= n / 2; i++) { for (ll j = 1; j \u003c= n / 2; j++) { pll pi = {i, j}; pll p = {10000, 10000}; for (auto pj : v) { if (!vis.count(pj) \u0026\u0026 dis(pi, pj) \u003c dis(pi, p)) { p = pj; } } vis[p] = true; auto [x, y] = p; while (x \u003e i) { ans.push_back({x, y, x - 1, y}), x -= 1; } while (x \u003c i) { ans.push_back({x, y, x + 1, y}), x += 1; } while (y \u003e j) { ans.push_back({x, y, x, y - 1}), y -= 1; } while (y \u003c j) { ans.push_back({x, y, x, y + 1}), y += 1; } } } cout \u003c\u003c ans.size() \u003c\u003c '\\n'; for (auto [q, w, e, r] : ans) { cout \u003c\u003c q \u003c\u003c ' ' \u003c\u003c w \u003c\u003c ' ' \u003c\u003c e \u003c\u003c ' ' \u003c\u003c r \u003c\u003c '\\n'; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-1曼哈顿距离"},{"categories":["在学算法的日子里"],"content":" 代码 2：宽搜 ll n; char maz[250][250]; vector\u003cpii\u003e dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}; bool vis[250][250], inq[250][250]; vector\u003carray\u003cll, 4\u003e\u003e ans; pii trace[250][250]; void solve() { cin \u003e\u003e n; ans.clear(); vector\u003cpii\u003e v; for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { cin \u003e\u003e maz[i][j]; vis[i][j] = false; } } // bfs for (ll i = 1; i \u003c= n / 2; i++) { for (ll j = 1; j \u003c= n / 2; j++) { for (ll ii = 1; ii \u003c= n; ii++) { for (ll jj = 1; jj \u003c= n; jj++) { inq[ii][jj] = false; } } bool flag = false; pii o = {i, j}; trace[i][j] = {i, j}; queue\u003cpii\u003e q; q.push({i, j}); inq[i][j] = true; while (!q.empty()) { pii pi = q.front(); q.pop(); if (maz[pi.first][pi.second] == '1') { o = pi; flag = true; break; } if (maz[pi.first][pi.second] == '1') break; for (auto [dx, dy] : dxy) { int px = pi.first + dx, py = pi.second + dy; if (px \u003c 1 || px \u003e n || py \u003c 1 || py \u003e n) continue; if (vis[px][py] || inq[px][py]) continue; trace[px][py] = pi; if (maz[px][py] == '1') { o = {px, py}; flag = true; break; } inq[px][py] = true; q.push({px, py}); } if (flag) break; } // 必然有解的 maz[o.first][o.second] = '0'; // 路径还原 while (o.first != i || o.second != j) { pii i = trace[o.first][o.second]; ans.push_back({o.first, o.second, i.first, i.second}); o = i; } maz[o.first][o.second] = '1'; vis[i][j] = true; } } cout \u003c\u003c ans.size() \u003c\u003c '\\n'; for (auto [q, w, e, r] : ans) { cout \u003c\u003c q \u003c\u003c ' ' \u003c\u003c w \u003c\u003c ' ' \u003c\u003c e \u003c\u003c ' ' \u003c\u003c r \u003c\u003c '\\n'; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:3:4","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-2宽搜"},{"categories":["在学算法的日子里"],"content":" D 双生双宿之决","date":"2025-01-23","objectID":"/posts/nc25wd1/:4:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#d-双生双宿之决"},{"categories":["在学算法的日子里"],"content":" 题意双生数组定义：数组大小为偶数，有且只有 2 种数，这两种数的数量相同。 判断一个数组是不是双生数组。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:4:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意双生数组定义：数组大小为偶数，有且只有 2 种数，这两种数的数量相同。 判断一个数组是不是双生数组。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:4:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路按性质判断即可。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:4:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; map\u003cll, ll\u003e mp; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; mp[a[i]]++; } if (mp.size() != 2) { cout \u003c\u003c \"No\\n\"; return; } vector\u003cpll\u003e v(mp.begin(), mp.end()); if (v[0].second == v[1].second) { cout \u003c\u003c \"Yes\\n\"; } else { cout \u003c\u003c \"No\\n\"; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:4:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-2"},{"categories":["在学算法的日子里"],"content":" E 双生双宿之错","date":"2025-01-23","objectID":"/posts/nc25wd1/:5:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#e-双生双宿之错"},{"categories":["在学算法的日子里"],"content":" 题意将一个数组变成双生数组，可以进行的操作是将某个数+1 或-1，求最小操作次数。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:5:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意将一个数组变成双生数组，可以进行的操作是将某个数+1 或-1，求最小操作次数。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:5:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路首先想到，将数组分为小的一半和大的一半，这两半各找一个数作为双生数组中的标准数。 这个数是中位数： 考虑当前的中位数是$x$，代表有至少一半的数小于等于$x$，也有至少一半的数大于等于$x$，如果将$x$变成$x+1$，假设原来的花费是$y$，有$c$的数小于等于$x$。那么现在的花费是$y’ = y+c-(n-c)$，由于$c\\ge n/2$，故$y’\\gt y$，$x-1$的情况也是同理。 特别的，当两边的中位数是同一个数的时候，需要对某一边进行+1 或-1，取 min。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:5:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } sort(a + 1, a + 1 + n); auto check = [\u0026](ll x, ll l, ll r) { ll tot = 0; for (ll i = l; i \u003c= r; i++) { tot += abs(x - a[i]); } return tot; }; // 左右两半各找一个中位数 ll x = a[(1 + n / 2) / 2]; ll y = a[(n / 2 + 1 + n) / 2]; ll ansx = check(x, 1, n / 2), ansy = check(y, n / 2 + 1, n); ll ans = ansx + ansy; if (x == y) { ans = inf; ans = min(ans, check(x + 1, 1, n / 2) + ansy); ans = min(ans, ansx + check(y + 1, n / 2 + 1, n)); ans = min(ans, check(x - 1, 1, n / 2) + ansy); ans = min(ans, ansx + check(y - 1, n / 2 + 1, n)); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:5:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-3"},{"categories":["在学算法的日子里"],"content":" F 双生双宿之探","date":"2025-01-23","objectID":"/posts/nc25wd1/:6:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#f-双生双宿之探"},{"categories":["在学算法的日子里"],"content":" 题意计算一个数组中有多少连续子数组是双生数组。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:6:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意计算一个数组中有多少连续子数组是双生数组。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:6:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路根据双生数组的特点，选出所有仅包含两种数的区间，在这个确定的最大的仅包含两种数的区间内计算区间中有多少个双生数组，由于仅包含两种数，可以将某种数记为 1，另一种记为-1，计算该段区间的前缀和，前缀和相同的两个端点之间的区间是双生数组。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:6:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } ll ans = 0; ll l = 1, r = 1; set\u003cll\u003e st; st.insert(a[l]); while (r \u003c= n) { // 仅包含两种元素的最远的r while (r + 1 \u003c= n \u0026\u0026 (st.size() \u003c 2 || st.find(a[r + 1]) != st.end())) { st.insert(a[++r]); } if (st.size() == 2) { // 计算区间内区间和是0的数量 ll x1 = *st.begin(); pre[l - 1] = 0; map\u003cll, ll\u003e mp; mp[0]++; for (ll i = l; i \u003c= r; i++) { if (a[i] == x1) pre[i] = pre[i - 1] + 1; else pre[i] = pre[i - 1] - 1; mp[pre[i]]++; } for (auto i : mp) { ans += (i.second - 1) * i.second / 2; } } else { break; } // 去掉一种数 while (l - 1 \u003c= r) { if (pre[r] - pre[l - 1] == r - l + 1 || pre[l - 1] - pre[r] == r - l + 1) { break; } l++; } st.clear(); st.insert(a[l]); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:6:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-4"},{"categories":["在学算法的日子里"],"content":" G 井然有序之衡","date":"2025-01-23","objectID":"/posts/nc25wd1/:7:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#g-井然有序之衡"},{"categories":["在学算法的日子里"],"content":" 题意将数组变成一个排列，可以进行的操作是将某个数+1，同时将另一个数-1，询问最小操作次数，若不能实现则输出-1。 数据范围 $1\\leq n\\leq 1e5$ $-1e9\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:7:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意将数组变成一个排列，可以进行的操作是将某个数+1，同时将另一个数-1，询问最小操作次数，若不能实现则输出-1。 数据范围 $1\\leq n\\leq 1e5$ $-1e9\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:7:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路排列中的数是 1~n，如果进行操作，一定是将大数减去的 1 加到小数上，让两个数都趋向要变成的数。从 n 开始枚举到 1，如果当前的排列数$i$在数组中不存在，则选一个大于$i$的数，将它减去的数统计到答案中，过程中判断可行性。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:7:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-6"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; ll tot = 0; multiset\u003cll, greater\u003c\u003e\u003e st; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; tot += a[i]; st.insert(a[i]); } if (tot != (1 + n) * n / 2) { cout \u003c\u003c \"-1\\n\"; return; } ll ans = 0ll, x = n; while (!st.empty() \u0026\u0026 x \u003e= 1) { if (st.find(x) != st.end()) { st.erase(st.find(x)); x--; continue; } if (*st.begin() \u003c x) break; ans += *st.begin() - x; x--; st.erase(st.begin()); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:7:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-5"},{"categories":["在学算法的日子里"],"content":" H 井然有序之窗","date":"2025-01-23","objectID":"/posts/nc25wd1/:8:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#h-井然有序之窗"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长度为 n 的排列，要求每个数$i$都符合在$[l_i,r_i]$范围内，如果不存在这样的排列，则输出-1，否则输出构造的排列。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq l_i\\leq r_i\\leq n$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:8:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长度为 n 的排列，要求每个数$i$都符合在$[l_i,r_i]$范围内，如果不存在这样的排列，则输出-1，否则输出构造的排列。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq l_i\\leq r_i\\leq n$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:8:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路按照 1~n 的顺序构造排列，每次从可以使用的区间中取右端点最近的区间。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:8:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-7"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; vector\u003cpair\u003cpll, ll\u003e\u003e v; for (ll i = 1; i \u003c= n; i++) { pll p; cin \u003e\u003e p.first \u003e\u003e p.second; v.push_back({p, i}); } // 关键字顺序l,r,id sort(v.begin(), v.end()); multiset\u003cpair\u003cll, pair\u003cpll, ll\u003e\u003e\u003e st; // 右端点r小的排在前面 ll pi = 0; for (ll x = 1; x \u003c= n; x++) { for (; pi \u003c (ll)v.size(); pi++) { pll p = v[pi].first; if (p.first \u003c= x \u0026\u0026 p.second \u003e= x) { st.insert({p.second, v[pi]}); continue; } break; } if (st.empty()) { cout \u003c\u003c \"-1\\n\"; return; } a[st.begin()-\u003esecond.second] = x; st.erase(st.begin()); while (!st.empty() \u0026\u0026 st.begin()-\u003efirst == x) { st.erase(st.begin()); } } for (ll i = 1; i \u003c= n; i++) { cout \u003c\u003c a[i] \u003c\u003c \" \\n\"[i == n]; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:8:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-6"},{"categories":["在学算法的日子里"],"content":" I 井然有序之桠","date":"2025-01-23","objectID":"/posts/nc25wd1/:9:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#i-井然有序之桠"},{"categories":["在学算法的日子里"],"content":" 题意给出排列$a$，构造另一个排列$b$，使得$\\sum_{i=1}^{n} gcd(a_i,b_i)=k$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq n$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:9:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意给出排列$a$，构造另一个排列$b$，使得$\\sum_{i=1}^{n} gcd(a_i,b_i)=k$。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq n$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:9:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路构造排列使$\\sum gcd(a_i,i)=k$，易知$k$的合法上界是$\\frac{(n+1)\\times n}{2}$，下届是$n$。从大到小遍历，找到某个端点，将数组分为$[1,r]$和$[r+1,n]$两组，右侧区间均取$a_i=i$，这个区间可以为空，找到最小的$r-1+r\\leq k’$成立的端点$r$，遍历的过程中$k$减去端点划过的值。 分类讨论，记$x=k-(r-1)$。如果$x$为偶数，则取$a_x=x$，剩余的$1,…,x-1,x+1,…r$从大到小两两一组交换，实现除了$a_x=x$的其他小组都是 1。 如果$x$为奇数，如果$r$为偶数，会出现$gcd(x-1,x+1)$，这个值是$2$，不符合要求，这时取$a_2=2$和$a_{x-1}=x-1$，可以实现与$a_x=x$一样的构造效果，注意判断$x=2$的情况。 特殊的，当$x=3$时，可以构造$a_2=4$和$a_4=2$，这时$gcd(a_2,4)+gcd(a_4,2)=4=3+1$可行。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:9:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-8"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; set\u003cll\u003e st; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; b[i] = a[i], c[a[i]] = i; st.insert(i); } if (k \u003c n) { cout \u003c\u003c \"-1\\n\"; return; } ll s = 0ll, r = n; while (r \u003e= 1) { if (k \u003c r - 1 + r) break; st.erase(r); k -= r; r--; } if (k == 0) { for (ll i = 1; i \u003c= n; i++) { cout \u003c\u003c b[i] \u003c\u003c ' '; } cout \u003c\u003c '\\n'; return; } // [r+1~n]都对应ai=i ll x = k - (r - 1); // 把a[1~r]构造成r-1+x if (x \u0026 1) { if (r \u0026 1) { st.erase(x); } else if (x - 1 \u003e 2) { st.erase(x - 1), st.erase(2); } else if (x == 3 \u0026\u0026 r \u003e= 4) { b[c[2]] = 4, b[c[4]] = 2; st.erase(2), st.erase(4); } else if (x != 1) { cout \u003c\u003c \"-1\\n\"; return; } } else { st.erase(x); } vector\u003cll\u003e v(st.begin(), st.end()); for (ll i = v.size() - 1; i - 1 \u003e= 0; i -= 2) { swap(b[c[v[i]]], b[c[v[i - 1]]]); } for (ll i = 1; i \u003c= n; i++) { cout \u003c\u003c b[i] \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:9:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-7"},{"categories":["在学算法的日子里"],"content":" J 硝基甲苯之袭","date":"2025-01-23","objectID":"/posts/nc25wd1/:10:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#j-硝基甲苯之袭"},{"categories":["在学算法的日子里"],"content":" 题意在数组中选两个元素$a_i,a_j,(i\\neq j)$，求满足$a_i \\oplus a_j = gcd(a_i,a_j)$的$i,j$对数量。 数据范围 $1\\leq n\\leq 2e5$ $1\\leq a_i\\leq 2e5$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:10:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-9"},{"categories":["在学算法的日子里"],"content":" 题意在数组中选两个元素$a_i,a_j,(i\\neq j)$，求满足$a_i \\oplus a_j = gcd(a_i,a_j)$的$i,j$对数量。 数据范围 $1\\leq n\\leq 2e5$ $1\\leq a_i\\leq 2e5$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:10:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-9"},{"categories":["在学算法的日子里"],"content":" 思路$x\\oplus y = g$，则有$y=x\\oplus g$，对每个$a_i$，枚举$g$，若有符合$g == gcd(x,x\\oplus g)$的则计入答案，答案要去掉一半重复计数的。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:10:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-9"},{"categories":["在学算法的日子里"],"content":" 代码 ll a[maxn]; // 记录每个数的因数 vector\u003cll\u003e MP[maxn]; void solve() { ll n; cin \u003e\u003e n; map\u003cll, ll\u003e mp; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; mp[a[i]]++; } ll ans = 0ll; for (ll i = 1; i \u003c= n; i++) { ll x = a[i]; for (ll g : MP[x]) { // 枚举x的因数, x^y=g -\u003e y=x^g, g=gcd(x,x^g) if (mp.count(x ^ g) \u0026\u0026 g == gcd(x, x ^ g)) { ans += mp[x ^ g]; } } } cout \u003c\u003c ans / 2 \u003c\u003c '\\n'; } void init() { for (ll i = 1; i \u003c maxn; i++) { for (ll j = i; j \u003c maxn; j += i) { MP[j].push_back(i); } } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:10:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-8"},{"categories":["在学算法的日子里"],"content":" K 硝基甲苯之魇","date":"2025-01-23","objectID":"/posts/nc25wd1/:11:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#k-硝基甲苯之魇"},{"categories":["在学算法的日子里"],"content":" 题意求一个数组中，有多少个区间$[l,r](l\\lt r)$满足区间内元素的最大公约数恰好等于它们的异或和。 数据范围 $1\\leq n\\leq 2e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:11:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-10"},{"categories":["在学算法的日子里"],"content":" 题意求一个数组中，有多少个区间$[l,r](l\\lt r)$满足区间内元素的最大公约数恰好等于它们的异或和。 数据范围 $1\\leq n\\leq 2e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:11:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-10"},{"categories":["在学算法的日子里"],"content":" 思路对于一个固定的区间$[l,r]$，其最大公约数可以用某种数据结构维护（线段树/ST 表/…），实现复杂度为$O(logn)$的查询。 区间异或和可以利用前缀异或实现，根据异或的性质$A \\oplus 0 = A$、$A\\oplus A=0$，对于数组的前缀异或($pre[i]=pre[i-1]\\oplus a[i]$)，有$a_l\\oplus a_{l+1}\\oplus \\dots \\oplus a_r=pre[r]\\oplus pre[l-1]$，提供$O(1)$的查询。 固定右端点$r$，当$l$逐渐减少，其区间$gcd$会逐渐变小，且变化的次数是 log 级别的，通过在数据结构上二分，找出这些变化的端点，并统计在这个区间中异或和是对应的 gcd 的数量的左端点，统计数量。这个异或的数量可以通过在求前缀异或数组时预处理获得，用 map 存一下每个前缀异或值出现的位置数组，查询时，二分统计$[l_l,l_r]$中$xor$为$g\\oplus pre[r]$的数量。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:11:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-10"},{"categories":["在学算法的日子里"],"content":" 代码 ll a[maxn], pre[maxn]; // ST表 ll dp[maxn][30]; void rmq_st(ll n) { for (ll i = 1; i \u003c= n; i++) { dp[i][0] = a[i]; // 2^0 } ll m = log(1 * n) / log(2.0); for (ll j = 1; j \u003c= m; j++) { ll t = n - (1 \u003c\u003c j) + 1; for (ll i = 1; i \u003c= t; i++) { dp[i][j] = gcd(dp[i][j - 1], dp[i + (1 \u003c\u003c (j - 1))][j - 1]); } } } ll rmq_find(ll l, ll r) { // 从l开始,长度为r的区间 ll k = log(1.0 * (r - l + 1)) / log(2.0); return gcd(dp[l][k], dp[r - (1 \u003c\u003c k) + 1][k]); } void solve() { ll n; cin \u003e\u003e n; map\u003cll, vector\u003cll\u003e\u003e mp; mp[0].push_back(0); for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] ^ a[i]; mp[pre[i]].push_back(i); } rmq_st(n); ll ans = 0; for (ll R = 2; R \u003c= n; R++) { // 枚举右端点 ll L = R - 1; while (L \u003e= 1) { ll g = rmq_find(L, R); ll xl = 1, xr = L; while (xl \u003c xr) { ll mid = (xl + xr) / 2; if (rmq_find(mid, R) == g) { xr = mid; } else { xl = mid + 1; } } // [xl,L]是符合rmq_find(i,R)=g的区间 ll x = g ^ pre[R]; if (mp.count(x)) { auto \u0026v = mp[x]; ans += lower_bound(v.begin(), v.end(), L) - lower_bound(v.begin(), v.end(), xl - 1); } L = xl - 1; } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:11:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-9"},{"categories":["在学算法的日子里"],"content":" L 一念神魔之耀","date":"2025-01-23","objectID":"/posts/nc25wd1/:12:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#l-一念神魔之耀"},{"categories":["在学算法的日子里"],"content":" 题意有$l$盏灯，初始状态用一个字符串表示，0表示关闭，1表示开启，每一轮操作可以操作连续的$x$个或$y$个灯，将其状态反转，询问是否存在一种操作方式让所有的灯状态相同，如果没有输出-1。 数据范围 $1\\leq T\\leq 500$ $1\\le l\\leq 500$ $1\\leq x,y\\leq \\frac{l}{3}$ 操作轮数$n\\leq l^2$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:12:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-11"},{"categories":["在学算法的日子里"],"content":" 题意有$l$盏灯，初始状态用一个字符串表示，0表示关闭，1表示开启，每一轮操作可以操作连续的$x$个或$y$个灯，将其状态反转，询问是否存在一种操作方式让所有的灯状态相同，如果没有输出-1。 数据范围 $1\\leq T\\leq 500$ $1\\le l\\leq 500$ $1\\leq x,y\\leq \\frac{l}{3}$ 操作轮数$n\\leq l^2$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:12:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-11"},{"categories":["在学算法的日子里"],"content":" 思路假设$x=y$，将灯的状态调整成全 1，可以遍历每个 0，以这些 0 为左端点反转一个长度$x$，当某个 0 的右侧空间不足一个长度$x$时显然无解。 $x\\neq y,x\\gt y$时，如果可以反转长度$x$，则在$x$上再反转一个$y$，可以得到仅反转$x-y$的效果，以此类推，直到最短的长度，这个过程也是辗转相除法的过程，最短的长度是$g=gcd(x,y)$。 尝试按照长度$g$反转所有 0 的位置，反转$s[i]=‘0’,[i,i+x-1]$中的$g$长度的部分，则需要将剩余的$[i+g,i+x-1]$的部分恢复，不定方程$ax+bx=g$一定有解，当需要恢复的区间$[l,r]$长度大于等于$y$时进行一次长度为$y$的操作，如果不足$y$则考虑边界后哦向左或者向右拓展长度为$x$，并在接下来的操作中恢复。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:12:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-11"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, x, y; string s; cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e s; ll g = gcd(x, y); s = \"1\" + s; vector\u003carray\u003cll, 2\u003e\u003e ans; auto rev = [\u0026](ll l, ll r) { for (ll i = l; i \u003c= r; i++) { s[i] = '1' - s[i] + '0'; } ans.push_back({l, r}); }; ll p = 1; while (p + g - 1 \u003c= n) { // 少于g的长度无法改变 if (s[p] == '1') { p++; continue; } // 反转接下来的g个长度子串 ll l, r; // 需要反转回去的部分 if (p + x - 1 \u003c= n) { // 反转[p,p+g-1]部分的子串 rev(p, p + x - 1); l = p + g, r = p + x - 1; } else { rev(p + g - x, p + g - 1); l = p + g - x, r = p - 1; } while (l \u003c= r) { if (r - l + 1 \u003e= y) { rev(l, l + y - 1); l += y; } else if (r + x \u003c= n) { // 向右拓展 rev(r + 1, r + x); r += x; } else { // 向左拓展 rev(l - x, l - 1); l -= x; } } p++; } if (s.find('0') != -1) { cout \u003c\u003c \"-1\\n\"; return; } cout \u003c\u003c ans.size() \u003c\u003c '\\n'; for (auto [l, r] : ans) { cout \u003c\u003c l \u003c\u003c ' ' \u003c\u003c r \u003c\u003c '\\n'; } } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:12:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-10"},{"categories":["在学算法的日子里"],"content":" M 数值膨胀之美","date":"2025-01-23","objectID":"/posts/nc25wd1/:13:0","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#m-数值膨胀之美"},{"categories":["在学算法的日子里"],"content":" 题意定义一个数组的极差是数组的最大值和最小值的差，现在有一个数组，恰好进行一次下述操作：选择一个非空区间，将区间中的数都乘以 2。求这个数组最小的极差。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:13:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#题意-12"},{"categories":["在学算法的日子里"],"content":" 题意定义一个数组的极差是数组的最大值和最小值的差，现在有一个数组，恰好进行一次下述操作：选择一个非空区间，将区间中的数都乘以 2。求这个数组最小的极差。 数据范围 $1\\leq n\\leq 1e5$ $1\\leq a_i\\leq 1e9$ ","date":"2025-01-23","objectID":"/posts/nc25wd1/:13:1","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#数据范围-12"},{"categories":["在学算法的日子里"],"content":" 思路极差是最大值减去最小值，将最大值翻倍肯定会增大极差，考虑将最小值乘 2 才能得到更小的极差，依次枚举翻倍最小值、次小值，若当前的区间是连续的，与上一个合法区间取更小的极差，维护数组的极差。 ","date":"2025-01-23","objectID":"/posts/nc25wd1/:13:2","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#思路-12"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; vector\u003carray\u003cll, 2\u003e\u003e v; multiset\u003cll\u003e mst; // 维护极差 for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; mst.insert(a[i]); v.push_back({a[i], i}); } sort(v.begin(), v.end()); ll ans = inf; set\u003cll\u003e st; // 维护已经翻倍的点 for (auto [x, i] : v) { st.insert(i); mst.erase(mst.find(x)), mst.insert(x * 2); if (*prev(st.end()) - *st.begin() + 1 == (ll)st.size()) { // 区间连续 ans = min(ans, *prev(mst.end()) - *mst.begin()); // 更新答案 } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2025-01-23","objectID":"/posts/nc25wd1/:13:3","series":["题解记录"],"tags":["2025寒假训练","算法","牛客"],"title":"2025牛客暑寒假多校训练营Day1（完結）","uri":"/posts/nc25wd1/#代码-11"},{"categories":["在学算法的日子里"],"content":" A. Alyona and a Square Jigsaw Puzzle","date":"2024-12-05","objectID":"/posts/cfround990div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#a-alyona-and-a-square-jigsaw-puzzle"},{"categories":["在学算法的日子里"],"content":" 题意Alyona按照顺时针围绕第一个拼图放置拼图，Alyona每天会按顺序放置一定数量的拼图，如果一天结束时拼图的组装部分没有任何已开始但未完成的层，Alyona会感到开心。给出每天放置拼图的数量，询问Alyona感到快乐的天数。 数据范围 $1\\leq t\\leq 500$ $1\\leq n\\leq 100$ $1\\leq a_i\\leq 100,a_1=1$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:1:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意Alyona按照顺时针围绕第一个拼图放置拼图，Alyona每天会按顺序放置一定数量的拼图，如果一天结束时拼图的组装部分没有任何已开始但未完成的层，Alyona会感到开心。给出每天放置拼图的数量，询问Alyona感到快乐的天数。 数据范围 $1\\leq t\\leq 500$ $1\\leq n\\leq 100$ $1\\leq a_i\\leq 100,a_1=1$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:1:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路检查每天完成添加拼图时的总拼图数是否恰好是一个奇数的平方数，若是则该天会感到快乐。 ","date":"2024-12-05","objectID":"/posts/cfround990div2/:1:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { cin \u003e\u003e n; ll tot = 0, ans = 0; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; tot += a[i]; ld t = sqrtl(tot); if ((ll)t \u0026 1 \u0026\u0026 t == (ll)t) { ans++; } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-12-05","objectID":"/posts/cfround990div2/:1:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#代码"},{"categories":["在学算法的日子里"],"content":" B. Replace Character","date":"2024-12-05","objectID":"/posts/cfround990div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#b-replace-character"},{"categories":["在学算法的日子里"],"content":" 题意在一个长度为$n$的字符串中，执行一次这样的操作： 选择两个索引$i,j(1\\leq i,j\\leq n)$，可以选择$i = j$。 进行赋值$s_i:=s_j$。 要求输出在进行该操作之后，字典序最小的那个字符串。 数据范围 $1\\leq t\\leq 500$ $1\\leq n\\leq 10$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:2:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意在一个长度为$n$的字符串中，执行一次这样的操作： 选择两个索引$i,j(1\\leq i,j\\leq n)$，可以选择$i = j$。 进行赋值$s_i:=s_j$。 要求输出在进行该操作之后，字典序最小的那个字符串。 数据范围 $1\\leq t\\leq 500$ $1\\leq n\\leq 10$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:2:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路将其中一个数量最少的字母改成数量最多的字母，不过这个题数据范围很小，也可以直接暴力。 ","date":"2024-12-05","objectID":"/posts/cfround990div2/:2:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { cin \u003e\u003e n; string s; cin \u003e\u003e s; map\u003cchar, ll\u003e mp; for (auto c : s) { mp[c]++; } vector\u003cpll\u003e v; for (auto i : mp) { v.push_back({i.second, i.first - 'a'}); } sort(v.begin(), v.end(), greater\u003c\u003e()); v[0].first += 1, mp[v[0].second + 'a']++; char cc = v[0].second + 'a'; v[v.size() - 1].first -= 1, mp[v[v.size() - 1].second + 'a']--; string ans; for (auto i : s) { if (mp[i]) { ans.push_back(i); mp[i]--; } else { ans.push_back(cc); } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-12-05","objectID":"/posts/cfround990div2/:2:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#代码-1"},{"categories":["在学算法的日子里"],"content":" C. Swap Columns and Find a Path","date":"2024-12-05","objectID":"/posts/cfround990div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#c-swap-columns-and-find-a-path"},{"categories":["在学算法的日子里"],"content":" 题意在一个$2\\times n$的矩阵中，从$(1,1)$走到$(2,n)$点，只能向右和向下走，每个位置上有一个$a_{i,j}$的分数，需要最大化路径上的总分。可以支持任意次这样的操作： 选择两列$i,j$，将列$i$和列$j$进行交换，即$swap(a_{1,i},a_{1,j})$和$swap(a_{2,i},a_{2,j})$. 请执行最大化路径上的数之和，并输出这个总和。 数据范围 $1\\leq t\\leq 5000$ $1\\leq n\\leq 5000$ $-10^5\\leq a_{i,j}\\leq 10^5$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:3:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意在一个$2\\times n$的矩阵中，从$(1,1)$走到$(2,n)$点，只能向右和向下走，每个位置上有一个$a_{i,j}$的分数，需要最大化路径上的总分。可以支持任意次这样的操作： 选择两列$i,j$，将列$i$和列$j$进行交换，即$swap(a_{1,i},a_{1,j})$和$swap(a_{2,i},a_{2,j})$. 请执行最大化路径上的数之和，并输出这个总和。 数据范围 $1\\leq t\\leq 5000$ $1\\leq n\\leq 5000$ $-10^5\\leq a_{i,j}\\leq 10^5$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:3:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路观察可知，选择的路径长度固定是$n+1$，由于只能向右或者向下走，实际的路径的形状一定是在第一行取前一段，再再第二行取后一段，对每列进行排序后贪心的选择最大的一组合法的数即可。 书写的时候判断转折的一列时，也可以反向先算出$2\\times n$个数的总和，再贪心的减掉$n-1$个较小的数，注意只有转折的地方一列的两个数都能取到，而其他位置的数只能取一个值。 ","date":"2024-12-05","objectID":"/posts/cfround990div2/:3:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 ll n, m; ll a[5][maxn], pre[5][maxn], b[maxn]; bool vis[maxn]; void solve() { ll n; cin \u003e\u003e n; vector\u003cpll\u003e v1, v2; for (ll k = 1; k \u003c= 2; k++) { for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[k][i]; vis[i] = false; if (k == 1) { v1.push_back({a[k][i], i}); } else { v2.push_back({a[k][i], i}); } } } sort(v1.begin(), v1.end(), greater\u003c\u003e()); sort(v2.begin(), v2.end(), greater\u003c\u003e()); ll ans = 0, cnt = 0; for (ll k = 1; k \u003c= 2; k++) { for (ll i = 1; i \u003c= n; i++) { ans += a[k][i]; } } ll p1 = n - 1, p2 = n - 1; while (cnt \u003c n - 1) { while (p1 \u003e= 0 \u0026\u0026 vis[v1[p1].second]) { p1--; } while (p2 \u003e= 0 \u0026\u0026 vis[v2[p2].second]) { p2--; } if (p1 != -1 \u0026\u0026 p2 != -1) { if (v1[p1].first \u003c v2[p2].first) { ans -= v1[p1].first; vis[v1[p1].second] = true; p1--; } else { ans -= v2[p2].first; vis[v2[p2].second] = true; p2--; } cnt++; } else if (p1 != -1) { ans -= v1[p1].first; vis[v1[p1].second] = true; p1--; cnt++; } else if (p2 != -1) { ans -= v2[p2].first; vis[v2[p2].second] = true; p2--; cnt++; } else { break; } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-12-05","objectID":"/posts/cfround990div2/:3:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#代码-2"},{"categories":["在学算法的日子里"],"content":" D. Move Back at a Cost","date":"2024-12-05","objectID":"/posts/cfround990div2/:4:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#d-move-back-at-a-cost"},{"categories":["在学算法的日子里"],"content":" 题意给出一个长度为$n$的数组$a$，可以执行如下操作： 选择一个索引$i$，将$a_i+1$添加到数组的末尾，并删去$a_i$。 可以执行这样的操作任意次，请输出字典序最小的操作之后的数组$a$。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 10^5$ $1\\leq a_i\\leq 10^9$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:4:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给出一个长度为$n$的数组$a$，可以执行如下操作： 选择一个索引$i$，将$a_i+1$添加到数组的末尾，并删去$a_i$。 可以执行这样的操作任意次，请输出字典序最小的操作之后的数组$a$。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 10^5$ $1\\leq a_i\\leq 10^9$ ","date":"2024-12-05","objectID":"/posts/cfround990div2/:4:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路尽量保留原数组中从小到达排列的数，将其中不符合单调性的点挪到数组的后面，不要让这些将挪到数组后面的数再次挪动。 维护一个全局的multiset，记录所有需要挪动的数字，将这些数+1 后依次添加到原来数组生成的有序序列的后面。 ","date":"2024-12-05","objectID":"/posts/cfround990div2/:4:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; multiset\u003cll\u003e st; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; st.insert(a[i]); } ll p = 1; multiset\u003cll\u003e v; vector\u003cll\u003e ans; while (p \u003c= n \u0026\u0026 !st.empty()) { while (p \u003c= n \u0026\u0026 a[p] != *st.begin()) { v.insert(a[p]); st.erase(st.find(a[p])); p++; } if (p \u003e n) break; ans.push_back(a[p]); st.erase(st.find(a[p])); p++; } while (!v.empty() \u0026\u0026 ans.back() \u003e *v.begin() + 1) { v.insert(ans.back()); ans.pop_back(); } for (auto i : v) { ans.push_back(i + 1); } for (auto i : ans) { cout \u003c\u003c i \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2024-12-05","objectID":"/posts/cfround990div2/:4:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 990 (Div. 2)","uri":"/posts/cfround990div2/#代码-3"},{"categories":["在学算法的日子里"],"content":" A. Profitable Interest Rate","date":"2024-11-26","objectID":"/posts/cfround980div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#a-profitable-interest-rate"},{"categories":["在学算法的日子里"],"content":" 题意有两种储值方式——无利可图和盈利，“盈利”可以保证盈利，但是有最低储值要求，“无利可图”类型没有利息，但是可以让“盈利”的最低储值降低。在“无利可图”储值$x$元，可以让“盈利”的最低值要求降低$2\\times x$元，最低储值不能低于$0$元，两种储值均不能取出。现在Alice拥有$a$元，并想使存入“盈利”的金额越多越好，求Alice最多存入多少“盈利”类型的金额。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq a,b\\leq 10^9$ ","date":"2024-11-26","objectID":"/posts/cfround980div2/:1:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意有两种储值方式——无利可图和盈利，“盈利”可以保证盈利，但是有最低储值要求，“无利可图”类型没有利息，但是可以让“盈利”的最低储值降低。在“无利可图”储值$x$元，可以让“盈利”的最低值要求降低$2\\times x$元，最低储值不能低于$0$元，两种储值均不能取出。现在Alice拥有$a$元，并想使存入“盈利”的金额越多越好，求Alice最多存入多少“盈利”类型的金额。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq a,b\\leq 10^9$ ","date":"2024-11-26","objectID":"/posts/cfround980div2/:1:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路假设存入$x$元在“无利可图”，则“盈利”的最低储值降为$b-2\\times x$，此时如果Alice的剩余金额$a-x$可以达到最低储值，则答案为$a-x$，否则为$0$，最小化$x$即可。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:1:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll a, b; cin \u003e\u003e a \u003e\u003e b; ll x = max(0ll, b - a); ll ans = max(0ll, a - x); cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-11-26","objectID":"/posts/cfround980div2/:1:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B. Buying Lemonade","date":"2024-11-26","objectID":"/posts/cfround980div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#b-buying-lemonade"},{"categories":["在学算法的日子里"],"content":" 题意柠檬水售卖机有$n$个按钮，但是无法辨认每个按钮对应的槽位还剩多少柠檬水，购买者知道每个槽位最初的柠檬水数量，每按下一个按钮，如果该按钮对应的槽位还有柠檬水，则可以售出$1$瓶柠檬水，若槽位为空，则将没有任何东西掉出来。现在需要精确购买$k$瓶柠檬水，保证柠檬水售卖机里有足够的柠檬水，即$\\sum_{i=1}^{n} a_i \\ge k$。求问最少的可以保证达成任务的点击次数。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 2\\times 10^5$ $1\\leq k\\leq 10^9$ $1\\leq a_i\\leq 10^9$ $n$之和不超过$2\\times 10^5$。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:2:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意柠檬水售卖机有$n$个按钮，但是无法辨认每个按钮对应的槽位还剩多少柠檬水，购买者知道每个槽位最初的柠檬水数量，每按下一个按钮，如果该按钮对应的槽位还有柠檬水，则可以售出$1$瓶柠檬水，若槽位为空，则将没有任何东西掉出来。现在需要精确购买$k$瓶柠檬水，保证柠檬水售卖机里有足够的柠檬水，即$\\sum_{i=1}^{n} a_i \\ge k$。求问最少的可以保证达成任务的点击次数。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 2\\times 10^5$ $1\\leq k\\leq 10^9$ $1\\leq a_i\\leq 10^9$ $n$之和不超过$2\\times 10^5$。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:2:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路基本的贪心购买思路是一直按同一个按钮，直到该槽位为空，考虑到购买$k$瓶至少需要$k$次基本点击，我们需要最小化会浪费的点击次数，即点空槽位的次数。 假设当前每个槽位都至少有$2$瓶柠檬水，我们想最小化点空的次数，最好先把每个按钮都点击$2$次，如果此时的总数足够$k$，我们就计数次数，否则去掉空槽位（通过 1 次点击去除），我们要继续最小化。 二分在每个按钮点击的次数，查询能买到的柠檬水总数，计数最少的次数，即第一个满足总数大于等于$k$的那个次数。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:2:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll a[maxn]; void solve() { ll n, k; cin \u003e\u003e n \u003e\u003e k; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } sort(a + 1, a + 1 + n); auto get_cnt = [\u0026](ll cnt) { ll ret = 0ll, tot = 0ll; for (ll i = 1; i \u003c= n; i++) { if (a[i] \u003c cnt) { if (tot + a[i] \u003c k) { ret += a[i] + 1; tot += a[i]; } else { ret += k - tot; break; } } else { if (tot + cnt \u003c k) { ret += cnt; tot += cnt; } else { ret += k - tot; break; } } } return ret; }; auto get_lemonade = [\u0026](ll cnt) { ll tot = 0ll; for (ll i = 1; i \u003c= n; i++) { if (a[i] \u003c cnt) { tot += a[i]; } else { tot += cnt; } } return tot; }; // 可以获得k的第一个次数的下标 ll l = 1, r = n; while (l \u003c r) { ll mid = l + (r - l) / 2; if (get_lemonade(a[mid]) \u003c k) { l = mid + 1; } else { r = mid; } } ll ans = get_cnt(a[l]); cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-11-26","objectID":"/posts/cfround980div2/:2:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C. Concatenation of Arrays","date":"2024-11-26","objectID":"/posts/cfround980div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#c-concatenation-of-arrays"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个二元组，将这些二元组重新排序后让序列的逆序数最小，输出排序后的结果。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 10^5$ $1\\leq a_{i,j}\\leq 10^9$ ","date":"2024-11-26","objectID":"/posts/cfround980div2/:3:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个二元组，将这些二元组重新排序后让序列的逆序数最小，输出排序后的结果。 数据范围 $1\\leq t\\leq 10^4$ $1\\leq n\\leq 10^5$ $1\\leq a_{i,j}\\leq 10^9$ ","date":"2024-11-26","objectID":"/posts/cfround980div2/:3:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路排序，将二元组按照两数之和、第一位数、第二位数的优先级顺序从小到大排序。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:3:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n; cin \u003e\u003e n; vector\u003cpll\u003e v; for (ll i = 1; i \u003c= n; i++) { pll p; cin \u003e\u003e p.first \u003e\u003e p.second; v.push_back(p); } sort(v.begin(), v.end(), [\u0026](pll p1, pll p2) { return make_tuple(p1.first + p1.second, p1.first, p1.second) \u003c make_tuple(p2.first + p2.second, p2.first, p2.second); }); for (auto i : v) { cout \u003c\u003c i.first \u003c\u003c ' ' \u003c\u003c i.second \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2024-11-26","objectID":"/posts/cfround980div2/:3:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D. Skipping","date":"2024-11-26","objectID":"/posts/cfround980div2/:4:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#d-skipping"},{"categories":["在学算法的日子里"],"content":" 题意问答系统，对第$i$个题，如果选择回答，可以获得$a_i$分数，接下来只能选择序号$j\\lt i$且没有操作过的问题。也可以选择跳过，接下来可以选择$j\\leq b_i$的未操作过的题目。从$1$号问题开始回答。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:4:1","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 思路注意到，当跳到索引$i$时，所有$1\\leq k\\leq i$的没有回答过的题目，都可以通过依次回答。我们只需要贪心的选择前置和-到达某个位置的最小代价即可。 考虑用一个全局$multiset$维护当前可以使用的代价，从$1$号问题开始，每个问题的$b_i$指向一个到$b_i+1$会“失效”的最小代价，每次移动时去除失效代价，并加入新的最小代价，维护最大得分即可。 维护时可以注意到$b_i\\leq i$的跳题没有意义，不如直接向前答题，可以通过判断去除这种移动。 ","date":"2024-11-26","objectID":"/posts/cfround980div2/:4:2","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { cin \u003e\u003e n; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] + a[i]; } for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e b[i]; } // ll ans = a[1]; multiset\u003cll\u003e st; // 可行代价 map\u003cll, vector\u003cll\u003e\u003e mp; // 存储到达i的所有可行代价 mp[2].push_back(0); st.insert(0); ll ans = a[1]; for (ll i = 1; i \u003c= n; i++) { for (auto x : mp[i]) { st.erase(st.find(x)); // 删去不再适用的代价 } if (st.empty()) { dis[i] = -1; // 没有可用的代价 } else { dis[i] = *st.begin(); } if (dis[i] == -1) continue; ans = max(ans, pre[i] - dis[i]); if (b[i] \u003c= i) continue; // 可以拓展到点b[i],b[i]+1时刻这些代价都不再适用 ll d = dis[i] + a[i]; mp[b[i] + 1].push_back(d); st.insert(d); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-11-26","objectID":"/posts/cfround980div2/:4:3","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 980 (Div. 2)","uri":"/posts/cfround980div2/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" G. Snake Move","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:1:0","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#g-snake-move"},{"categories":["在学算法的日子里"],"content":" 题意$n\\times m$的网格中有一条长度为$k$的贪吃蛇，贪吃蛇支持上下左右移动 1 格的操作，以及缩短 1 个身体长度的操作。 设$f(i,j)$为从蛇头从初始位置到达网格中点$(i,j)$所需要的最少的操作数，网格中不可到达的格子操作数设为$0$，求解输出： $$ \\sum_{i=1}^{i=n}\\sum_{j=1}^{j=m}f(i,j) $$ ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:1:1","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#题意"},{"categories":["在学算法的日子里"],"content":" 思路初始时蛇身压住的格子有一个最早释放的时间，可以通过预处理获得。 当蛇头开始移动时，蛇头经过的格子不会有更早的到达时刻，如果下一步可以到达蛇身压住的格子，绕行不可能优于直接缩短长度的操作数。 正常从蛇头进行 BFS，如果遇到初始时不被蛇身压住的格子则正常加入队列，如果遇到被压住的格子，对释放时间和当前步数取max。 ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:1:2","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include \u003cbits/stdc++.h\u003e #define x first #define y second using namespace std; typedef double ld; typedef unsigned long ul; typedef long long ll; typedef unsigned long long ull; typedef pair\u003cll, ll\u003e pll; const int maxn = 2e5 + 50; const ll inf = 0x3f3f3f3f3f3f; const vector\u003cpll\u003e dxy = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}}; ll n, m, k; char maz[3090][3090]; ull dis[3090][3090]; bool inq[3090][3090], vis[3090][3090]; map\u003cll, pll\u003e snake; map\u003cpll, ll\u003e body; bool check(pll \u0026p) { return p.x \u003e= 1 \u0026\u0026 p.x \u003c= n \u0026\u0026 p.y \u003e= 1 \u0026\u0026 p.y \u003c= m \u0026\u0026 maz[p.x][p.y] != '#'; }; void bfs(pll st) { priority_queue\u003cpair\u003cll, pll\u003e, vector\u003cpair\u003cll, pll\u003e\u003e, greater\u003c\u003e\u003e q; q.push({0ll, st}); dis[st.x][st.y] = 0ll; inq[st.x][st.y] = true; while (!q.empty()) { auto [d, p] = q.top(); q.pop(); dis[p.x][p.y] = d; for (auto [dx, dy] : dxy) { pll pi = {p.x + dx, p.y + dy}; if (!check(pi)) continue; if (inq[pi.x][pi.y]) continue; if (body.count(pi)) { ll di = max(d + 1, body[pi]); q.push({di, pi}); inq[pi.x][pi.y] = true; } else { q.push({d + 1, pi}); inq[pi.x][pi.y] = true; } } } } void solve() { cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; body.clear(); pll st; for (ll i = k - 1; i \u003e= 0; i--) { pll p; cin \u003e\u003e p.x \u003e\u003e p.y; snake[i] = p; if (i == k - 1) { st = p; body[p] = 0; } else { body[p] = i + 1; } } for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { cin \u003e\u003e maz[i][j]; dis[i][j] = inf; } } bfs(st); ull ans = 0; for (ll i = 1; i \u003c= n; i++) { for (ll j = 1; j \u003c= m; j++) { ull d = dis[i][j]; if (d == inf) d = 0; ans += d * d; } } cout \u003c\u003c fixed \u003c\u003c setprecision(0) \u003c\u003c ans \u003c\u003c '\\n'; } void init() { } int main(void) { ios::sync_with_stdio(false); cin.tie(0); init(); int _t = 1; // cin \u003e\u003e _t; // cin.get(); while (_t--) solve(); return 0; } ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:1:3","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#代码"},{"categories":["在学算法的日子里"],"content":" J. Mysterious Tree","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:2:0","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#j-mysterious-tree"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 有一棵节点数$n\\ge 4$的树，树的形状是链状或者星状，每次询问两个点$u$和$v$，会返回$(u,v)$之间是否有边，需要在$\\lceil \\frac{n}{2} \\rceil + 3$的询问次数之内确定树的形状。 ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:2:1","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#题意-1"},{"categories":["在学算法的日子里"],"content":" 思路每次询问2个没有问过的节点$(1,2),(3,4),…$如果到结束都没有问出边，此时节点数是偶数，则说明是链状，否则用三次询问确定节点$n$是否是星状的中心（询问中要有两个点之间是没有边的），若是则为星，否则为链。 问出一条边后，抉择确定这条边的两个点是否是星的中心。 ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:2:2","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n; cin \u003e\u003e n; ll t; auto ask = [\u0026](ll p1, ll p2) { cout \u003c\u003c \"? \" \u003c\u003c p1 \u003c\u003c ' ' \u003c\u003c p2 \u003c\u003c endl; cin \u003e\u003e t; }; auto conf = [\u0026](ll x) { cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c endl; }; bool flag = false; ll u = -1, v = -1; for (ll i = 1; i + 1 \u003c= n; i += 2) { ask(i, i + 1); if (t == 1) { flag = true; u = i, v = i + 1; break; } } ll t1, t2, t3; if (!flag) { if (n \u0026 1) { ask(n, 1), t1 = t; ask(n, 2), t2 = t; ask(n, 3), t3 = t; if (t1 \u0026\u0026 t2 \u0026\u0026 t3) { conf(2); } else { conf(1); } } else { conf(1); } return; } if (u - 1 \u003e= 1) { ask(u - 1, u); t1 = t; if (t1 != 1) { ask(u - 1, v); t2 = t; if (t2 != 1) { conf(1); } else { if (v + 1 \u003c= n) ask(v, v + 1); else ask(u - 2, v); t3 = t; if (t3 != 1) { conf(1); } else { conf(2); } } } else { if (u - 2 \u003e= 1) { ask(u - 2, u); } else { ask(v + 1, u); } t2 = t; if (t2 != 1) { conf(1); } else { conf(2); } } } else { ask(v, v + 1); t1 = t; if (t1 != 1) { ask(v + 1, u); t2 = t; if (t2 != 1) { conf(1); } else { ask(v + 2, u); t3 = t; if (t3 != 1) { conf(1); } else { conf(2); } } } else { ask(v, v + 2); t2 = t; if (t2 != 1) { conf(1); } else { conf(2); } } } } ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:2:3","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#代码-1"},{"categories":["在学算法的日子里"],"content":" M. V-Diagram","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:3:0","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#m-v-diagram"},{"categories":["在学算法的日子里"],"content":" 题意在 V 型数组，找一个平均值最大的连续子数组，要求子数组也成 V 型，输出平均值。 ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:3:1","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#题意-2"},{"categories":["在学算法的日子里"],"content":" 思路从最低点（pi）分别向左向右找到平均值最大的位置（lp，rp），选择区间$[lp,pi+1]$、$[pi-1,rp]$、$[lp,rp]$之中平均值最大的一个。 ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:3:2","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 const int maxn = 3e5 + 50; ll a[maxn], pre[maxn]; void solve() { ll n; cin \u003e\u003e n; ll lp, rp, pi, mna = inf; for (ll i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] + a[i]; if (mna \u003e a[i]) { pi = lp = rp = i; mna = a[i]; } } ll sum = 0, len = 0, llp = lp, rrp = rp; ld rcur = 0.0, lcur = 0.0; while (lp \u003e= 1) { sum += a[lp]; len++; if (1.0 * sum / len \u003e lcur) { lcur = 1.0 * sum / len; llp = lp; } lp -= 1; } sum = 0, len = 0; while (rp \u003c= n) { sum += a[rp]; len++; if (1.0 * sum / len \u003e rcur) { rcur = 1.0 * sum / len; rrp = rp; } rp += 1; } auto getavl = [\u0026](ll r, ll l) { return 1.0 * (pre[r] - pre[l - 1]) / (r - l + 1); }; ld ans = max(getavl(rrp, pi - 1), getavl(pi + 1, llp)); ans = max(ans, getavl(rrp, llp)); cout \u003c\u003c fixed \u003c\u003c setprecision(12) \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-11-23","objectID":"/posts/23hangzhouicpc/:3:3","series":["题解记录"],"tags":["算法"],"title":"2023杭州ICPC区域赛","uri":"/posts/23hangzhouicpc/#代码-2"},{"categories":["在学算法的日子里"],"content":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","date":"2024-10-25","objectID":"/posts/cfround977div2/","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/"},{"categories":["在学算法的日子里"],"content":" A. Meaning Mean","date":"2024-10-25","objectID":"/posts/cfround977div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#a-meaning-mean"},{"categories":["在学算法的日子里"],"content":" 题意可以选择 2 个不同的索引$i,j$，将数组中这两个索引对应的数删除，然后将$\\lfloor \\frac{a_i+a_j}{2} \\rfloor$添加到数组的最后。可知到最后只会剩下一个数，最大化最后剩余的这个数$x$，并输出。 数据范围 $2\\leq n \\leq 50$ $1\\leq a_i\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意可以选择 2 个不同的索引$i,j$，将数组中这两个索引对应的数删除，然后将$\\lfloor \\frac{a_i+a_j}{2} \\rfloor$添加到数组的最后。可知到最后只会剩下一个数，最大化最后剩余的这个数$x$，并输出。 数据范围 $2\\leq n \\leq 50$ $1\\leq a_i\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路考虑三个数$a\\lt b\\lt c$时，按照各种顺序合并的情况下，$\\lfloor \\frac{\\lfloor \\frac{a+b}{2} \\rfloor+c}{2}\\rfloor$是最好的操作。 ","date":"2024-10-25","objectID":"/posts/cfround977div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll a[maxn]; void solve() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } sort(a + 1, a + 1 + n); ll tot = a[1]; for (int i = 2; i \u003c= n; i++) { ll x = a[i]; tot = (tot + x) / 2; } cout \u003c\u003c tot \u003c\u003c '\\n'; } ","date":"2024-10-25","objectID":"/posts/cfround977div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B. Maximize Mex","date":"2024-10-25","objectID":"/posts/cfround977div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#b-maximize-mex"},{"categories":["在学算法的日子里"],"content":" 题意对一个给定的数组$a$和给定的数$x$，可以进行如下操作： 选择一个索引，$a_i:=a_i + x$。 可以执行这个操作任意次，询问这个数组最大的$MEX$值是多少。 数据范围 $1\\leq t\\leq 5000$ $1\\leq n\\leq 2\\times 10^5$ $0\\leq x\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意对一个给定的数组$a$和给定的数$x$，可以进行如下操作： 选择一个索引，$a_i:=a_i + x$。 可以执行这个操作任意次，询问这个数组最大的$MEX$值是多少。 数据范围 $1\\leq t\\leq 5000$ $1\\leq n\\leq 2\\times 10^5$ $0\\leq x\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路赛后再交发现 T 了…剪枝优化了一下。 首先容易观察到，$a_i:=a_i + x$的操作不会改变$a_i$所属的模$x$的同余系，在把$a$按照模$x$的值进行分组之后，对每个组，check 对应集合中是否能满足$[1, n-1]$的范围内的$a_i$都存在，遍历时，计数$a_i=k\\times x + (a_i \\mod x)$的$k$的数量，如果$k$从$0$到$\\lfloor \\frac{n-1}{x}\\rfloor + ((n-1) \\mod x \u003e= a_i \\mod x)$每一位都满足$\\sum_0^{k_i} cnt[k_i] \\gt k_i$，则说明同余集合中到$ki\\times x+a_i\\mod x$的值都是可以满足的。 最后检测一下$vis$数组，寻找$mex$。 ","date":"2024-10-25","objectID":"/posts/cfround977div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll a[maxn]; bool vis[maxn]; void solve() { ll n, x; cin \u003e\u003e n \u003e\u003e x; for (int i = 0; i \u003c= n; i++) { vis[i] = false; } map\u003cll, vector\u003cll\u003e\u003e mp; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; mp[a[i] % x].push_back(a[i]); } for (auto \u0026[i, v] : mp) { sort(v.begin(), v.end()); ll tot = (n - 1) / x; if ((n - 1) % x \u003e= i) tot += 1; vector\u003cll\u003e cnt(tot, 0); for (auto j : v) { if ((j - i) / x \u003c tot) { cnt[(j - i) / x]++; } else { break; } } ll sum = 0ll; for (int j = 0; j \u003c tot; j++) { sum += cnt[j]; if (sum \u003c= j) { break; } vis[j * x + i] = true; } } for (int i = 0; i \u003c= n; i++) { if (!vis[i]) { cout \u003c\u003c i \u003c\u003c '\\n'; return; } } } ","date":"2024-10-25","objectID":"/posts/cfround977div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C. Adjust The Presentation (Easy Version \u0026\u0026 Hard Version)","date":"2024-10-25","objectID":"/posts/cfround977div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#c-adjust-the-presentation-easy-version--hard-version"},{"categories":["在学算法的日子里"],"content":" 题意$n$个人排成一队，依次播放$m$张幻灯片，当一个人播放过幻灯片之后，可以重新将他插入任意的位置，或者留在队首播放下一张幻灯片。每张幻灯片都有一个最佳播放者，如果所有的幻灯片都由其最佳播放者播放，则整个播放是完美的，输出YA，否则输出TIDAK。询问是否可以通过调整，使得所有的幻灯片都完美播放。 同时支持$q$次修改幻灯片的最佳播放者，询问每次修改之后的播放效果，输出YA或TIDAK。 数据范围 $1 \\leq t\\leq 10^4$ $1\\leq n,m \\leq 2\\times 10^5$ $0\\leq q\\leq 2\\times 10^5$ $1\\leq a_i,b_i\\leq n$ $1\\leq s_i\\leq m,1\\leq t_i\\leq n$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意$n$个人排成一队，依次播放$m$张幻灯片，当一个人播放过幻灯片之后，可以重新将他插入任意的位置，或者留在队首播放下一张幻灯片。每张幻灯片都有一个最佳播放者，如果所有的幻灯片都由其最佳播放者播放，则整个播放是完美的，输出YA，否则输出TIDAK。询问是否可以通过调整，使得所有的幻灯片都完美播放。 同时支持$q$次修改幻灯片的最佳播放者，询问每次修改之后的播放效果，输出YA或TIDAK。 数据范围 $1 \\leq t\\leq 10^4$ $1\\leq n,m \\leq 2\\times 10^5$ $0\\leq q\\leq 2\\times 10^5$ $1\\leq a_i,b_i\\leq n$ $1\\leq s_i\\leq m,1\\leq t_i\\leq n$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路幻灯片$i$是否能被最佳播放者播放，只需要保证其播放者$s_i$在播放$i$时或之前出现，也就是说，如果数组$b$中每个编号最先出现的次序排序后，若恰好是$a$的前缀，则是可以满足的。 差分数组计数$a$数组中第$i$个数$a[i]$在$b$中最先出现次序排序后的次序是否大于等于前一个数，即是否上升。利用$set$更新$b$中每个编号最先出现的位置。 每次$b_{s_i}:=t_i$操作后，更新检查编号$b[s_i]$前后编号的新次序是否合法（与$a$中$b[s_i]$的前一位置的编号的最早位置相比是否上升），编号$t_i$前后是否合法，更新$diff$数组和$sum$值。 ll a[maxn], b[maxn], pos[maxn], diff[maxn]; vector\u003cset\u003cll\u003e\u003e st; void YorT(bool f) { f ? cout \u003c\u003c \"YA\\n\" : cout \u003c\u003c \"TIDAK\\n\"; } void solve() { int n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; st.assign(n + 1, set\u003cll\u003e()); for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; pos[a[i]] = i; st[i].insert(m + 1); diff[i] = 0; } for (int i = 1; i \u003c= m; i++) { cin \u003e\u003e b[i]; st[b[i]].insert(i); } auto check = [\u0026](int s) { // 检查a[s-1] -\u003e a[s]的合法情况,是否上升 if (s == 1 || s \u003e n) return 0; int res = 0; if (diff[s] \u0026\u0026 !(*st[a[s - 1]].begin() \u003c= *st[a[s]].begin())) { diff[s] = 0; res = -1; } else if (!diff[s] \u0026\u0026 *st[a[s - 1]].begin() \u003c= *st[a[s]].begin()) { diff[s] = 1; res = 1; } return res; }; ll sum = 0ll; for (int i = 2; i \u003c= n; i++) { sum += check(i); } YorT(sum == n - 1); while (q--) { int s, t; cin \u003e\u003e s \u003e\u003e t; st[b[s]].erase(s); st[t].insert(s); sum += check(pos[b[s]]) + check(pos[b[s]] + 1) + check(pos[t]) + check(pos[t] + 1); b[s] = t; YorT(sum == n - 1); } } ","date":"2024-10-25","objectID":"/posts/cfround977div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" D. Boss, Thirsty","date":"2024-10-25","objectID":"/posts/cfround977div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#d-boss-thirsty"},{"categories":["在学算法的日子里"],"content":" E1. Digital Village (Easy Version) \u0026\u0026 (Hard Version)","date":"2024-10-25","objectID":"/posts/cfround977div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#e1-digital-village-easy-version--hard-version"},{"categories":["在学算法的日子里"],"content":" 题意居民房屋构成一个无向图，包含$n$个点$m$条边，其中$p$户需要网络服务，可以在任意的房屋中安置交换机，房屋$s_i$与交换机所在房屋$s_j$之间的延迟是$s_i$到$s_j$的简单路径上最大的延迟。可以任意选择放置交换机的位置，询问在逐渐增加交换机的过程中，所有需要网络服务的居民的最小总延迟。 数据范围 $1\\leq t \\leq 2000$ $2\\leq n,\\leq 5000$ $n-1\\leq m \\leq 5000$ $1\\leq p \\leq n$ $1\\leq s\\leq n$ $1\\leq u_i\\lt w_i\\leq n;1\\leq w_i\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意居民房屋构成一个无向图，包含$n$个点$m$条边，其中$p$户需要网络服务，可以在任意的房屋中安置交换机，房屋$s_i$与交换机所在房屋$s_j$之间的延迟是$s_i$到$s_j$的简单路径上最大的延迟。可以任意选择放置交换机的位置，询问在逐渐增加交换机的过程中，所有需要网络服务的居民的最小总延迟。 数据范围 $1\\leq t \\leq 2000$ $2\\leq n,\\leq 5000$ $n-1\\leq m \\leq 5000$ $1\\leq p \\leq n$ $1\\leq s\\leq n$ $1\\leq u_i\\lt w_i\\leq n;1\\leq w_i\\leq 10^9$ ","date":"2024-10-25","objectID":"/posts/cfround977div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路","date":"2024-10-25","objectID":"/posts/cfround977div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码","date":"2024-10-25","objectID":"/posts/cfround977div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","uri":"/posts/cfround977div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":"区间动态规划一般以区间作为动态规划的阶段。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:0:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#"},{"categories":["在学算法的日子里"],"content":" [P1880]石子合并","date":"2024-09-11","objectID":"/posts/intervaldp/:1:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#p1880石子合并"},{"categories":["在学算法的日子里"],"content":" 题目描述在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。 试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。 输入格式 数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。 第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。 输出格式 输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。 样例 #1 样例输入 #1 4 4 5 9 4 样例输出 #1 43 54 提示 $1\\leq N\\leq 100$，$0\\leq a_i\\leq 20$​。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:1:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述"},{"categories":["在学算法的日子里"],"content":" 思路考虑状态转移： 每次合并区间$[l,r]$时，可以由区间$[l,k]$和$[k+1,r]$的状态转移过来，记$f(i,j)$是合并区间$[i,j]$的最大得分，$sum(i,j)$是合并$[i,j]$的得分，则有： $$ f(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+sum(i,j)) $$ 此题考虑到是环形数组，可以将数组复制一倍，枚举区间长度是$n$的最优值。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:1:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 250; const int mo109 = 1000000007; ll a[maxn]; ll f1[maxn][maxn], f2[maxn][maxn]; ll pre[maxn]; ll sum(int l, int r) { return pre[r] - pre[l - 1]; } void solve() { int n;cin \u003e\u003e n; pre[0] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; pre[i] = a[i] + pre[i - 1]; } for (int i = n + 1;i \u003c= 2 * n;i++) { pre[i] = a[i - n] + pre[i - 1]; } for (int i = 0;i \u003c= 2 * n;i++) { for (int j = 0;j \u003c= 2 * n;j++) { f2[i][j] = f1[i][j] = 0; } } for (int len = 1;len \u003c= n;len++) { for (int i = 1;i + len \u003c= 2 * n;i++) { int j = len + i - 1; for (int k = i;k \u003c j;k++) { if (!f1[i][j])f1[i][j] = f1[i][k] + f1[k + 1][j] + sum(i, j); else f1[i][j] = min(f1[i][j], f1[i][k] + f1[k + 1][j] + sum(i, j)); f2[i][j] = max(f2[i][j], f2[i][k] + f2[k + 1][j] + sum(i, j)); } } } ll mx = 0, mn = 1e18; for (int i = 1;i \u003c= n;i++) { int j = i + n - 1; mx = max(mx, f2[i][j]); mn = min(mn, f1[i][j]); } cout \u003c\u003c mn \u003c\u003c '\\n' \u003c\u003c mx \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:1:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码"},{"categories":["在学算法的日子里"],"content":" [P3146]248G","date":"2024-09-11","objectID":"/posts/intervaldp/:2:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#p3146248g"},{"categories":["在学算法的日子里"],"content":" 题面翻译给定一个 $1\\ \\times n$ 的地图，在里面玩 $2048$，每次可以合并相邻两个（数值范围 $1\\sim 40$），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是 $+1$，例如 $2$ 与 $2$ 合并后的数值为 $3$。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:2:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题面翻译"},{"categories":["在学算法的日子里"],"content":" 题目描述Bessie likes downloading games to play on her cell phone, even though she doesfind the small touch screen rather cumbersome to use with her large hooves. She is particularly intrigued by the current game she is playing.The game starts with a sequence of $N$ positive integers ($2 \\leq N\\leq 248$), each in the range $1 \\ldots 40$. In one move, Bessie cantake two adjacent numbers with equal values and replace them a singlenumber of value one greater (e.g., she might replace two adjacent 7swith an 8). The goal is to maximize the value of the largest numberpresent in the sequence at the end of the game. Please help Bessiescore as highly as possible! 输入格式 The first line of input contains $N$, and the next $N$ lines give the sequence of $N$ numbers at the start of the game. 输出格式 Please output the largest integer Bessie can generate. 样例 #1 样例输入 #1 4 1 1 1 2 样例输出 #1 3 提示 In this example shown here, Bessie first merges the second and third 1s to obtain the sequence 1 2 2, and then she merges the 2s into a 3. Note that it is not optimal to join the first two 1s. ","date":"2024-09-11","objectID":"/posts/intervaldp/:2:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 思路区间dp，考虑转移： $$ f(i,j)=f(i,k)+1\\quad when:f(i,k)=f(k+1,j) $$ 同时要保证$f(i,k)$和$f(k+1,j)$在向$f(i,j)$转移之前，已经进行了\"合并\"。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:2:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 550; const int mo109 = 1000000007; int a[maxn]; int f[maxn][maxn]; void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } for (int i = 0;i \u003c= n;i++) { for (int j = 0;j \u003c= n;j++) { f[i][j] = 0; } if (i) f[i][i] = a[i]; } for (int len = 1;len \u003c= n;len++) { for (int i = 1;i + len - 1 \u003c= n;i++) { int j = i + len - 1; for (int k = i;k + 1 \u003c= j;k++) { if (f[i][k] == f[k + 1][j] \u0026\u0026 f[i][k]) { f[i][j] = max(f[i][j], f[i][k] + 1); } } } } int ans = a[1]; for (int i = 1;i \u003c= n;i++) { for (int j = i;j \u003c= n;j++) { ans = max(ans, f[i][j]); } } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:2:4","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码-1"},{"categories":["在学算法的日子里"],"content":" [NOIP2006 提高组] 能量项链","date":"2024-09-11","objectID":"/posts/intervaldp/:3:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#noip2006-提高组-能量项链"},{"categories":["在学算法的日子里"],"content":" 题目描述在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \\times r \\times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。 需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。 例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\\oplus$ 表示两颗珠子的聚合操作，$(j \\oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为： $(4 \\oplus 1)=10 \\times 2 \\times 3=60$。 这一串项链可以得到最优值的一个聚合顺序所释放的总能量为： $(((4 \\oplus 1) \\oplus 2) \\oplus 3)=10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710$。 输入格式 第一行是一个正整数 $N$（$4 \\le N \\le 100$），表示项链上珠子的个数。第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$。第 $i$ 个数为第 $i$ 颗珠子的头标记（$1 \\le i \\le N$），当 $i\u003cN$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记。第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。 至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。 输出格式 一个正整数 $E$（$E\\le 2.1 \\times 10^9$），为一个最优聚合顺序所释放的总能量。 样例 #1 样例输入 #1 4 2 3 5 10 样例输出 #1 710 提示 NOIP 2006 提高组 第一题 ","date":"2024-09-11","objectID":"/posts/intervaldp/:3:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 思路将数组处理成环形数组，考虑转移： $$ f(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+head[i]\\times tail[k]\\times tail[j]) $$ 枚举长度为$n$的区间，获得最大值。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:3:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 550; const int mo109 = 1000000007; ll h[maxn], t[maxn]; ll f[maxn][maxn]; void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e h[i]; t[i - 1] = h[i]; } for (int i = n + 1;i \u003c= 2 * n;i++) { h[i] = h[i - n]; t[i - 1] = t[i - 1 - n]; } t[2 * n] = t[n]; for (int i = 0;i \u003c= 2 * n;i++) { for (int j = 0;j \u003c= 2 * n;j++) { f[i][j] = 0; } } for (int len = 1;len \u003c= n;len++) { for (int i = 1;i + len - 1 \u003c= 2 * n;i++) { int j = i + len - 1; for (int k = i;k + 1 \u003c= j;k++) { f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + h[i] * t[k] * t[j]); } } } ll ans = 0; for (int i = 1;i \u003c= n;i++) { int j = i + n - 1; ans = max(ans, f[i][j]); } cout \u003c\u003c ans \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:3:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码-2"},{"categories":["在学算法的日子里"],"content":" [NOIP2007 提高组] 矩阵取数游戏","date":"2024-09-11","objectID":"/posts/intervaldp/:4:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#noip2007-提高组-矩阵取数游戏"},{"categories":["在学算法的日子里"],"content":" 题目描述帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \\times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下： 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素； 每次取走的各个元素只能是该元素所在行的行首或行尾； 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从 $1$ 开始编号）； 游戏结束总得分为 $m$ 次取数得分之和。 帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。 输入格式 输入文件包括 $n+1$ 行： 第一行为两个用空格隔开的整数 $n$ 和 $m$。 第 $2\\sim n+1$ 行为 $n \\times m$ 矩阵，其中每行有 $m$ 个用单个空格隔开的非负整数。 输出格式 输出文件仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。 样例 #1 样例输入 #1 2 3 1 2 3 3 4 2 样例输出 #1 82 提示 【数据范围】 对于 $60%$ 的数据，满足 $1\\le n,m\\le 30$，答案不超过 $10^{16}$。 对于 $100%$ 的数据，满足 $1\\le n,m\\le 80$，$0\\le a_{i,j}\\le1000$。 【题目来源】 NOIP 2007 提高第三题。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:4:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 思路设置$f(i,j)$表示取区间$[i,j]$获得的最大得分，根据题意可知，每行的最大值之间并不相关，可以分别计算每行取数得分的最大值再相加，注意此题涉及到高精度。 考虑转移： $f(i,j)$可以由两种状态转移而来，一种是先取$a[i]$，再取$f(i+1,j)$，这时的得分是$f(i+1,j)\\times 2 + a[i]\\times 2$；另一种是先取$a[j]$，再取$f(i,j-1)$，这时的得分是$f(i,j-1)\\times 2+a[j]\\times 2$。两者取较大值即可。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:4:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 550; const int mo109 = 1000000007; const ll mo118 = 1e18; struct int128 { ll hig, low; int128 operator+(const int128\u0026 b)const { int128 k = { 0ll,0ll }; k.low = low + b.low; k.hig = k.low / mo118 + hig + b.hig; k.low %= mo118; return k; } int128 operator*(const int\u0026 b)const { int128 k = { 0ll,0ll }; k.low = b * low; k.hig = k.low / mo118 + hig * b; k.low %= mo118; return k; } void output() { if (!hig)cout \u003c\u003c low; else cout \u003c\u003c hig \u003c\u003c setw(18) \u003c\u003c setfill('0') \u003c\u003c low; } }; bool leq(int128 a, int128 b) { if (a.hig != b.hig)return a.hig \u003c b.hig; return a.low \u003c b.low; } int128 a[maxn][maxn]; int128 f[maxn][maxn]; void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { cin \u003e\u003e a[i][j].low; a[i][j].hig = 0ll; } } int128 ans = { 0ll,0ll }; for (int ni = 1;ni \u003c= n;ni++) { for (int i = 1;i \u003c= m;i++) { for (int j = 1;j \u003c= m;j++) { f[i][j] = { 0ll,0ll }; } } for (int len = 1;len \u003c= m;len++) { for (int i = 1;i + len - 1 \u003c= m;i++) { int j = i + len - 1; int128 na = (f[i + 1][j] + a[ni][i]) * 2; int128 nb = (f[i][j - 1] + a[ni][j]) * 2; f[i][j] = max(na, nb, leq); } } ans = ans + f[1][m]; } ans.output(); } int main() { // ios::sync_with_stdio(false); // cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:4:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码-3"},{"categories":["在学算法的日子里"],"content":" [CQOI2007] 涂色","date":"2024-09-11","objectID":"/posts/intervaldp/:5:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#cqoi2007-涂色"},{"categories":["在学算法的日子里"],"content":" 题目描述假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\\texttt{RGBGR}$。 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\\texttt{RRRRR}$，第二次涂成 $\\texttt{RGGGR}$，第三次涂成 $\\texttt{RGBGR}$，达到目标。 用尽量少的涂色次数达到目标。 输入格式 输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。 输出格式 仅一行，包含一个数，即最少的涂色次数。 样例 #1 样例输入 #1 AAAAA 样例输出 #1 1 样例 #2 样例输入 #2 RGBGR 样例输出 #2 3 提示 $40%$ 的数据满足 $1\\le n\\le 10$。 $100%$ 的数据满足 $1\\le n\\le 50$。 ","date":"2024-09-11","objectID":"/posts/intervaldp/:5:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 思路设$f(i,j)$表示完成区间$[i,j]$的最小涂色次数。取$i\\leq k\\lt j$则$f(i,j)$可以由$f(i,k)$和$f(k+1,j)$合并转移而来，转移时，若$s[k]=s[k+1]$，显然在区间$[i,k]$中涂位置$k$和涂位置$k+1$可以是同一步操作；若$s[i]=s[j]$，则涂位置$i$和$j$也可以是同一步操作，则转移方程如下： $$ f(i,j)=f(i,k)+f(k+1,j)-(s[i]==s[j] \\or s[k]==s[k+1]) $$ ","date":"2024-09-11","objectID":"/posts/intervaldp/:5:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 550; const int mo109 = 1000000007; const ll mo118 = 1e18; ll f[maxn][maxn]; void solve() { string s;cin \u003e\u003e s; int n = s.size(); s = \" \" + s; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { f[i][j] = 1e18; } f[i][i] = 1; } for (int len = 1;len \u003c= n;len++) { for (int i = 1;i + len - 1 \u003c= n;i++) { int j = i + len - 1; // f[i][j]:完成[i,j]区间涂色的最小涂色次数 for (int k = i;k + 1 \u003c= j;k++) { if (s[k] == s[k + 1] || s[i] == s[j]) f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] - 1); else f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } } } cout \u003c\u003c f[1][n] \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:5:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码-4"},{"categories":["在学算法的日子里"],"content":" [SCOI2003] 字符串折叠","date":"2024-09-11","objectID":"/posts/intervaldp/:6:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#scoi2003-字符串折叠"},{"categories":["在学算法的日子里"],"content":" 题目描述折叠的定义如下： 一个字符串可以看成它自身的折叠。记作 S = S X(S) 是 $X$ 个 S 连接在一起的串的折叠。记作 X(S) = SSSS…S。 如果 A = A’, B = B’，则 AB = A’B’ 。例如：因为 3(A) = AAA, 2(B) = BB，所以 3(A)C2(B) = AAACBB，而 2(3(A)C)2(B) = AAACAAACBB 给一个字符串，求它的最短折叠。 例如 AAAAAAAAAABABABCCD 的最短折叠为：9(A)3(AB)CCD。 输入格式 仅一行，即字符串 S，长度保证不超过 $100$。 输出格式 仅一行，即最短的折叠长度。 样例 #1 样例输入 #1 NEERCYESYESYESNEERCYESYESYES 样例输出 #1 14 提示 一个最短的折叠为：2(NEERC3(YES)) ","date":"2024-09-11","objectID":"/posts/intervaldp/:6:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 思路设$f(i,j)$是区间$[i,j]$折叠之后的最短长度，如果区间$[i,j]$可以被折叠，则状态转移： $$ f(i,j)=max(f(i,j),f(i,k)+2+Len((j-i+1)/(k-i+1))) $$ ","date":"2024-09-11","objectID":"/posts/intervaldp/:6:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef pair\u003cint, int\u003e pii; const int maxn = 550; const int mo109 = 1000000007; const ll mo118 = 1e18; string s; int n; ll f[maxn][maxn]; ll ff[maxn][maxn]; int Len(int x) { if (x == 1)return -2; int res = 0; while (x) { res++; x /= 10; } return res; } bool check(int l, int r, int p) { for (int i = l + p;i \u003c= r;i++) { if (s[i] == s[(i - l) % p + l])continue; return false; } return true; } void solve() { cin \u003e\u003e s; n = s.size(); s = \" \" + s; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { f[i][j] = max(0, j - i + 1); // S=S' } f[i][i] = 1; } for (int len = 2;len \u003c= n;len++) { // 区间长度是len for (int i = 1;i + len - 1 \u003c= n;i++) { int j = i + len - 1; for (int k = i;k + 1 \u003c= j;k++) { f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]); } for (int d = 1;d + i - 1 \u003c j;d++) { if (len % d)continue; // [i,j]按照长度d进行折叠 int k = d + i - 1; if (check(i, j, d)) { f[i][j] = min(f[i][j], f[i][k] + 2 + Len(len / d)); } } } } cout \u003c\u003c f[1][n] \u003c\u003c '\\n'; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-09-11","objectID":"/posts/intervaldp/:6:3","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||区间动态规划","uri":"/posts/intervaldp/#代码-5"},{"categories":["在学算法的日子里"],"content":" 前言 痛定思痛练习线段树QAQ。 此篇包含尚未写完的题，事实上是一个TODO List。 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:0:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#"},{"categories":["在学算法的日子里"],"content":" TODO List Atlantis P5490 【模板】扫描线 \u0026 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) I Hate It 覆盖的面积 敌兵布阵 P4588 TJOI2018 数学计算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 单峰数列 ✅ 2024-09-26 树上询问 P1502 窗口的星星 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P2471 SCOI2007 降雨量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-08-16","objectID":"/posts/segtree_practice/:0:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#todo-list"},{"categories":["在学算法的日子里"],"content":" Atlantis \u0026 P5490 扫描线矩形面积并Problem - 1542 (hdu.edu.cn) ","date":"2024-08-16","objectID":"/posts/segtree_practice/:1:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#atlantis--p5490-扫描线矩形面积并"},{"categories":["在学算法的日子里"],"content":" 题意给出$x_1,y_1,x_2,y_2$，标志平面内的矩形的左上角坐标$(x_1,y_1)$和右下角坐标$(x_2,y_2)$​​，求这些矩形覆盖的总面积。 输出格式参照样例。 数据范围 $0\\leq n\\leq 100$ $0\\leq x_1\\lt x_2\\leq 10^5$ $0\\leq y_1\\lt y_2\\leq 10^5$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:1:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#题意"},{"categories":["在学算法的日子里"],"content":" 题意给出$x_1,y_1,x_2,y_2$，标志平面内的矩形的左上角坐标$(x_1,y_1)$和右下角坐标$(x_2,y_2)$​​，求这些矩形覆盖的总面积。 输出格式参照样例。 数据范围 $0\\leq n\\leq 100$ $0\\leq x_1\\lt x_2\\leq 10^5$ $0\\leq y_1\\lt y_2\\leq 10^5$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:1:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路记录每个矩阵的上下边，并给下边沿标记$1$，上边沿标记$-1$，扫描线从下向上扫描。 记录每条线的左右端点的$x$坐标，去重后进行离散化，用$X[]$数组记录出现过的$x$坐标，并做去重。 在去重之后的$X[]$数组上建立线段树（不包含最右侧端点），线段树中的每个节点记录该段节点代表的线段的左右端点在$X[]$中的下标，之后若该线段被覆盖，该节点代表的长度就是$X[posr+1]- X[posl]$，初始时每个节点记录的长度都是$0$（初始时均未被覆盖）。 扫描线从下到上扫描，每次都是先遇到某个矩阵的下边沿（标记为$1$的边），然后再遇到上边沿（标记为$-1$的边）。对于每次加边，更新线段树上的节点，当前被覆盖的长度$\\times$当前扫描线与下一条扫描线的高度差即为这一部分的面积。 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:1:2","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 2050; struct line { int typ; double s, t, y; bool operator\u003c(const line\u0026 l)const { return y \u003c l.y; // 按照横坐标升序排序 } }line[maxn * 2]; struct node { int l, r; int cnt; double len; }tree[maxn * 4]; double X[maxn * 2]; void build(int p, int l, int r) { tree[p] = { l,r,0,0 }; if (l == r)return; int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); } void pushup(int p) { int l = tree[p].l, r = tree[p].r; if (tree[p].cnt) { // 有覆盖 tree[p].len = X[r + 1] - X[l]; } else { tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len; } } void editTree(int p, double l, double r, int c) { // 要修改的x区间:[l,r] int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标 if (X[pl] \u003e= l \u0026\u0026 X[pr + 1] \u003c= r) { // 包含 tree[p].cnt += c; pushup(p); return; } if (l \u003e= X[pr + 1] || r \u003c= X[pl]) return; editTree(p * 2, l, r, c); editTree(p * 2 + 1, l, r, c); pushup(p); } int n; int cas; void solve() { cout \u003c\u003c \"Test case #\" \u003c\u003c ++cas \u003c\u003c \"\\n\"; set\u003cdouble\u003eXs; for (int i = 1;i \u003c= n;i++) { double x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; line[i] = { 1,x1,x2,y1 }; // 下边 line[i + n] = { -1,x1,x2,y2 }; // 上边 Xs.insert(x1), Xs.insert(x2); // 离散化 } sort(line + 1, line + 1 + 2 * n); int t = 0; for (auto p : Xs) { X[++t] = p; } build(1, 1, t - 1); // 对离散化的X轴建树 double ans = 0.0; for (int i = 1;i \u003c 2 * n;i++) { // 最后一条扫描线不用计入统计 editTree(1, line[i].s, line[i].t, line[i].typ); ans += tree[1].len * (line[i + 1].y - line[i].y); } cout \u003c\u003c \"Total explored area: \" \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { // ios::sync_with_stdio(false); // cin.tie(0); while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } 稍微修改一下上一题的代码就能过这个题：P5490 【模板】扫描线 \u0026 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码： #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 1e6 + 50; struct line { int typ; ll s, t, y; bool operator\u003c(const line\u0026 l)const { return y \u003c l.y; // 按照横坐标升序排序 } }line[maxn * 2]; struct node { int l, r; int cnt; ll len; }tree[maxn * 4]; ll X[maxn * 2]; void build(int p, int l, int r) { tree[p] = { l,r,0,0 }; if (l == r)return; int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); } void pushup(int p) { int l = tree[p].l, r = tree[p].r; if (tree[p].cnt) { // 有覆盖 tree[p].len = X[r + 1] - X[l]; } else { tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len; } } void editTree(int p, ll l, ll r, int c) { // 要修改的x区间:[l,r] int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标 if (X[pl] \u003e= l \u0026\u0026 X[pr + 1] \u003c= r) { // 包含 tree[p].cnt += c; pushup(p); return; } if (l \u003e= X[pr + 1] || r \u003c= X[pl]) return; editTree(p * 2, l, r, c); editTree(p * 2 + 1, l, r, c); pushup(p); } void solve() { int n;cin \u003e\u003e n; set\u003cll\u003eXs; for (int i = 1;i \u003c= n;i++) { ll x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; line[i] = { 1,x1,x2,y1 }; // 下边 line[i + n] = { -1,x1,x2,y2 }; // 上边 Xs.insert(x1), Xs.insert(x2); // 离散化 } sort(line + 1, line + 1 + 2 * n); int t = 0; for (auto p : Xs) { X[++t] = p; } build(1, 1, t - 1); // 对离散化的X轴建树 ll ans = 0ll; for (int i = 1;i \u003c 2 * n;i++) { // 最后一条扫描线不用计入统计 editTree(1, line[i].s, line[i].t, line[i].typ); ans += tree[1].len * (line[i + 1].y - line[i].y); } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.tie(0); while (t--) solve(); return 0; } ","date":"2024-08-16","objectID":"/posts/segtree_practice/:1:3","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#代码"},{"categories":["在学算法的日子里"],"content":" I Hate ItI Hate It ","date":"2024-08-16","objectID":"/posts/segtree_practice/:2:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#i-hate-it"},{"categories":["在学算法的日子里"],"content":" 题意老师想询问学生中从某某到某某分数最高的是多少，并支持修改单个学生的成绩。 数据范围$0\\lt n\\leq 200000$ $0\\lt m\\leq 5000$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:2:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意老师想询问学生中从某某到某某分数最高的是多少，并支持修改单个学生的成绩。 数据范围$0\\lt n\\leq 200000$ $0\\lt m\\leq 5000$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:2:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路建树，节点记录最大值，单点修改。注意多组读入 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:2:2","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; const int mo109 = 1000000007; const int mo998 = 998244353; struct node { int mxval; }tree[maxn \u003c\u003c 2]; int n, m; int a[maxn]; void build(int l, int r, int p) { if (l == r) { tree[p] = { a[l] }; return; } int mid = l + (r - l) / 2; build(l, mid, p * 2); build(mid + 1, r, p * 2 + 1); tree[p].mxval = max(tree[p * 2].mxval, tree[p * 2 + 1].mxval); } void pushdown(int p) { tree[p].mxval = max(tree[p * 2].mxval, tree[p * 2 + 1].mxval); } void update(int cl, int cr, int p, int lr, int newval) { if (cl == cr \u0026\u0026 cl == lr) { a[cl] = newval; tree[p] = { newval }; return; } int mid = cl + (cr - cl) / 2; if (lr \u003c= mid) { update(cl, mid, p * 2, lr, newval); } else { update(mid + 1, cr, p * 2 + 1, lr, newval); } pushdown(p); } int query(int cl, int cr, int p, int l, int r) { if (cl \u003e= l \u0026\u0026 cr \u003c= r) { return tree[p].mxval; } int mid = cl + (cr - cl) / 2; int mx = -1; if (mid \u003e= l) { int x = query(cl, mid, p * 2, l, r); mx = max(x, mx); } if (mid + 1 \u003c= r) { int x = query(mid + 1, cr, p * 2 + 1, l, r); mx = max(mx, x); } return mx; } void solve() { // cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } build(1, n, 1); while (m--) { char c;cin \u003e\u003e c; int a, b;cin \u003e\u003e a \u003e\u003e b; if (c == 'Q') { cout \u003c\u003c query(1, n, 1, a, b) \u003c\u003c '\\n'; } else { update(1, n, 1, a, b); } } } int main() { ios::sync_with_stdio(0); cin.tie(0); int _ = 1; // cin \u003e\u003e _;cin.get(); while (cin \u003e\u003e n \u003e\u003e m) solve(); return 0; } ","date":"2024-08-16","objectID":"/posts/segtree_practice/:2:3","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#代码-1"},{"categories":["在学算法的日子里"],"content":" 覆盖的面积覆盖的面积 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:3:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#覆盖的面积"},{"categories":["在学算法的日子里"],"content":" 题意给定平面上的矩阵，求出被这些矩阵覆盖至少两次的区域面积。 数据范围$1\\leq N\\leq 1000$ $0\\leq x_i,y_i\\leq 100000$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:3:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给定平面上的矩阵，求出被这些矩阵覆盖至少两次的区域面积。 数据范围$1\\leq N\\leq 1000$ $0\\leq x_i,y_i\\leq 100000$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:3:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路扫描线求矩形并，在求并时统计更新被覆盖的次数，在pushup的时候，当父节点已有一次覆盖，而子区间已经被包含一次，则子区间已经被包含了2次。 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:3:2","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 2050; struct line { int typ; ld s, t, y; bool operator\u003c(const line\u0026 l)const { return y \u003c l.y; // 按照横坐标升序排序 } }line[maxn * 2]; struct node { int l, r; int cnt; ld len, len2; }tree[maxn * 4]; ld X[maxn * 2]; void build(int p, int l, int r) { tree[p] = { l,r,0,0,0 }; if (l == r)return; int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); } void pushup(int p) { int l = tree[p].l, r = tree[p].r; if (tree[p].cnt) { // 有覆盖 tree[p].len = X[r + 1] - X[l]; } else if (l != r) { tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len; } else { tree[p].len = 0; } if (tree[p].cnt \u003e= 2) { tree[p].len2 = X[r + 1] - X[l]; } else if (l != r \u0026\u0026 tree[p].cnt == 1) { // cnt=1时,子区间已经被包含过一次，再加上父节点p的一次则子区间被包含了2次 tree[p].len2 = tree[p * 2].len + tree[p * 2 + 1].len; } else if (l != r) { tree[p].len2 = tree[p * 2].len2 + tree[p * 2 + 1].len2; } else { tree[p].len2 = 0; } } void editTree(int p, ld l, ld r, int c) { // 要修改的x区间:[l,r] int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标 if (l \u003e= X[pr + 1] || r \u003c= X[pl]) { // pushup(p); return; } if (X[pl] \u003e= l \u0026\u0026 X[pr + 1] \u003c= r) { // 包含 tree[p].cnt += c; pushup(p); return; } editTree(p * 2, l, r, c); editTree(p * 2 + 1, l, r, c); pushup(p); } void solve() { int n;cin \u003e\u003e n; set\u003cld\u003eXs; for (int i = 1;i \u003c= n;i++) { ld x1, y1, x2, y2; // 左下右上 cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; line[i] = { 1,x1,x2,y1 }; // 下边 line[i + n] = { -1,x1,x2,y2 }; // 上边 Xs.insert(x1), Xs.insert(x2); // 离散化 } sort(line + 1, line + 1 + 2 * n); int t = 0; for (auto p : Xs) { X[++t] = p; } build(1, 1, t - 1); // 对离散化的X轴建树 ld ans = 0; for (int i = 1;i \u003c 2 * n;i++) { // 最后一条扫描线不用计入统计 editTree(1, line[i].s, line[i].t, line[i].typ); ans += tree[1].len2 * (line[i + 1].y - line[i].y); } ans += 0.001; // 样例好像有石 cout \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; cin \u003e\u003e t;cin.tie(0); while (t--) solve(); return 0; } ","date":"2024-08-16","objectID":"/posts/segtree_practice/:3:3","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#代码-2"},{"categories":["在学算法的日子里"],"content":" 敌兵布阵敌兵布阵 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:4:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#敌兵布阵"},{"categories":["在学算法的日子里"],"content":" 题意有$N$个营地，初始第$i$个营地有$a_i$个人，有$4$种命令。 Add i j，表示第$i$个营地增加$j$人。 Sub i j，表示第$i$个营地减少$j$人。 Query i j，查询第$i$到第$j$个营地一共有多少人。 End，表示结束。 数据范围 $N\\leq 50000$ $1\\leq a_i\\leq 50$​ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:4:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有$N$个营地，初始第$i$个营地有$a_i$个人，有$4$种命令。 Add i j，表示第$i$个营地增加$j$人。 Sub i j，表示第$i$个营地减少$j$人。 Query i j，查询第$i$到第$j$个营地一共有多少人。 End，表示结束。 数据范围 $N\\leq 50000$ $1\\leq a_i\\leq 50$​ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:4:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路很模板的一个题。 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:4:2","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 5e4 + 50; struct node { int val; }tree[maxn * 4]; int a[maxn]; void build(int p, int l, int r) { if (l == r) { tree[p].val = a[l]; return; } int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); tree[p].val = tree[p * 2].val + tree[p * 2 + 1].val; } void pushup(int p,int l,int r) { if (l == r)return; tree[p].val = tree[p * 2].val + tree[p * 2 + 1].val; } void update(int p, int cl, int cr, int goal,int x) { if (cl \u003e goal || cr \u003c goal)return; if (cl == cr) { tree[p].val += x; pushup(p, cl, cr); return; } int mid = cl + (cr - cl) / 2; update(p * 2, cl, mid, goal, x); update(p * 2 + 1, mid + 1, cr, goal, x); pushup(p, cl, cr); } int query(int p, int cl, int cr, int l, int r) { if (cl \u003e r || cr \u003c l) return 0; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { return tree[p].val; } int mid = cl + (cr - cl) / 2; int tot = 0; tot += query(p * 2, cl, mid, l, r); tot += query(p * 2 + 1, mid + 1, cr, l, r); return tot; } int ccnt; void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } build(1, 1, n); string s; cout \u003c\u003c \"Case \" \u003c\u003c ++ccnt \u003c\u003c \":\\n\"; while (cin \u003e\u003e s) { if (s == \"End\")break; if (s == \"Query\") { int l, r;cin \u003e\u003e l \u003e\u003e r; cout \u003c\u003c query(1, 1, n, l, r) \u003c\u003c '\\n'; } else if (s == \"Add\") { int i, j;cin \u003e\u003e i \u003e\u003e j; update(1, 1, n, i, j); } else if (s == \"Sub\") { int i, j;cin \u003e\u003e i \u003e\u003e j; update(1, 1, n, i, -j); } } } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; cin \u003e\u003e t;cin.tie(0); ccnt = 0; while (t--) solve(); return 0; } ","date":"2024-08-16","objectID":"/posts/segtree_practice/:4:3","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#代码-3"},{"categories":["在学算法的日子里"],"content":" 单峰数列单峰数列 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:5:0","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#单峰数列"},{"categories":["在学算法的日子里"],"content":" 题意给定长度为$n$的数列$a$，支持以下操作： 1 l r x：给区间$[l,r]$的所有数加上$x$ 2 l r：查询区间$[l,r]$中的元素是否全都相同 3 l r：查询区间$[l,r]$中的元素是否严格上升，当$l==r$时认为是严格上升的 4 l r：查询区间$[l,r]$中的元素是否严格下降，当$l==r$时认为是严格下降的 5 l r：查询区间$[l,r]$是否是单峰数列，单峰数列符合右侧严格递增，左侧严格递减，并且左右侧的区间不为空，保证$r-l+1\\geq 3$。 数据范围 $3\\leq n \\leq 10^5$ $0\\leq a_i\\leq 10^9$ $1\\leq q \\leq 2\\times 10^5$ 对于第一类操作，保证$-10^9\\leq x\\leq 10^9$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:5:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意给定长度为$n$的数列$a$，支持以下操作： 1 l r x：给区间$[l,r]$的所有数加上$x$ 2 l r：查询区间$[l,r]$中的元素是否全都相同 3 l r：查询区间$[l,r]$中的元素是否严格上升，当$l==r$时认为是严格上升的 4 l r：查询区间$[l,r]$中的元素是否严格下降，当$l==r$时认为是严格下降的 5 l r：查询区间$[l,r]$是否是单峰数列，单峰数列符合右侧严格递增，左侧严格递减，并且左右侧的区间不为空，保证$r-l+1\\geq 3$。 数据范围 $3\\leq n \\leq 10^5$ $0\\leq a_i\\leq 10^9$ $1\\leq q \\leq 2\\times 10^5$ 对于第一类操作，保证$-10^9\\leq x\\leq 10^9$ ","date":"2024-08-16","objectID":"/posts/segtree_practice/:5:1","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路用三个变量记录区间左值、右值和懒标记。 用三个布尔值变量记录当前区间是否是相同、上升、下降、单峰。在判断合并后是否是单峰时，主要满足单峰的区间必须大于等于3，当左右两个区间分别是上升、下降，且某个区间只有一个数时，要注意比较左右值。 ","date":"2024-08-16","objectID":"/posts/segtree_practice/:5:2","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 #include \u003cbits/stdc++.h\u003e using namespace std; #define lson(p) tree[p * 2] #define rson(p) tree[p * 2 + 1] typedef long long ll; typedef unsigned long long ull; const int maxn = 4e5 + 50; struct node { int l, r; ll lval, rval, lazy; bool isup, isdown, issame, isheap; } tree[maxn \u003c\u003c 2]; ll a[maxn]; node merge(node ret1, node ret2) { node ret; ret = { ret1.l, ret2.r, ret1.lval, ret2.rval, 0ll, true, true, true, false }; ret.issame = ret1.issame \u0026\u0026 ret2.issame \u0026\u0026 ret1.rval == ret2.lval; ret.isup = ret1.isup \u0026\u0026 ret2.isup \u0026\u0026 ret1.rval \u003c ret2.lval; ret.isdown = ret1.isdown \u0026\u0026 ret2.isdown \u0026\u0026 ret1.rval \u003e ret2.lval; if (ret1.isup \u0026\u0026 ret2.isdown) { if (ret1.l == ret1.r \u0026\u0026 ret1.rval \u003c ret2.lval \u0026\u0026 ret2.l != ret2.r) ret.isheap = true; else if (ret2.l == ret2.r \u0026\u0026 ret1.rval \u003e ret2.lval \u0026\u0026 ret1.l != ret1.r) ret.isheap = true; else if (ret1.l != ret1.r \u0026\u0026 ret2.l != ret2.r) ret.isheap = true; } if (ret1.isup \u0026\u0026 ret2.isheap \u0026\u0026 ret1.rval \u003c ret2.lval) ret.isheap = true; if (ret1.isheap \u0026\u0026 ret2.isdown \u0026\u0026 ret1.rval \u003e ret2.lval) ret.isheap = true; return ret; } void build(int p, int l, int r) { if (l == r) { tree[p] = {l, r, a[l], a[r], 0ll, true, true, true, false}; return; } int mid = l + (r - l) / 2; build(p * 2, l, mid); build(p * 2 + 1, mid + 1, r); tree[p] = merge(lson(p), rson(p)); } void pushdown(int p) { int l = tree[p].l, r = tree[p].r; if (l == r) { return; } if (tree[p].lazy) { ll x = tree[p].lazy; lson(p).lazy += x, rson(p).lazy += x; lson(p).lval += x, rson(p).lval += x; lson(p).rval += x, rson(p).rval += x; tree[p].lazy = 0ll; } } void pushup(int p) { int l = tree[p].l, r = tree[p].r; if (l == r) { return; } tree[p] = merge(lson(p), rson(p)); } void update(int p, int cl, int cr, int l, int r, ll num) { if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].lval += num, tree[p].rval += num; tree[p].lazy += num; pushdown(p); pushup(p); return; } pushdown(p); int mid = cl + (cr - cl) / 2; if (l \u003c= mid) update(p * 2, cl, mid, l, r, num); if (mid + 1 \u003c= r) update(p * 2 + 1, mid + 1, cr, l, r, num); pushup(p); } node query(int p, int cl, int cr, int l, int r) { if (cl \u003e= l \u0026\u0026 cr \u003c= r) { return tree[p]; } pushdown(p); int mid = cl + (cr - cl) / 2; node ret, ret1, ret2; ret1.l = ret2.l = -1; ret.l = cl, ret.r = cr; if (l \u003c= mid) { ret1 = query(p * 2, cl, mid, l, r); } if (mid + 1 \u003c= r) { ret2 = query(p * 2 + 1, mid + 1, cr, l, r); } pushup(p); if (ret1.l == -1) return ret2; if (ret2.l == -1) return ret1; ret = merge(ret1, ret2); return ret; } void solve() { int n; cin \u003e\u003e n; for (int i = 1; i \u003c= n; i++) { cin \u003e\u003e a[i]; } build(1, 1, n); int q; cin \u003e\u003e q; while (q--) { int op, l, r; cin \u003e\u003e op \u003e\u003e l \u003e\u003e r; if (op == 1) { ll x; cin \u003e\u003e x; update(1,1,n,l,r,x); } else { node ret = query(1, 1, n, l, r); if (op == 2) { cout \u003c\u003c ret.issame \u003c\u003c '\\n'; } else if (op == 3) { cout \u003c\u003c ret.isup \u003c\u003c '\\n'; } else if (op == 4) { cout \u003c\u003c ret.isdown \u003c\u003c '\\n'; } else if (op == 5) { cout \u003c\u003c ret.isheap \u003c\u003c '\\n'; } } } } void init() { } int main(void) { ios::sync_with_stdio(false); cin.tie(0); init(); int t = 1; // cin \u003e\u003e t; // cin.get(); while (t--) solve(); return 0; } ","date":"2024-08-16","objectID":"/posts/segtree_practice/:5:3","series":["题解记录"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树专题练习","uri":"/posts/segtree_practice/#代码-4"},{"categories":["在学算法的日子里"],"content":" A-Surrender to My Will","date":"2024-08-15","objectID":"/posts/nc24sd10/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#a-surrender-to-my-will"},{"categories":["在学算法的日子里"],"content":" 题意根据上票状态判断是否投降。4票及以上赞同投降则投降成功。 数据范围 $1\\leq i \\leq 5$ $1\\leq j\\leq i,S[j]\\in\\{Y,N\\}$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#题意"},{"categories":["在学算法的日子里"],"content":" 题意根据上票状态判断是否投降。4票及以上赞同投降则投降成功。 数据范围 $1\\leq i \\leq 5$ $1\\leq j\\leq i,S[j]\\in\\{Y,N\\}$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路计数模拟即可。 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { string s;cin \u003e\u003e s; int y = 0, n = 0; for (auto c : s) { if (c == 'Y')y++; else if (c == 'N')n++; } if (y \u003e= 4)cout \u003c\u003c \"1\\n\"; else if (n \u003e= 2)cout \u003c\u003c \"-1\\n\"; else cout \u003c\u003c \"0\\n\"; } ","date":"2024-08-15","objectID":"/posts/nc24sd10/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#代码"},{"categories":["在学算法的日子里"],"content":" B-std::pair","date":"2024-08-15","objectID":"/posts/nc24sd10/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#b-stdpair"},{"categories":["在学算法的日子里"],"content":" 题意使用std::pair声明$n$个变量，进行对于这些变量的$q$个询问，回答其数据类型。 数据范围 $1\\leq n,q\\leq 1000$ 每行输入不超过5000字符 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意使用std::pair声明$n$个变量，进行对于这些变量的$q$个询问，回答其数据类型。 数据范围 $1\\leq n,q\\leq 1000$ 每行输入不超过5000字符 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路按.分割询问的变量，逐层确定当前的数据类型。 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 1e6 + 50; map\u003cstring, string\u003emp; void solve() { int n, q;cin \u003e\u003e n \u003e\u003e q; for (int i = 0;i \u003c n;i++) { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; if (s2.back() == ';')s2.pop_back(); mp[s2] = s1; } while (q--) { string s;cin \u003e\u003e s; s = s + \".\"; vector\u003cstring\u003estk; int p = s.find(\".\"); int pr = 0; while (p != -1) { string t = s.substr(pr, p - pr); stk.push_back(t); s = s.substr(p + 1); p = s.find(\".\"); } string typ = mp[stk.front()]; for (int i = 1;i \u003c stk.size();i++) { string c = stk[i]; vector\u003cint\u003ev; int pp; // 中点的','位置 int cnt1, cnt2; cnt1 = cnt2 = 0; for (int j = 0;j \u003c typ.size();j++) { if (typ[j] == '\u003c') { cnt1++; } else if (typ[j] == ',') { cnt2++; v.push_back(j); } else if (typ[j] == '\u003e') { cnt1--, cnt2--; if (!cnt1 \u0026\u0026 !cnt2) { pp = v.back(); break; } v.pop_back(); } } if (c == \"first\") { typ = typ.substr(5, pp - 5); } else { typ = typ.substr(pp + 1, typ.size() - pp - 2); } } cout \u003c\u003c typ \u003c\u003c \"\\n\"; } } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-08-15","objectID":"/posts/nc24sd10/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#代码-1"},{"categories":["在学算法的日子里"],"content":" F-Collinear Exception","date":"2024-08-15","objectID":"/posts/nc24sd10/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#f-collinear-exception"},{"categories":["在学算法的日子里"],"content":" 题意在$\\{1,…,n\\}\\times \\{1,…,n\\}$的坐标逐渐加入$n\\times n$个数，如果即将加入的这个数与已有的形成了三点共线，则该数不能被成功加入，输出一个长度为$n\\times n$的01串，表示第$i$个点能否成功加入。 数据结构 $1\\leq n\\leq 1000$ $1\\leq x_i,y_i\\leq n$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意在$\\{1,…,n\\}\\times \\{1,…,n\\}$的坐标逐渐加入$n\\times n$个数，如果即将加入的这个数与已有的形成了三点共线，则该数不能被成功加入，输出一个长度为$n\\times n$的01串，表示第$i$个点能否成功加入。 数据结构 $1\\leq n\\leq 1000$ $1\\leq x_i,y_i\\leq n$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#数据结构"},{"categories":["在学算法的日子里"],"content":" 思路每行每列都不能拥有超过$2$个点，若某行或某列已经超过2个点则直接判不能加入，用一个$vis$数组记录某点是否能被成功加入，加入新点时，遍历图中已有的点，枚举与图中已有点形成的直线的斜率$(dx,dy)$，$dx$、$dy$互质，从当前点$(x,y)$向两边转移到$(x\\pm dx,y\\pm dy)$，并标记该处不能被访问。 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1050; struct point { int x, y; }; int X[maxn], Y[maxn]; bool vis[maxn][maxn]; void solve() { int n;cin \u003e\u003e n; vector\u003cpoint\u003ev; for (int i = 1;i \u003c= n * n;i++) { int x1, y1;cin \u003e\u003e x1 \u003e\u003e y1; if (X[x1] + 1 \u003e 2 || Y[y1] + 1 \u003e 2 || vis[x1][y1]) { cout \u003c\u003c \"0\"; continue; } X[x1]++, Y[y1]++; if (i == 1) { v.push_back({ x1,y1 }); vis[x1][y1] = true; cout \u003c\u003c \"1\";continue; } for (auto [x2, y2] : v) { if (y2 == y1 || x2 == x1)continue; int dx = abs(x2 - x1), dy = abs(y2 - y1), c = (1.0 * (y1 - y2) / (x1 - x2) \u003e 0 ? 1 : -1); int g = gcd(dx, dy); dx /= g, dy /= g; int x = x1, y = y1; while (x \u003e= 1 \u0026\u0026 x \u003c= n \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= n) { vis[x][y] = true; x += dx, y += c * dy; } x = x1, y = y1; while (x \u003e= 1 \u0026\u0026 x \u003c= n \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= n) { vis[x][y] = true; x -= dx, y -= c * dy; } } v.push_back({ x1,y1 }); cout \u003c\u003c \"1\"; } cout \u003c\u003c \"\\n\"; } int main() { int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-08-15","objectID":"/posts/nc24sd10/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#代码-2"},{"categories":["在学算法的日子里"],"content":" H-All-in at the Pre-flop","date":"2024-08-15","objectID":"/posts/nc24sd10/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#h-all-in-at-the-pre-flop"},{"categories":["在学算法的日子里"],"content":" 题意两个玩家拥有$a$和$b$的筹码，在一场公平游戏中全押，等概率成为输家或赢家，若赢家的筹码不少于输家，游戏结束，该局赢家为最终胜利者。否则输家向赢家支付等同于赢家筹码的筹码。问游戏结束时两个玩家分别的胜率是多少（模$998244353$）。 数据范围 $1\\leq a,b\\leq 998244353$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意两个玩家拥有$a$和$b$的筹码，在一场公平游戏中全押，等概率成为输家或赢家，若赢家的筹码不少于输家，游戏结束，该局赢家为最终胜利者。否则输家向赢家支付等同于赢家筹码的筹码。问游戏结束时两个玩家分别的胜率是多少（模$998244353$）。 数据范围 $1\\leq a,b\\leq 998244353$ ","date":"2024-08-15","objectID":"/posts/nc24sd10/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路游戏结束时要求赢家筹码不少于输家，另$f(x)$为玩家筹码量为$x$时的胜率，$n$为总筹码数，也就是$a+b$，则有： $$ f(0)=0,f(n)=1\\\\ \\begin{cases} f(x)=\\frac{1}{2}\\times f(0)+\\frac{1}{2}\\times f(2 x)\\quad x\\lt n/2\\\\ f(x)=\\frac{1}{2}\\times f(n)+\\frac{1}{2}\\times f(2 x-n)\\quad x\\geq n/2 \\end{cases} $$ 玩家押上$x$筹码后，对方押上$n-x$筹码，若$x\\geq n-x$则玩家为赢家时直接胜利，为输家时向对方交付$n-x$筹码，自己留下$x-(n-x)=2\\times x-n$筹码，这时候的胜率变为$f(2x-n)$，发生这两种情况的概率都是$0.5$。打表后发现$f(x)=\\frac{x}{n}$是线性方程的解。 输出$\\frac{a}{a+b}$和$\\frac{a}{a+b}$。 ","date":"2024-08-15","objectID":"/posts/nc24sd10/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026 1)res = res * a % mo998; b \u003e\u003e= 1; a = a * a % mo998; } return res; } ll inv(ll x) { return qpow(x, mo998 - 2); } void solve() { ll a, b;cin \u003e\u003e a \u003e\u003e b; ll c = (a + b) % mo998; cout \u003c\u003c a * inv(c) % mo998 \u003c\u003c \" \" \u003c\u003c b * inv(c) % mo998 \u003c\u003c \"\\n\"; } ","date":"2024-08-15","objectID":"/posts/nc24sd10/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day10||补题","uri":"/posts/nc24sd10/#代码-3"},{"categories":["在学算法的日子里"],"content":" A-Haitang and Game","date":"2024-08-09","objectID":"/posts/nc24sd8/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#a-haitang-and-game"},{"categories":["在学算法的日子里"],"content":" 题意给出一个数组，两人轮流，每次选择数组中的两个数，若这两个数的$gcd$不在当前的数组里，就将这两个数的$gcd$加入到数组中，不能再加数的一方输。 数据范围 $1\\leq t\\leq 100$ $1\\leq n\\leq 10^5$ $1\\leq a_i\\leq 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd8/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#题意"},{"categories":["在学算法的日子里"],"content":" 题意给出一个数组，两人轮流，每次选择数组中的两个数，若这两个数的$gcd$不在当前的数组里，就将这两个数的$gcd$加入到数组中，不能再加数的一方输。 数据范围 $1\\leq t\\leq 100$ $1\\leq n\\leq 10^5$ $1\\leq a_i\\leq 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd8/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路整个数组的最终含有哪些数是确定的，枚举$1\\sim a_{max}$的每个数，记为$x$，查看数组中大于$x$的整数倍的数，若这些倍数的$gcd$恰好等于$x$，则$x$会出现在最终的数组中。 ","date":"2024-08-09","objectID":"/posts/nc24sd8/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ea(n); vector\u003cbool\u003evis(100005, false); int mx = -1; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; vis[a[i]] = true; if (mx != -1)mx = max(mx, a[i]); else mx = a[i]; } if (n == 1) { cout \u003c\u003c \"Haitang\\n\";return; } int ans = 0; for (int i = 1;i \u003c= mx;i++) { if (vis[i])continue; vector\u003cint\u003eg; for (int j = 2 * i;j \u003c= mx;j += i) { if (vis[j])g.push_back(j); } if (g.size() \u003e= 2) { int k = gcd(g[0], g[1]); for (int j = 2;j \u003c g.size();j++) { k = gcd(k, g[j]); } if (k == i) { ans++; vis[i] = true; } } } if (ans % 2) { cout \u003c\u003c \"dXqwq\\n\"; } else { cout \u003c\u003c \"Haitang\\n\"; } } ","date":"2024-08-09","objectID":"/posts/nc24sd8/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#代码"},{"categories":["在学算法的日子里"],"content":" K-Haitang and Ava","date":"2024-08-09","objectID":"/posts/nc24sd8/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#k-haitang-and-ava"},{"categories":["在学算法的日子里"],"content":" 题意符合以下条件的字符串的合法的： 空串是合法的。 在合法串$S$的前面或后面加$ava$​形成的字符串是合法的。 在合法串$S$的前面或后面加$avava$​形成的字符串是合法的。 给你一个字符串，判断它是否合法。 数据范围 $1\\leq T\\leq 1.7\\times 10^5$ $3\\leq |S| \\leq 5\\times 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd8/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意符合以下条件的字符串的合法的： 空串是合法的。 在合法串$S$的前面或后面加$ava$​形成的字符串是合法的。 在合法串$S$的前面或后面加$avava$​形成的字符串是合法的。 给你一个字符串，判断它是否合法。 数据范围 $1\\leq T\\leq 1.7\\times 10^5$ $3\\leq |S| \\leq 5\\times 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd8/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路逐步删去前缀或后缀，若最后能删成空串，则为合法串。 ","date":"2024-08-09","objectID":"/posts/nc24sd8/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { string s;cin \u003e\u003e s; int l = 0, r = s.size() - 1; while (l \u003c= r) { string t; if (r - l + 1 \u003e= 5) { t = s.substr(l, 5); if (t == \"avava\") { l += 5;continue; } t = s.substr(r - 4, 5); if (t == \"avava\") { r -= 5;continue; } } if (r - l + 1 \u003e= 3) { t = s.substr(l, 3); if (t == \"ava\") { l += 3;continue; } t = s.substr(r - 2, 3); if (t == \"ava\") { r -= 3;continue; } } break; } if (l \u003e r) { cout \u003c\u003c \"Yes\\n\"; } else { cout \u003c\u003c \"No\\n\"; } } ","date":"2024-08-09","objectID":"/posts/nc24sd8/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day8||补题","uri":"/posts/nc24sd8/#代码-1"},{"categories":["在学算法的日子里"],"content":" I-Fight Against the Monster","date":"2024-08-09","objectID":"/posts/nc24sd7/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#i-fight-against-the-monster"},{"categories":["在学算法的日子里"],"content":" 题意使用机器对抗怪兽，一台机器有以下两种功能： 战斗：使怪兽血量减少1点，后技巧丧失所有功能 创造：需要$m$台机器同时使用，创造出$k$台新机器，每台机器仅能使用一次创造功能。 怪兽初始血量是$h$，血量下降至$0$​时死亡，请计算初始最少需要多少机器才能打败怪兽。 数据范围 $1\\leq t\\leq 2\\times 10^5$ $1\\leq k\\leq m \\leq 10^6$ $0\\leq h\\leq 10^9$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#题意"},{"categories":["在学算法的日子里"],"content":" 题意使用机器对抗怪兽，一台机器有以下两种功能： 战斗：使怪兽血量减少1点，后技巧丧失所有功能 创造：需要$m$台机器同时使用，创造出$k$台新机器，每台机器仅能使用一次创造功能。 怪兽初始血量是$h$，血量下降至$0$​时死亡，请计算初始最少需要多少机器才能打败怪兽。 数据范围 $1\\leq t\\leq 2\\times 10^5$ $1\\leq k\\leq m \\leq 10^6$ $0\\leq h\\leq 10^9$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路根据机器的功能特点，我们尽可能让每台机器进行创造。若最初有$x$台机器，则进行一次创造之后拥有$x+k(x\\ge m)$台机器，其中有$k+x-m$台机器拥有创造能力，最多拥有的机器数目是直到拥有创造能力的机器数目低于$m$时拥有的机器数目。可以发现除了第一次使用$m$台机器进行创造，之后使用$m$台机器进行创造时，可以使用$k$台新制造的机器加上$m-k$台最初拥有的机器进行创造，那么最多拥有的机器数目是： $$ f(x)= \\begin{cases} x\\quad x\\lt m\\\\ x+k\\times (\\lfloor (x-m)/(m-k)\\rfloor+1) \\end{cases} $$ 二分寻找符合条件的最少的最初机器数即可。 不过队友在赛时提供了一种更加直观不必二分求解的方法： 怪兽每受到$m$点攻击时，可以将这$m$点攻击看成是花费$m-k$台机器，在保证至少能发出一次$m$点攻击时，最初的机器数目要有$m$个，同时，怪物剩余不足$m$点血量时，只能再用额外的机器进行攻击。相关代码也贴在下面了。 ","date":"2024-08-09","objectID":"/posts/nc24sd7/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 // 二分 ll m, k, h; ll getmax(ll x) { if (x \u003c m)return x; return x + k * ((x - m) / (m - k) + 1); } void solve() { cin \u003e\u003e m \u003e\u003e k \u003e\u003e h; if (m == k || h \u003c= m) { cout \u003c\u003c min(h, m) \u003c\u003c \"\\n\"; return; } ll l = m, r = h + 1; while (l \u003c r) {// [l,r) ll x = (l + r) \u003e\u003e 1; if (h \u003e getmax(x)) { l = x + 1; } else { r = x; } } cout \u003c\u003c l \u003c\u003c \"\\n\"; } // 直接求解 void solve(){ cin \u003e\u003e m \u003e\u003e k \u003e\u003e h; ll ans = (h / m) * (m - k); if(h / m) ans += max(h % m, k); else ans = h; cout \u003c\u003c ans \u003c\u003c \"\\n\"; } ","date":"2024-08-09","objectID":"/posts/nc24sd7/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#代码"},{"categories":["在学算法的日子里"],"content":" J-Ball","date":"2024-08-09","objectID":"/posts/nc24sd7/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#j-ball"},{"categories":["在学算法的日子里"],"content":" 题意坐标轴上有一根木棒，左端点在原点$(0,0)$处，垂直$y$轴放置，右端点在$(l,0)$处，在坐标轴上有一个点$P(x,y)$，询问在木棒上是否有一个点，满足当木棒绕着该点旋转时可以击中点$P$，如有则输出该点坐标，若无输出$-1$。 数据范围 $1\\leq T\\leq 10^4$ $1\\leq l\\leq 10^5$ $-10^5\\leq x,y \\leq 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意坐标轴上有一根木棒，左端点在原点$(0,0)$处，垂直$y$轴放置，右端点在$(l,0)$处，在坐标轴上有一个点$P(x,y)$，询问在木棒上是否有一个点，满足当木棒绕着该点旋转时可以击中点$P$，如有则输出该点坐标，若无输出$-1$。 数据范围 $1\\leq T\\leq 10^4$ $1\\leq l\\leq 10^5$ $-10^5\\leq x,y \\leq 10^5$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路木棒可以到达的最大范围是以$(0,0)$为旋转中心和以$(l,0)$为旋转中心的旋转范围的并集。 ","date":"2024-08-09","objectID":"/posts/nc24sd7/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 ld sqr(ld dx, ld dy) { return sqrt(dx * dx + dy * dy); } ld dist(ll x1, ll y1, ll x2, ll y2) { return sqr(1.0 * (x1 - x2), 1.0 * (y1 - y2)); } void solve() { ll l, x, y;cin \u003e\u003e l \u003e\u003e x \u003e\u003e y; ld d1 = dist(0, 0, x, y), d2 = dist(l, 0, x, y); if (d1 \u003e l \u0026\u0026 d2 \u003e l) { cout \u003c\u003c \"No\\n\";return; } cout \u003c\u003c \"Yes\\n\"; if (d1 \u003c= l) { cout \u003c\u003c \"0.00000000\\n\"; } else if (d2 \u003c= l) { printf(\"%.8lf\\n\", 1.0 * l); } } ","date":"2024-08-09","objectID":"/posts/nc24sd7/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#代码-1"},{"categories":["在学算法的日子里"],"content":" K-Strings, Subsequences, Reversed Subsequences, Prefixes","date":"2024-08-09","objectID":"/posts/nc24sd7/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#k-strings-subsequences-reversed-subsequences-prefixes"},{"categories":["在学算法的日子里"],"content":" 题意给出一个字符串$s$和一个字符串$t$，要求在$s$中寻找以$t$为前缀，以$t$的翻转串为后缀的$s$的子串，求这样的本质不同的子串数目。 数据范围 $1\\leq n,m \\leq 10^6$ $s_i,t_i\\in [a,z]$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给出一个字符串$s$和一个字符串$t$，要求在$s$中寻找以$t$为前缀，以$t$的翻转串为后缀的$s$的子串，求这样的本质不同的子串数目。 数据范围 $1\\leq n,m \\leq 10^6$ $s_i,t_i\\in [a,z]$ ","date":"2024-08-09","objectID":"/posts/nc24sd7/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路前缀和后缀可以直接暴力从$s$最左侧和最右侧枚举，前后缀还要加上有公共重叠部分的数目，之后的问题就是如何计算中间部分的本质不同的子串了。 另中间部分的字符串为$s’$，在$s’$上，设$f[i]$表示到第$i$位时拥有多少个本质不同的子串，将$a[i]$加入时，$a[i]$可以加入在$f[i-1]$时的所有本质不同的子串的后面，这样形成的字符串中，与原来答案重复的是上一个字符$a[i]$加入时拥有的本质不同的字符串数目，所以转移方程是这样： $$ f[i]=2\\times f[i-1]-f[last[a[i]]-1] $$ 在处理前后缀的时候，当前后缀所处的最小区域有相交时，枚举允许重叠的长度时要至少从重叠部分的长度开始进行枚举。 ","date":"2024-08-09","objectID":"/posts/nc24sd7/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const ll mo998 = 998244353; const ll mo109 = 1000000007; const int maxn = 1e5 + 50; void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; string s, t;cin \u003e\u003e s \u003e\u003e t; ll l = 0, r = n - 1; ll p0 = 0; while (p0 \u003c m \u0026\u0026 l \u003c n) { if (t[p0] == s[l]) { p0++; } l++; } if (p0 != m) { cout \u003c\u003c 0 \u003c\u003c \"\\n\"; return; } p0 = 0; ll pos = 0; while (p0 \u003c m \u0026\u0026 r \u003e= 0) { if (t[p0] == s[r]) { p0++; if (r \u003e= l)pos = p0; // 独自能自匹配的长度 } r--; } if (p0 != m) { cout \u003c\u003c 0 \u003c\u003c \"\\n\"; return; } // 处理回文 ll cnt = 0; vector\u003cll\u003eh1(m + 5), h2(m + 5), p(m + 5); ll b = 131; t = \" \" + t; p[0] = 1; for (int i = 1;i \u003c= m;i++) { h1[i] = h1[i - 1] * b + t[i]; h2[i] = h2[i - 1] * b + t[m - i + 1]; p[i] = p[i - 1] * b; } for (int i = 1;i \u003c= m;i++) { // 判断长度为i的前后缀是否相同 ll hh1 = h1[m] - h1[m - i] * p[i]; ll hh2 = h2[i] - h2[0] * p[i]; if (hh1 == hh2)cnt++; } int len = r - l + 1; if (len \u003c 0) { ll ans = 0; len = m - pos; for (ll i = len;i \u003c= m;i++) { ll hh1 = h1[m] - h1[m - i] * p[i]; ll hh2 = h2[i] - h2[0] * p[i]; if (hh1 == hh2)ans++; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; return; } string a = s.substr(l, len); vector\u003cll\u003ef(len + 5, 0), las(30, -1); a = \" \" + a; f[0] = 1; for (ll i = 1;i \u003c= len;i++) { int c = a[i] - 'a'; if (las[c] != -1) f[i] = (2 * f[i - 1] % mo109 - f[las[c] - 1] + mo109) % mo109; else f[i] = 2 * f[i - 1] % mo109; las[c] = i; } cout \u003c\u003c f[len] + cnt \u003c\u003c \"\\n\"; } int main() { int _ = 1; while (_--) solve(); return 0; } ","date":"2024-08-09","objectID":"/posts/nc24sd7/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day7||补题","uri":"/posts/nc24sd7/#代码-2"},{"categories":["在学算法的日子里"],"content":" A-Cake","date":"2024-08-05","objectID":"/posts/nc24sd6/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#a-cake"},{"categories":["在学算法的日子里"],"content":" 题意Oscar和Grammy玩游戏，第一阶段两人轮流在有根树上走，走到叶子停止，经过的边有两种，标0边或者标1边，记录走下的01串。设01串的长度是$m$，第二阶段Oscar将蛋糕切成$m$份，有些蛋糕可以是空的，按照第一阶段的01串顺序依次拿蛋糕（1代表Grammy拿，0代表Oscar拿），两人都想获得最多的蛋糕，求最后Grammy获得的蛋糕比例。 数据范围 $1\\leq n\\leq 2\\times 10^5$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#题意"},{"categories":["在学算法的日子里"],"content":" 题意Oscar和Grammy玩游戏，第一阶段两人轮流在有根树上走，走到叶子停止，经过的边有两种，标0边或者标1边，记录走下的01串。设01串的长度是$m$，第二阶段Oscar将蛋糕切成$m$份，有些蛋糕可以是空的，按照第一阶段的01串顺序依次拿蛋糕（1代表Grammy拿，0代表Oscar拿），两人都想获得最多的蛋糕，求最后Grammy获得的蛋糕比例。 数据范围 $1\\leq n\\leq 2\\times 10^5$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路在第二阶段，Oscar分蛋糕的时候，是对当前串寻找一个0占比最大的前缀，然后拿走占比一致的蛋糕。 于是，在第一阶段时，首先树上每个节点即代表一个前缀，预处理出每个节点为前缀时0的占比，在之后两人轮流取数时，Oscar会取选择下一个节点轮流选择后0占比最大的节点，Grammy会选择0占比最小的节点。 ","date":"2024-08-05","objectID":"/posts/nc24sd6/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 struct edge { int s, t, typ; }; struct status { int cnt0, cnt1; status(int a, int b) :cnt0(a), cnt1(b) {} status operator+(const status\u0026 s)const { return status(s.cnt0 + cnt0,s.cnt1 + cnt1); } }; vector\u003cvector\u003cedge\u003e\u003etree; double dfs(int p, int fr, int who, status now, double mx) { // mx为路径中0比例最大的前缀中0的比例 if (tree[p].size() == 1 \u0026\u0026 fr) { return mx; } double ans = 1.0 * who; for (int i = 0;i \u003c tree[p].size();i++) { struct edge e = tree[p][i]; if (e.t == fr)continue; double nxt = dfs(e.t, p, 1 - who, now + status(1 - e.typ, e.typ), max(mx, 1.0 * (now.cnt0 + 1 - e.typ) / (now.cnt0 + now.cnt1 + 1))); if (who) { // Grammy选择(当前路径+接下来的路径)中0比例少的 ans = min(ans, nxt); } else { // Oscar选择0比例多的 ans = max(ans, nxt); } } return ans; } void solve() { int n;cin \u003e\u003e n; tree.assign(n + 1, vector\u003cedge\u003e()); for (int i = 0;i \u003c n - 1;i++) { int u, v, t; cin \u003e\u003e u \u003e\u003e v \u003e\u003e t; tree[u].push_back({ u,v,t }); tree[v].push_back({ v,u,t }); } double ans = dfs(1, 0, 1, { 0,0 }, 0.0); cout \u003c\u003c fixed \u003c\u003c setprecision(15) \u003c\u003c 1.0 - ans \u003c\u003c \"\\n\"; } ","date":"2024-08-05","objectID":"/posts/nc24sd6/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#代码"},{"categories":["在学算法的日子里"],"content":" B-Cake 2","date":"2024-08-05","objectID":"/posts/nc24sd6/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#b-cake-2"},{"categories":["在学算法的日子里"],"content":" 题意对一个正$n$边形，顶点按顺时针标为$0\\sim n-1$，在每一个$i$和$(i+k)\\bmod n$的顶点之间切一刀，问最终能切出多少块蛋糕。 数据范围 $1\\leq n\\leq 10^6$ $2\\leq k\\leq n-2$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意对一个正$n$边形，顶点按顺时针标为$0\\sim n-1$，在每一个$i$和$(i+k)\\bmod n$的顶点之间切一刀，问最终能切出多少块蛋糕。 数据范围 $1\\leq n\\leq 10^6$ $2\\leq k\\leq n-2$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路找规律可以发现除了$2\\times k=n$时答案为$n$，其他情况都符合$n\\times \\min(n-k,k) +1$。 ","date":"2024-08-05","objectID":"/posts/nc24sd6/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; if (n == k * 2) { cout \u003c\u003c n \u003c\u003c \"\\n\"; } else { k = min(k, n - k); cout \u003c\u003c k * n + 1 \u003c\u003c \"\\n\"; } } ","date":"2024-08-05","objectID":"/posts/nc24sd6/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#代码-1"},{"categories":["在学算法的日子里"],"content":" D-Puzzle: Wagiri","date":"2024-08-05","objectID":"/posts/nc24sd6/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#d-puzzle-wagiri"},{"categories":["在学算法的日子里"],"content":" 题意无向图中有两种边，对原图进行删边，要求删完边之后图仍是联通的，且所有的轮边只在环中出现，所有的切边都不在环，判断是否存在合适的删边操作，若有再输出结果的连接情况。 数据范围 $1\\leq n\\leq 10^5$ $n-1\\leq m\\leq 2\\times 10^5$ $1\\leq u_i,v_i\\leq n$ $t_i\\in \\{“Lun”,“Qie”\\}$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意无向图中有两种边，对原图进行删边，要求删完边之后图仍是联通的，且所有的轮边只在环中出现，所有的切边都不在环，判断是否存在合适的删边操作，若有再输出结果的连接情况。 数据范围 $1\\leq n\\leq 10^5$ $n-1\\leq m\\leq 2\\times 10^5$ $1\\leq u_i,v_i\\leq n$ $t_i\\in \\{“Lun”,“Qie”\\}$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路将所有的$Lun$边中成环的部分进行缩点，再根据$Qie$边对这些点生成一棵树。 ","date":"2024-08-05","objectID":"/posts/nc24sd6/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 struct E { int id; int s, t; int typ; }; vector\u003cvector\u003cE\u003e\u003eedge; ll deep, top, sum, res = 0; ll dfn[maxn], low[maxn], color[maxn], vis[maxn], stk[maxn]; vector\u003cE\u003eans; void tarjan(int v, int fa) { dfn[v] = ++deep; low[v] = deep; vis[v] = 1; stk[++top] = v; // 入栈 for (int i = 0;i \u003c edge[v].size();i++) { auto e = edge[v][i]; if (e.typ == 0 || e.t == fa) // 忽略Qie边和避免重边环 continue; if (dfn[e.t] == 0) { tarjan(e.t, v); low[v] = min(low[v], low[e.t]); } else { if (vis[e.t]) { low[v] = min(low[v], low[e.t]); } } } if (low[v] == dfn[v]) { // 形成强联通分量或仅自己,缩点 color[v] = ++sum; vis[v] = 0; while (stk[top] != v) { color[stk[top]] = sum; vis[stk[top--]] = 0; } top--; } } int fa[maxn]; int findfa(int u) { if (fa[u] == u)return u; return fa[u] = findfa(fa[u]); } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; edge.assign(n + 1, vector\u003cE\u003e()); for (int i = 1;i \u003c= m;i++) { int u, v;cin \u003e\u003e u \u003e\u003e v; string s;cin \u003e\u003e s; int c = (s == \"Lun\" ? 1 : 0); edge[u].push_back({ ++tot,u,v,c }); edge[v].push_back({ ++tot,v,u,c }); } memset(dfn, 0, sizeof(dfn)); for (int i = 1;i \u003c= n;i++) { if (dfn[i] == 0) { tarjan(i, -1); } } // for (int i = 1;i \u003c= n;i++) { // cout \u003c\u003c color[i] \u003c\u003c \" \"; // 各个点的颜色 // } // cout \u003c\u003c \"\\n\"; for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c edge[i].size();j++) { auto e = edge[i][j]; if (color[e.t] == color[i]) { // s,t相同颜色的轮边直接加入答案 if (e.typ == 1) ans.push_back(e); } } } for (int i = 1;i \u003c= sum;i++)fa[i] = i; int cntc = sum; for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c edge[i].size();j++) { auto e = edge[i][j]; if (e.typ == 1) { // 跳过轮边 continue; } if (color[i] != color[e.t]) { int f1 = findfa(color[i]); int f2 = findfa(color[e.t]); if (f1 != f2) { fa[f1] = f2; ans.push_back(e); // 用e将两个颜色连起来 cntc--; } } } } if (cntc == 1) { cout \u003c\u003c \"YES\\n\"; // 去除加入的双向边 map\u003cpair\u003cll, ll\u003e, bool\u003emp; for (auto e : ans) { if (e.s \u003c e.t) { mp[{e.s, e.t}] = true; } else { mp[{e.t, e.s}] = true; } } cout \u003c\u003c mp.size() \u003c\u003c \"\\n\"; for (auto [e, f] : mp) { cout \u003c\u003c e.first \u003c\u003c \" \" \u003c\u003c e.second \u003c\u003c \"\\n\"; } } else { cout \u003c\u003c \"NO\\n\"; } } ","date":"2024-08-05","objectID":"/posts/nc24sd6/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#代码-2"},{"categories":["在学算法的日子里"],"content":" H-Genshin Impact’s Fault","date":"2024-08-05","objectID":"/posts/nc24sd6/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#h-genshin-impacts-fault"},{"categories":["在学算法的日子里"],"content":" 题意每次抽卡的结果是3星、4星、5星非Up、5星Up四种结果中的一种。同时也符合如下的要求： 连续10抽中不会全是3星。 连续90抽中至少有一个是5星非Up或5星Up 每两个连续的5星中至少有一个是5星非Up 给出一个抽卡结果序列，判断该抽卡结果是否符合上述规则。 数据范围 $1\\leq T\\leq 10^5$ $1\\leq |S|\\leq 10^6$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意每次抽卡的结果是3星、4星、5星非Up、5星Up四种结果中的一种。同时也符合如下的要求： 连续10抽中不会全是3星。 连续90抽中至少有一个是5星非Up或5星Up 每两个连续的5星中至少有一个是5星非Up 给出一个抽卡结果序列，判断该抽卡结果是否符合上述规则。 数据范围 $1\\leq T\\leq 10^5$ $1\\leq |S|\\leq 10^6$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路模拟。 ","date":"2024-08-05","objectID":"/posts/nc24sd6/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { string s;cin \u003e\u003e s; bool hasup = true; int cnt10 = 0, cnt90 = 0; bool f = true; for (auto c : s) { if (c == '4' || c == '5' || c == 'U')cnt10 = 0; else cnt10++; if (cnt10 == 10) { f = false;break; } if (c == '5' \u0026\u0026 !hasup) { f = false;break; } if (c == '5' || c == 'U') { cnt90 = 0; if (c == 'U') hasup = true; else if (c == '5') hasup = false; } else { cnt90++; } if (cnt90 == 90) { f = false;break; } } f ? cout \u003c\u003c \"valid\\n\" : cout \u003c\u003c \"invalid\\n\"; } ","date":"2024-08-05","objectID":"/posts/nc24sd6/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#代码-3"},{"categories":["在学算法的日子里"],"content":" F-Challenge NPC 2","date":"2024-08-05","objectID":"/posts/nc24sd6/:5:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#f-challenge-npc-2"},{"categories":["在学算法的日子里"],"content":" 题意在一个森林的补图中寻找哈密顿路径。 注：哈密顿路径指经过图中所有顶点一次且仅经过一次。 数据范围 $n\\leq 5\\times 10^5$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意在一个森林的补图中寻找哈密顿路径。 注：哈密顿路径指经过图中所有顶点一次且仅经过一次。 数据范围 $n\\leq 5\\times 10^5$ ","date":"2024-08-05","objectID":"/posts/nc24sd6/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路森林中有且只有一棵菊花是无解的。剩余情况中，假如树是一棵菊花，则将其分为花瓣和花心两部分，花瓣可以连成一条路径，花心单独成为一条路径，假如不是一棵菊花，则寻找树的一个叶子结点，再从叶子结点进行BFS，按照246…135…的顺序将点穿起来，加入答案。 最后将不能相连的一组花瓣花心分别接在答案的两边，输出答案即可。 ","date":"2024-08-05","objectID":"/posts/nc24sd6/:5:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 5e5 + 50; const ll mo998 = 998244353; struct edge { int s, t; }; vector\u003cvector\u003cedge\u003e\u003etree; int fa[maxn]; int rk[maxn]; int deg[maxn]; bool vis[maxn]; int findfa(int x) { if (fa[x] == x)return x; return fa[x] = findfa(fa[x]); } vector\u003cint\u003eans; vector\u003cpair\u003cvector\u003cint\u003e, vector\u003cint\u003e\u003e\u003etmp; // 不能相邻的两条路 int tail, c; void getpath(vector\u003cint\u003ev) { if (v.size() == 1) { vis[v.front()] = true; ans.push_back(v.front()); return; } if (v.size() == 2) { tmp.push_back({ {v.front()},{v.back()} }); return; } // 判断菊花 int n = v.size(); vector\u003cint\u003ewi, wj; for (int i = 0;i \u003c n;i++) { int p = v[i]; if (deg[p] == n - 1) { wj.push_back(p); } else if (deg[p] == 1) { wi.push_back(p); } } if (wj.size() == 1) { tmp.push_back({ wi,wj }); return; } // 寻找叶子结点 for (auto i : v) { if (tree[i].size() == 1) { tail = i; break; } } // 分层bfs c = 0; wi.clear(); vector\u003cint\u003ex; x.push_back(tail); while (!x.empty()) { vector\u003cint\u003ey; for (auto p : x) { vis[p] = true; for (int i = 0;i \u003c tree[p].size();i++) { struct edge e = tree[p][i]; if (vis[e.t])continue; y.push_back(e.t); } if (c)ans.push_back(p); else wi.push_back(p); } c = 1 - c; x = y; } for (auto i : wi) { ans.push_back(i); } } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; tree.assign(n + 1, vector\u003cedge\u003e()); for (int i = 1;i \u003c= n;i++) { fa[i] = i; deg[i] = 0; vis[i] = false; rk[i] = 1; } for (int i = 0;i \u003c m;i++) { int u, v;cin \u003e\u003e u \u003e\u003e v; deg[u]++, deg[v]++; tree[u].push_back({ u,v }); tree[v].push_back({ v,u }); int fu = findfa(u), fv = findfa(v); if (rk[fu] \u003e rk[fv])fa[fv] = fu; else { if (rk[fu] == rk[fv])rk[fv]++; fa[fu] = fv; } } map\u003cint, vector\u003cint\u003e\u003emp; for (int i = 1;i \u003c= n;i++) { int f = findfa(i); mp[f].push_back(i); } ans.clear(), tmp.clear(); for (auto i : mp) { getpath(i.second); } if (ans.empty() \u0026\u0026 tmp.size() == 1) { cout \u003c\u003c -1 \u003c\u003c \"\\n\"; return; } if (tmp.size() \u003e= 2) { // 只有两个菊花时要交叉放 auto [v1, v2] = tmp[0]; auto [w1, w2] = tmp[1]; for (int i = 0;i \u003c v1.size();i++) { ans.push_back(v1[i]); } for (int i = 0;i \u003c w1.size();i++) { ans.push_back(w1[i]); } for (int i = 0;i \u003c v2.size();i++) { ans.push_back(v2[i]); } for (int i = 0;i \u003c w2.size();i++) { ans.push_back(w2[i]); } tmp.erase(tmp.begin()); tmp.erase(tmp.begin()); } vector\u003cint\u003ex, y; for (auto [w, v] : tmp) { for (auto i : w) { x.push_back(i); } for (auto i : v) { y.push_back(i); } } for (auto i : x) { cout \u003c\u003c i \u003c\u003c \" \"; } for (auto i : ans) { cout \u003c\u003c i \u003c\u003c \" \"; } for (auto i : y) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } int main() { ll t; cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2024-08-05","objectID":"/posts/nc24sd6/:5:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day6||补题","uri":"/posts/nc24sd6/#代码-4"},{"categories":["在学算法的日子里"],"content":"TODO ","date":"2024-07-31","objectID":"/posts/nc24sd5/:0:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day5||补题","uri":"/posts/nc24sd5/#"},{"categories":["在学算法的日子里"],"content":" A-LCT","date":"2024-07-31","objectID":"/posts/nc24sd4/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#a-lct"},{"categories":["在学算法的日子里"],"content":" 题意给定一棵有根树，每次询问前$i$条边组成的森林中，第$c_i$个点为根的树的深度。 数据范围 $2\\leq n\\leq 10^6$ $1\\leq a_i,b_i,c_i\\leq n,a_i\\neq b_i$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意"},{"categories":["在学算法的日子里"],"content":" 题意给定一棵有根树，每次询问前$i$条边组成的森林中，第$c_i$个点为根的树的深度。 数据范围 $2\\leq n\\leq 10^6$ $1\\leq a_i,b_i,c_i\\leq n,a_i\\neq b_i$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路带权并查集，维护每个节点在当前所属树的层数，维护所有以该节点为根节点的树的深度。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 int deep[maxn], fa[maxn], dis[maxn]; int findfa(int x) { if (x == fa[x])return x; int fx = findfa(fa[x]); // 更新deep,旧根:fa[x],新根:fx deep[x] += deep[fa[x]]; return fa[x] = fx; } void merge(int u, int v) { int fu = findfa(u); fa[v] = fu; deep[v] = deep[u] + 1; dis[fu] = max(dis[fu], dis[v] + deep[v]); } void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { fa[i] = i; deep[i] = 0; dis[i] = 0; } for (int i = 1;i \u003c= n - 1;i++) { int u, v, c;cin \u003e\u003e u \u003e\u003e v \u003e\u003e c; merge(u, v); cout \u003c\u003c dis[c] \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码"},{"categories":["在学算法的日子里"],"content":" C-Sort4","date":"2024-07-31","objectID":"/posts/nc24sd4/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#c-sort4"},{"categories":["在学算法的日子里"],"content":" 题意给出一个排列，每次选择四个位置交换其中的元素，求将该排列排序成上升序列的最小操作次数。 数据范围 $1\\leq t\\leq 10^5$ $1\\leq n\\leq 10^6$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给出一个排列，每次选择四个位置交换其中的元素，求将该排列排序成上升序列的最小操作次数。 数据范围 $1\\leq t\\leq 10^5$ $1\\leq n\\leq 10^6$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路令$p_i$是排序之后数$a_i$的位置，每个$(p_i,a_i)$对应了一个关系。易知这样的关系会形成若干个环，如果环的长度是$3$或$4$，则一次交换可以让这个环上的数字都归位，如果是大于$4$的环，每次在这个环上进行一次操作可以让环的长度减少$3$，如果是两个长度为$2$的环，则一次操作可以让两个长度为$2$的环归位。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 int p[maxn], fa[maxn], len[maxn]; int findfa(int x) { if (x == fa[x])return x; int fx = findfa(fa[x]); len[fa[x]] = len[fx]; return fa[x] = fx; } void merge(int x, int y) { int fx = findfa(x), fy = findfa(y); if (fx == fy)return; fa[fx] = fy; len[fy] += len[fx]; } void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { len[i] = 1;fa[i] = i; } for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e p[i]; merge(i, p[i]); } map\u003cint, int\u003emp; for (int i = 1;i \u003c= n;i++) { int fx = findfa(i); if (mp.count(fx))continue; mp[fx] = len[fx]; } int ans = 0, cnt2 = 0; for (auto [i, s] : mp) { if (s == 1)continue; else if (s == 3 || s == 4)ans++; else if (s \u003e 4) { int t = s / 3; ans += t; if (s % 3 == 2) { cnt2++; } } else cnt2++; } ans += (cnt2 + 1) / 2; cout \u003c\u003c ans \u003c\u003c \"\\n\"; } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码-1"},{"categories":["在学算法的日子里"],"content":" F-Good Tree","date":"2024-07-31","objectID":"/posts/nc24sd4/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#f-good-tree"},{"categories":["在学算法的日子里"],"content":" 题意一棵树，树上的边权都是$1$，定义$f(u)=\\sum_v dis(u,v)$，给出一个$x$，寻找一个满足存在两个点$u,v$使得$f(u)-f(v)=x$成立的最少节点子树，输出节点数。 数据范围 $1\\leq t\\leq 10^5$ $1\\leq x \\leq 10^{18}$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意一棵树，树上的边权都是$1$，定义$f(u)=\\sum_v dis(u,v)$，给出一个$x$，寻找一个满足存在两个点$u,v$使得$f(u)-f(v)=x$成立的最少节点子树，输出节点数。 数据范围 $1\\leq t\\leq 10^5$ $1\\leq x \\leq 10^{18}$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路$f(u)$为点$u$到各个其他节点的距离之和，只有$u\\rightarrow v$一条路径的时候，$f(u)=f(v)=dia(u,v)$，若要增加$f(u)$和$f(v)$之间的差值，每在$v$上增加一个在$v$的子树中的节点，$f(u)-f(v)$的值就会增加一倍$dis(u,v)$。 当有奇数个点，$2\\times k +1$个点，另$dis(u,v)=k$，剩余$k$个点都是$v$的子树中的节点，$f(u)-f(v)$最大是$k^2$。 当有偶数个点，$2\\times k+2$，同理，$f(u)-f(v)$的最大值是$k(k+1)$。 下一个奇数是$(k+1)^2$，再下一个偶数的是$(k+1)(k+2)$… 故对于一个确定的$x$，我们需要确定落在哪个$(k^2,(k+1)^2]$区间，然后再确定是在区间$(k^2,k(k+1)]$还是$(k(k+1),(k+1)^2]$，也就是点数应该至少是大于$2\\times k+1$还是$2\\times k+2$。 在区间$(k(k+1),(k+1)^2)$中，一定可以构造出$2\\times k+3$的方法； 在区间$(k^2,k(k+1)]$中，如果$k$为奇数，可以构造出$2\\times k+3$，如果$k$为偶数，可以构造出$2\\times k+2$。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll x;cin \u003e\u003e x; ll k = sqrtl(x); // 注意开方long long if (k * k == x) { cout \u003c\u003c 2 * k + 1 \u003c\u003c \"\\n\"; } else if (k * (k + 1) \u003c x) { cout \u003c\u003c 2 * k + 3 \u003c\u003c \"\\n\"; } else if ((x - k * k) % 2ll != k % 2ll) { cout \u003c\u003c 2 * k + 3 \u003c\u003c \"\\n\"; } else { cout \u003c\u003c 2 * k + 2 \u003c\u003c \"\\n\"; } } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码-2"},{"categories":["在学算法的日子里"],"content":" G-Horse Drinks Water","date":"2024-07-31","objectID":"/posts/nc24sd4/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#g-horse-drinks-water"},{"categories":["在学算法的日子里"],"content":" 题意将军饮马问题。在平面坐标轴中，只有$x、y$轴的飞负半轴是水源，给出马儿的坐标和营地的坐标，求最短距离。 数据范围 $1\\leq t\\leq 10^5$ $0\\leq x_G,y_G,x_T,u_T\\leq 10^9$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意将军饮马问题。在平面坐标轴中，只有$x、y$轴的飞负半轴是水源，给出马儿的坐标和营地的坐标，求最短距离。 数据范围 $1\\leq t\\leq 10^5$ $0\\leq x_G,y_G,x_T,u_T\\leq 10^9$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路将坐标按坐标轴对称，求距离。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 ld dist(ld r, ld c) { return sqrt(r * r + c * c); } void solve() { ll x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; ld ans1 = dist(1.0 * abs(y1 - y2), 1.0 * (abs(x1) + abs(x2))); ld ans2 = dist(1.0 * (abs(y1) + abs(y2)), 1.0 * abs(x1 - x2)); ld ans = min(ans1, ans2); printf(\"%.12lf\\n\", ans); } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码-3"},{"categories":["在学算法的日子里"],"content":" H-Yet Another Origami Problem","date":"2024-07-31","objectID":"/posts/nc24sd4/:5:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#h-yet-another-origami-problem"},{"categories":["在学算法的日子里"],"content":" 题意可以选择任意坐标$p$，进行如下二选一操作： 若符合$a_i\\leq a_p$，可以重新赋值$a_i\\leftarrow a_i + 2(a_p-a_i)$。 若符合$a_i\\geq a_p$，可以重新赋值$a_i \\leftarrow a_i-a(a_i-a_p)$ 可以进行上述操作若干次，求问可以将$a$数组的范围收敛到多小。 数据范围 $1\\leq t\\leq 5\\times 10^5$ $1\\leq n\\leq 10^5$ $0\\leq a_i\\leq 10^{16}$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意可以选择任意坐标$p$，进行如下二选一操作： 若符合$a_i\\leq a_p$，可以重新赋值$a_i\\leftarrow a_i + 2(a_p-a_i)$。 若符合$a_i\\geq a_p$，可以重新赋值$a_i \\leftarrow a_i-a(a_i-a_p)$ 可以进行上述操作若干次，求问可以将$a$数组的范围收敛到多小。 数据范围 $1\\leq t\\leq 5\\times 10^5$ $1\\leq n\\leq 10^5$ $0\\leq a_i\\leq 10^{16}$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路上面的操作可以进行无数次，通过模拟可以意识到，这是一个类似折纸的操作，是将某个数沿着某条线折叠到另一边的操作。注意到每次操作不是必须要对每个$a_i$进行这样的翻折的，例如当$a_i\\lt a_p$时选择操作2，可以避免$a_i$的翻折。 通过翻折让数组的范围收束到最小。假设当前只有3个各不相同的数，这三个数从小到大排列之后是${a,b,c}$，那么在数轴上形成了距离$x=b-a$和$y=c-b$，对于这三个数来说，通过折叠，假设是$a$沿着$b$向$c$折叠，将$x$变为$x\\bmod y$（不断沿着$y$的两边折叠，直到落在$b、c$之间），若此时$x\\neq 0$，则$y$也可以通过一样的方法收束到小于$x$的某个长度。故获得的最小的范围应该是$x、y$的$gcd$。 同样的思想可以拓展到多个数的时候。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:5:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 ll a[maxn]; void solve() { int n;cin \u003e\u003e n; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } sort(a, a + n); if (n == 1) { cout \u003c\u003c 0 \u003c\u003c \"\\n\"; return; } if (n == 2) { cout \u003c\u003c a[1] - a[0] \u003c\u003c \"\\n\"; return; } ll ans = a[1] - a[0]; for (int i = 2;i \u003c n;i++) { ans = gcd(ans, a[i] - a[i - 1]); } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:5:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码-4"},{"categories":["在学算法的日子里"],"content":" I-Friends","date":"2024-07-31","objectID":"/posts/nc24sd4/:6:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#i-friends"},{"categories":["在学算法的日子里"],"content":" 题意$n$个人从左到右排成一排，编号从$1$到$n-1$，这$n$个人之间有$m$对好朋友，求有多少个区间$[l,r]$中每两对都是好朋友。 数据范围 $1\\leq n,m \\leq 10^6$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:6:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意$n$个人从左到右排成一排，编号从$1$到$n-1$，这$n$个人之间有$m$对好朋友，求有多少个区间$[l,r]$中每两对都是好朋友。 数据范围 $1\\leq n,m \\leq 10^6$ ","date":"2024-07-31","objectID":"/posts/nc24sd4/:6:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路假设已有一个区间$[l,r]$符合要求，且$r$是以$l$为左端点的时候最远的符合要求的右端点。那么显然有： 当加入$r+1$时，$r+1$号与$[l,r]$中的至少一个人不是好友关系。同时，区间$[l+1,r]$是一个友好区间，于是在移动左端点时，右端点只需要从上一个左端点的最远右端点开始检查即可。 ","date":"2024-07-31","objectID":"/posts/nc24sd4/:6:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cmap\u003cint, bool\u003e\u003elinks(n + 1); for (int i = 0;i \u003c m;i++) { int u, v;cin \u003e\u003e u \u003e\u003e v; links[u][v] = true; links[v][u] = true; } int ans = 0; int prer = 1; for (int i = 1;i \u003c= n;i++) { int j = prer; while (j \u003c= n) { // check bool f = true; for (int k = i;k \u003c j;k++) { if (links[j].count(k))continue; f = false; break; } if (!f)break; j++; } ans += j - i; prer = j - 1; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } ","date":"2024-07-31","objectID":"/posts/nc24sd4/:6:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day4||补题","uri":"/posts/nc24sd4/#代码-5"},{"categories":["在学算法的日子里"],"content":" A-Bridging the Gap 2","date":"2024-07-23","objectID":"/posts/nc24sd3/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#a-bridging-the-gap-2"},{"categories":["在学算法的日子里"],"content":" 题意在河岸的一侧有$n$个人，每个人有一个体力值$h_i$，有一艘船可以将人从一侧载到另一侧，每次航行需要至少$L$个人掌舵，每次掌舵会花费每个掌舵人的一点体力，当体力不足一点时，这个人不能再掌舵，船的容量最大是$R$，提问是否能够将这些人都运送到对岸。 数据范围 $1\\leq L\\lt R\\leq n\\leq 5\\times 10^5$​ $1\\leq h_i\\leq 5\\times 10^5$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意在河岸的一侧有$n$个人，每个人有一个体力值$h_i$，有一艘船可以将人从一侧载到另一侧，每次航行需要至少$L$个人掌舵，每次掌舵会花费每个掌舵人的一点体力，当体力不足一点时，这个人不能再掌舵，船的容量最大是$R$，提问是否能够将这些人都运送到对岸。 数据范围 $1\\leq L\\lt R\\leq n\\leq 5\\times 10^5$​ $1\\leq h_i\\leq 5\\times 10^5$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路贪心的运输，从左岸运输的最小次数是$k=\\lceil \\frac{n-R}{R-L} \\rceil$，计算每个人最多的来回次数$a_i$，假如满足$\\sum_{i-1}^{n} min(k,a_i)\\geq k\\times L$，则可以将所有人都运输到对岸。 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 ll h[maxn], a[maxn]; void solve() { int n, L, R;cin \u003e\u003e n \u003e\u003e L \u003e\u003e R; ll sum = 0, k = (n - L - 1) / (R - L); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e h[i]; a[i] = (h[i] - 1) / 2; sum += min(k, a[i]); } if (sum \u003e= k * L)cout \u003c\u003c \"Yes\\n\"; else cout \u003c\u003c \"No\\n\"; } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码"},{"categories":["在学算法的日子里"],"content":" B-Crash Test","date":"2024-07-23","objectID":"/posts/nc24sd3/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#b-crash-test"},{"categories":["在学算法的日子里"],"content":" 题意小车有$n$个引擎，第$i$个引擎可以让车前进$h[i]$米。在小车起点正前方距离为$D$处有一反弹墙面，小车如果撞在墙上将会被回弹与当前剩余的前进米数相同的距离，并保持车头朝向墙面。小车可以使用任意引擎任意次，询问距离墙面最近的距离是多少。 数据范围 $1\\leq n\\leq 100$ $1\\leq D \\leq 10^{18}$ $1\\leq h[i]\\leq 10^{18}$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意小车有$n$个引擎，第$i$个引擎可以让车前进$h[i]$米。在小车起点正前方距离为$D$处有一反弹墙面，小车如果撞在墙上将会被回弹与当前剩余的前进米数相同的距离，并保持车头朝向墙面。小车可以使用任意引擎任意次，询问距离墙面最近的距离是多少。 数据范围 $1\\leq n\\leq 100$ $1\\leq D \\leq 10^{18}$ $1\\leq h[i]\\leq 10^{18}$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路假设当前选择了某个引擎，并只使用这个引擎，易知，我们可以将距离$d$减小到$\\min(d\\bmod h[i],h[i]-d\\bmod h[i])$。 接下来选择另一种引擎，在刚才的基础上，我们可以将距离减小到$\\min(d\\bmod h[i+1],h[i+1]-d\\bmod h[i+1])$。 设$gcd(h[i],h[i+1])=k$，$h[i]=ak,h[i+1]=bk$，则$d$的变化其实是这样的： $$ \\begin{align*} d_1=\u0026\\min(d_0\\bmod ak,d_0-d_0\\bmod ak)\\\\ =\u0026\\min(d_0\\bmod k,d_0-d_0\\bmod k)\\\\ \\\\ d_2=\u0026\\min(d_1\\bmod bk,d_1-d_1\\bmod bk)\\\\ =\u0026\\min(d_1\\bmod k,d_1-d_1\\bmod k)\\\\ =\u0026d_1\\\\ =\u0026\\min(d_0\\bmod k,d_0-d_0\\bmod k)\\\\ \\\\ \u0026……. \\end{align*} $$ 观察结果，可以发现最小的$|dis-d|$之和所有引擎的$gcd$有关，计算$h[]$数组的$gcd$即可。 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, d;cin \u003e\u003e n \u003e\u003e d; vector\u003cll\u003eh(n + 1); for (ll i = 1;i \u003c= n;i++) { cin \u003e\u003e h[i]; } sort(h.begin() + 1, h.end()); ll x = h[n]; for (ll i = n;i \u003e= 1;i--) { x = gcd(x, h[i]); } cout \u003c\u003c min(d % x, x - d % x) \u003c\u003c endl; } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码-1"},{"categories":["在学算法的日子里"],"content":" D-Dominoes!","date":"2024-07-23","objectID":"/posts/nc24sd3/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#d-dominoes"},{"categories":["在学算法的日子里"],"content":" 题意一张多米诺骨牌的左右两端各有一个数字，给出$n$张这样的多米诺骨牌，是否存在一个可以另所有相邻且不在同一张牌上的两个数字不一样的序列。 数据范围 $1\\leq n\\leq 2\\times 10^5$ $1\\leq x_i,y_i\\leq 10^9$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意一张多米诺骨牌的左右两端各有一个数字，给出$n$张这样的多米诺骨牌，是否存在一个可以另所有相邻且不在同一张牌上的两个数字不一样的序列。 数据范围 $1\\leq n\\leq 2\\times 10^5$ $1\\leq x_i,y_i\\leq 10^9$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路首先注意到当 某个数字的数量大于等于$n+2$时，一定没有合法的排列。 而如果符合$\\lt n+2$，一定有合法序列。 如果所有骨牌都满足$x_i\\neq y_i$，则只要满足每次从两侧加入的牌相邻没有相同数字即可，一定有合法序列。 优先考虑排列$x_i=y_i$的骨牌。将$x_i = y_i$的骨牌按照数量从大到小排序，每次选择一张牌，假设这张牌的数字是$p$，之后选择现存数量最多的且符合$x_j = y_j\\neq p$的一张牌，放在右侧，接下来继续取两侧相同骨牌中数目最多的，若两侧相同骨牌数目不足$2$种，则加入任意两侧不同的牌，注意接触端的条件 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll maxn = 2e5 + 50; struct Domi { ll x, y; bool operator==(const Domi\u0026 d)const { return tie(x, y) == tie(d.x, d.y); } bool operator!=(const Domi\u0026 d)const { return tie(x, y) != tie(d.x, d.y); } bool operator\u003c(const Domi\u0026 d)const { return tie(x, y) \u003c tie(d.x, d.y); } }; bool compare(const pair\u003cll, Domi\u003e\u0026 a, const pair\u003cll, Domi\u003e\u0026 b) { if (a.first == b.first)return a.second \u003c b.second; return a.first \u003e b.first; } void solve() { ll n;cin \u003e\u003e n; vector\u003cDomi\u003ev, w; map\u003cll, ll\u003ecnt; for (ll i = 1;i \u003c= n;i++) { ll x, y;cin \u003e\u003e x \u003e\u003e y; if (x \u003e y) { x = x ^ y, y = x ^ y, x = x ^ y; } cnt[x]++, cnt[y]++; if (x == y) v.push_back({ x,y }); else w.push_back({ x,y }); } ll lv = v.size(); ll lw = w.size(); for (auto i : cnt) { if (i.second \u003e= n + 2) { cout \u003c\u003c \"No\\n\"; return; } } cout \u003c\u003c \"Yes\\n\"; if (n == 1) { struct Domi d; if (v.empty()) { d = w.back(); } else { d = v.back(); } cout \u003c\u003c d.x \u003c\u003c \" \" \u003c\u003c d.y \u003c\u003c \"\\n\"; return; } sort(v.begin(), v.end()); ll c = 1; priority_queue\u003cpair\u003cll, Domi\u003e\u003epris; for (ll i = 1;i \u003c lv;i++) { if (v[i] != v[i - 1]) { pris.push({ c,v[i - 1] }); c = 1; } else { c++; } } if (lv) { pris.push({ c,v.back() }); } vector\u003cDomi\u003eans; ll pw = 0; ll las = -1; while (!pris.empty() || pw \u003c lw) { if (pris.empty()) { struct Domi x = w[pw++]; if (x.x == las) { x = { x.y,x.x }; } ans.push_back(x); las = x.y; continue; } auto [cntx, x] = pris.top();pris.pop(); if (las != x.x) { cntx--; if (cntx) { pris.push({ cntx,x }); } ans.push_back(x); las = x.y; continue; } if (pris.empty()) { pris.push({ cntx,x }); x = w[pw++]; if (x.x == las) { x = { x.y,x.x }; } ans.push_back(x); las = x.y; continue; } auto [cnty, y] = pris.top();pris.pop(); pris.push({ cntx,x }); cnty--; if (cnty) { pris.push({ cnty,y }); } ans.push_back(y); las = y.y; } for (auto i : ans) { cout \u003c\u003c i.x \u003c\u003c \" \" \u003c\u003c i.y \u003c\u003c \"\\n\"; } } int main() { ios::sync_with_stdio(false); cin.tie(0); int t = 1; // cin \u003e\u003e t;cin.get(); while (t--)solve(); return 0; } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码-2"},{"categories":["在学算法的日子里"],"content":" E-Malfunctioning Typewriter","date":"2024-07-23","objectID":"/posts/nc24sd3/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#e-malfunctioning-typewriter"},{"categories":["在学算法的日子里"],"content":" 题意有一台打字机，对于每次键入的字符（只有0或1），每次有p的概率正确键入，有$n$句长度为$m$的不会重复的诗句，这些诗句可以以任意顺序组合成一首长度为$n$的诗。询问在打字这首诗的时候，有多大的概率成果打出。 数据范围 $1\\leq n,m\\leq 1000$ $0.5\\leq q\\leq 1$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有一台打字机，对于每次键入的字符（只有0或1），每次有p的概率正确键入，有$n$句长度为$m$的不会重复的诗句，这些诗句可以以任意顺序组合成一首长度为$n$的诗。询问在打字这首诗的时候，有多大的概率成果打出。 数据范围 $1\\leq n,m\\leq 1000$ $0.5\\leq q\\leq 1$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路将$n$句诗建立字典树，对每个节点统计以该结点为前缀的字符串数目。 考虑到只有01，每个节点下最多只有0或1的子节点。记某个节点为$u$，将节点$u$前缀打对的概率可以预处理（$f(x,y)$表示打对$x$个$1$，$y$个$0$的概率），打对一整首诗歌是遍历完字典树上的每个字符串$1$次，对于字典树上的某个非叶子节点，在遍历时，经过该结点的数目是它的子树中有多少个叶子结点决定的，假设有$x$是从该节点（表示一个前缀）往后以1为根节点的子树中的叶子结点数目，$y$是以0为根节点的子树中叶子结点的数目，那么在决策当前是否正确输出了0/1的概率是$f(x,y)$（相当于在当前节点输出正确的$x$个1和$y$个0的概率代表这一步打字输出了$x+y$个合法下行子串的概率），故总概率是$\\prod_u f(sz(lp),sz(rp))$。 对$f(x,y)$的预处理： $$ f(x,y)=\\max(p\\times f(x-1,y)+(1-p)\\times f(x,y),p\\times f(x,y-1)+(1-p)\\times f(x-1,y)) $$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const ll maxn = 1010; int node = 0; int nxt[maxn * maxn][2]; int sz[maxn * maxn]; void triInsert(string s) { int n = s.size(); int p = 0; for (int i = 0;i \u003c n;i++) { int c = s[i] - '0'; if (!nxt[p][c])nxt[p][c] = ++node; sz[nxt[p][c]]++; // 以这个点为前缀的字符串数目 p = nxt[p][c]; } } ld f[maxn][maxn]; void solve() { int n, m;ld p; cin \u003e\u003e n \u003e\u003e m \u003e\u003e p; vector\u003cstring\u003est(n); for (int i = 0;i \u003c n;i++) { string s;cin \u003e\u003e s; triInsert(s); } f[0][0] = 1.0; // 打出0个1,0个0概率为1 for (int x = 0;x \u003c= n;x++) { // f(x,y):恰好正确打出x个1,y个0 for (int y = 0;y \u003c= n;y++) { if (!x \u0026\u0026 !y)continue; ld w = x ? f[x - 1][y] : 0.0; ld v = y ? f[x][y - 1] : 0.0; f[x][y] = max( p * w + (1 - p) * v, p * v + (1 - p) * w ); } } ld ans = 1.0; for (int i = 0;i \u003c= node;i++) { ans *= f[sz[nxt[i][0]]][sz[nxt[i][1]]]; } printf(\"%.12lf\", ans); } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); return 0; } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码-3"},{"categories":["在学算法的日子里"],"content":" J-Rigged Games","date":"2024-07-23","objectID":"/posts/nc24sd3/:5:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#j-rigged-games"},{"categories":["在学算法的日子里"],"content":" 题意比赛由大分比和小分比一同决定最终的胜负，小分比Bo2a-1：先胜出a场为胜。大分比Bo2b-1：先胜出b场为胜。记1次小分比胜负为大分比的一场。 现在有一个长度为$n$的01字符串，字符串是无限循环重复的，用于记录每一次比赛的胜负，从01字符串的每个位置开始比赛，询问谁会赢得整个比赛。 数据范围 $1\\leq n,a,b\\leq 10^5$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意比赛由大分比和小分比一同决定最终的胜负，小分比Bo2a-1：先胜出a场为胜。大分比Bo2b-1：先胜出b场为胜。记1次小分比胜负为大分比的一场。 现在有一个长度为$n$的01字符串，字符串是无限循环重复的，用于记录每一次比赛的胜负，从01字符串的每个位置开始比赛，询问谁会赢得整个比赛。 数据范围 $1\\leq n,a,b\\leq 10^5$ ","date":"2024-07-23","objectID":"/posts/nc24sd3/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路倍增思想，在01循环串中，记录每个位置开始后进行Bo2a-1小局的胜负，以及下一步从哪个位置开始。数组f[i][j]表示从$i$开始进行$2^j$轮后到达的位置、对应的$0$、$1$​的胜利次数。 在统计Bo2b-1时，我们要找到第一次0或1胜利b次以上的位置，将j倒序处理，$2b-1$是最多获得终局的次数，$b$是最少获得终局的次数。假设$b=5$，需要至少$5$局，至多$9$局定胜负，注意到$9=2^3+2^0$，在计数恰好$9$局时，应当只统计先$2^3=8$局，然后往后再统计$2^0=1$局（这里先1后8也不会影响结果，只要保证不超过9局即可）。在计算Bo2b-1的结果时，每次统计恰好$2b-1$。 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:5:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 struct status { int n0, n1; int overpos; }f[maxn][20]; // 从位置i开始结束j小局后的状态 void solve() { ll n, a, b;cin \u003e\u003e n \u003e\u003e a \u003e\u003e b; string s;cin \u003e\u003e s; // 更新Bo2a-1的状态 int w0 = 0, w1 = 0; // 统计0/1胜利多少次 int pos = 0; for (int i = 0;i \u003c n;i++) { // 位置i开始 while (w0 \u003c a \u0026\u0026 w1 \u003c a) { // 未出小局结果 if (s[pos] == '1')w1++; else w0++; pos = (pos + 1) % n; } if (w0 \u003e= a) { f[i][0] = { 1,0,pos }; } else { f[i][0] = { 0,1,pos }; } if (s[i] == '1')w1--; else w0--; // 下一次循环会从i+1开始,减去i位置的分 } // 倍增结果 for (int j = 1;j \u003c 20;j++) { // 枚举进行了2^j局 for (int i = 0;i \u003c n;i++) { // 枚举开始位置 // 第i位置开始进行2^j局=第i开始进行2^(j-1)局+第i开始进行2^(j-1)局后的位置pos开始进行2^(j-1)局 int pos = f[i][j - 1].overpos; f[i][j].overpos = f[pos][j - 1].overpos; f[i][j].n0 = f[i][j - 1].n0 + f[pos][j - 1].n0; f[i][j].n1 = f[i][j - 1].n1 + f[pos][j - 1].n1; } } // 进行Bo2b-1的结果统计 for (int i = 0;i \u003c n;i++) { int w0 = 0, w1 = 0; int tot = 0; int pos = i; for (int j = 0;j \u003c 20;j++) { // 从pos开始进行2^j次比赛,累计0/1的胜利次数 if ((2 * b - 1) \u003e\u003e j \u0026 1) { w0 += f[pos][j].n0; w1 += f[pos][j].n1; pos = f[pos][j].overpos; } } // cout \u003c\u003c w0 \u003c\u003c \" \" \u003c\u003c w1 \u003c\u003c endl; // 出现第一个胜利b次时正确 if (w0 \u003e= b)cout \u003c\u003c '0'; else cout \u003c\u003c '1'; } cout \u003c\u003c \"\\n\"; } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:5:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码-4"},{"categories":["在学算法的日子里"],"content":" L-Sudoku and Minesweeper","date":"2024-07-23","objectID":"/posts/nc24sd3/:6:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#l-sudoku-and-minesweeper"},{"categories":["在学算法的日子里"],"content":" 题意给出一个$9\\times 9$的数独，在这个数独的基础上构造一个扫雷地图，将数独上的一些数字替换为*，但是不能将所有数字都替换为*，使得整个扫雷地图合法。 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:6:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#题意-5"},{"categories":["在学算法的日子里"],"content":" 思路在铺满地雷的地图上保留一些数字，数字8表明该格周围都是*，所以选择保留所有的8，并再次遍历一遍所有的地图（注意边界），删掉不符合要求的8。 或者另一个想法：中间$3\\times 3$的格子中中一定有一个数字8，在去掉除了这个8以外的所有数字之后，这个8一定是符合要求的。 ","date":"2024-07-23","objectID":"/posts/nc24sd3/:6:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 char mp[10][10]; void solve() { for (int i = 1;i \u003c= 9;i++) { for (int j = 1;j \u003c= 9;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] != '8')mp[i][j] = '*'; } } vector\u003cpair\u003cint, int\u003e\u003edxy = { {-1,-1},{-1,0},{-1 ,1}, {0,-1},{0 ,1}, {1,-1},{1,0},{1 ,1}, }; for (int i = 1;i \u003c= 9;i++) { for (int j = 1;j \u003c= 9;j++) { if (mp[i][j] == '*')continue; int x = mp[i][j] - '0'; int y = 0; for (int k = 0;k \u003c 8;k++) { int ii = i + dxy[k].first, jj = j + dxy[k].second; if (ii \u003e= 1 \u0026\u0026 ii \u003c= 9 \u0026\u0026 jj \u003e= 1 \u0026\u0026 jj \u003c= 9) if (mp[ii][jj] == '*') { y++; } } if (x != y)mp[i][j] = '*'; } } for (int i = 1;i \u003c= 9;i++) { for (int j = 1;j \u003c= 9;j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c \"\\n\"; } } ","date":"2024-07-23","objectID":"/posts/nc24sd3/:6:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day3||补题","uri":"/posts/nc24sd3/#代码-5"},{"categories":["在学算法的日子里"],"content":" 1001-循环位移$(709/3775)$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:0","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#1001-循环位移"},{"categories":["在学算法的日子里"],"content":" 题意将字符串$S=S_0+S_1+S_2+…+S_{n-1}$循环位移$k$次后得到$S(k)=S_{k\\bmod n }+…+S_{n-1}+S+0+…+S_{(k-1)\\bmod n}$。 定义$[A]={A(k),k\\in N}$。给出$T$组串$A,B$，询问$B$有多少个子串在$[A]$​中。 数据范围 $|A|\\leq |B|$ $\\sum|B|\\leq 1048576$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#题意"},{"categories":["在学算法的日子里"],"content":" 题意将字符串$S=S_0+S_1+S_2+…+S_{n-1}$循环位移$k$次后得到$S(k)=S_{k\\bmod n }+…+S_{n-1}+S+0+…+S_{(k-1)\\bmod n}$。 定义$[A]={A(k),k\\in N}$。给出$T$组串$A,B$，询问$B$有多少个子串在$[A]$​中。 数据范围 $|A|\\leq |B|$ $\\sum|B|\\leq 1048576$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路 思路1：字符串哈希记字符串$A$的长度是$n$，将字符串$A$转变为首尾相连的样子（$A=A+A.substr(1,n-1)$），并计算其中每个长度为$n$的哈希值，用map存值，再对字符串$B$进行哈希，同样也对长度为$n$的子串计算哈希值，若有符合的则计数。 ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:2","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#思路"},{"categories":["在学算法的日子里"],"content":" 思路 思路1：字符串哈希记字符串$A$的长度是$n$，将字符串$A$转变为首尾相连的样子（$A=A+A.substr(1,n-1)$），并计算其中每个长度为$n$的哈希值，用map存值，再对字符串$B$进行哈希，同样也对长度为$n$的子串计算哈希值，若有符合的则计数。 ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:2","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#思路1字符串哈希"},{"categories":["在学算法的日子里"],"content":" 代码 代码1：字符串哈希 ll ha[maxn], hb[maxn]; ll pwr[maxn]; void solve() { string a, b;cin \u003e\u003e a \u003e\u003e b; ll n = a.size(); a = a.substr(1, n - 1) + a; ll la = a.size(), lb = b.size(); a = \" \" + a, b = \" \" + b; pwr[0] = 1; map\u003cll, bool\u003emp; for (ll i = 1;i \u003c= la;i++) { ha[i] = ha[i - 1] * bas1 + a[i]; pwr[i] = pwr[i - 1] * bas1; if (i - n \u003e= 0) { ll x = ha[i] - ha[i - n] * pwr[n]; mp[x] = true; } } ll ans = 0; for (ll i = 1;i \u003c= lb;i++) { hb[i] = hb[i - 1] * bas1 + b[i]; if (i - n \u003e= 0) { ll x = hb[i] - hb[i - n] * pwr[n]; if (mp.count(x)) { ans++; } } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:3","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#代码"},{"categories":["在学算法的日子里"],"content":" 代码 代码1：字符串哈希 ll ha[maxn], hb[maxn]; ll pwr[maxn]; void solve() { string a, b;cin \u003e\u003e a \u003e\u003e b; ll n = a.size(); a = a.substr(1, n - 1) + a; ll la = a.size(), lb = b.size(); a = \" \" + a, b = \" \" + b; pwr[0] = 1; mapmp; for (ll i = 1;i \u003c= la;i++) { ha[i] = ha[i - 1] * bas1 + a[i]; pwr[i] = pwr[i - 1] * bas1; if (i - n \u003e= 0) { ll x = ha[i] - ha[i - n] * pwr[n]; mp[x] = true; } } ll ans = 0; for (ll i = 1;i \u003c= lb;i++) { hb[i] = hb[i - 1] * bas1 + b[i]; if (i - n \u003e= 0) { ll x = hb[i] - hb[i - n] * pwr[n]; if (mp.count(x)) { ans++; } } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:1:3","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#代码1字符串哈希"},{"categories":["在学算法的日子里"],"content":" 1002-星星$(991/1659)$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:2:0","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#1002-星星"},{"categories":["在学算法的日子里"],"content":" 题意小$A$有$n$次获得星星的机会，第$i$次有如下5种选择： 跳过 $a_i$的代价获得$1$颗星星 $b_i$的代价获得$2$颗星星 $c_i$的代价获得$3$颗星星 $d_i$的代价获得$4$颗星星 请问若想恰好获得$k$颗星星，所需要的最小代价是多少。 数据范围 $1\\leq n\\leq 1000$ $0\\leq k\\leq n\\times 4$ $0\\lt a_i\\leq b_i\\leq c_i\\leq d_i\\leq 10^9$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:2:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意小$A$有$n$次获得星星的机会，第$i$次有如下5种选择： 跳过 $a_i$的代价获得$1$颗星星 $b_i$的代价获得$2$颗星星 $c_i$的代价获得$3$颗星星 $d_i$的代价获得$4$颗星星 请问若想恰好获得$k$颗星星，所需要的最小代价是多少。 数据范围 $1\\leq n\\leq 1000$ $0\\leq k\\leq n\\times 4$ $0\\lt a_i\\leq b_i\\leq c_i\\leq d_i\\leq 10^9$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:2:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路基础的动态规划。记$dp[i]$表示获得$i$颗星星的最小代价。 ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:2:2","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 ll a[maxn], b[maxn], c[maxn], d[maxn]; ll dp[4 * maxn]; void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; for (ll i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i] \u003e\u003e c[i] \u003e\u003e d[i]; } fill(dp, dp + 4 * maxn, inf); dp[0] = 0; for (ll i = 1;i \u003c= n;i++) { ll m = min(k, 4 * i); for (ll j = m;j \u003e= 0;j--) { if (j + 1 \u003c= m) dp[j + 1] = min(dp[j] + a[i], dp[j + 1]); if (j + 2 \u003c= m) dp[j + 2] = min(dp[j] + b[i], dp[j + 2]); if (j + 3 \u003c= m) dp[j + 3] = min(dp[j] + c[i], dp[j + 3]); if (j + 4 \u003c= m) dp[j + 4] = min(dp[j] + d[i], dp[j + 4]); } } cout \u003c\u003c dp[k] \u003c\u003c \"\\n\"; } ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:2:3","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#代码-1"},{"categories":["在学算法的日子里"],"content":" 1008-位运算$(918/1427)$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:3:0","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#1008-位运算"},{"categories":["在学算法的日子里"],"content":" 题意有多少在范围$[0,2^k)$中的$a,b,c,d$构成的四元组$(a,b,c,d)$满足$a \\\u0026 b\\oplus c | d=n$。 数据范围 $1\\leq T\\leq 10$ $1\\leq k\\leq 15,0\\leq n\\lt 2^k$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:3:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有多少在范围$[0,2^k)$中的$a,b,c,d$构成的四元组$(a,b,c,d)$满足$a \\\u0026 b\\oplus c | d=n$。 数据范围 $1\\leq T\\leq 10$ $1\\leq k\\leq 15,0\\leq n\\lt 2^k$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:3:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路记$x=a \\\u0026 b\\oplus c | d$，$x$的每一位只有1和0的可能，而每位上的数字只和$a,b,c,d$对应位是$1$或$0$有关，枚举四个数的$1/0$，统计$x$是$0$的组合和是$1$的组合的数量。再根据$n$的$k$位进行统计即可。 ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:3:2","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; ll cnt[2];cnt[0] = cnt[1] = 0; for (int i = 0;i \u003c= 1;i++) { for (int j = 0;j \u003c= 1;j++) { for (int k = 0;k \u003c= 1;k++) { for (ll l = 0;l \u003c= 1;l++) { ll x = i \u0026 j ^ k | l; cnt[x]++; } } } } vector\u003cint\u003ev; ll ans = 1; for (ll i = 0;i \u003c k;i++) { v.push_back(n \u0026 1); ans *= cnt[n \u0026 1]; n \u003e\u003e= 1; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:3:3","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#代码-2"},{"categories":["在学算法的日子里"],"content":" 1012-并$(241/1229)$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:4:0","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#1012-并"},{"categories":["在学算法的日子里"],"content":" 题意给出在二维平面上的$n$个矩形，随机选择$k$个不同的矩形$(k\\in [1,n])$，求这$k$个矩形所有覆盖部分的并集的面积的期望。 数据范围 $1\\leq n\\leq 2\\times 10^3$ $1\\leq x_{i,1}\\lt x_{i,2} \\leq 10^9$ $1\\leq y_{i,1}\\lt y_{i,2} \\leq 10^9$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:4:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给出在二维平面上的$n$个矩形，随机选择$k$个不同的矩形$(k\\in [1,n])$，求这$k$个矩形所有覆盖部分的并集的面积的期望。 数据范围 $1\\leq n\\leq 2\\times 10^3$ $1\\leq x_{i,1}\\lt x_{i,2} \\leq 10^9$ $1\\leq y_{i,1}\\lt y_{i,2} \\leq 10^9$ ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:4:1","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路将横纵坐标离散化之后可以将这$n$个矩形覆盖的部分分割成不重叠的若干个小矩形，每个小矩形设置权值，代表被原来的$n$个矩形覆盖的次数。设某个小矩形的覆盖次数是$m$，则在选择$k$个矩形时，这个小矩形的贡献是：$\\frac{\\binom{k}{n}-\\binom{k}{n-m}}{\\binom{k}{n}}$（全集-选除该矩形以外的部分），预处理离散后的矩形以及被覆盖$m$次的所有矩形的总面积，枚举计数即可。 ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:4:2","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; const int maxn = 2050; const int mo998 = 998244353; struct Rec { ll x1, y1, x2, y2; }a[maxn]; ll X[maxn * 2], Y[maxn * 2]; ll fact[maxn], invfact[maxn]; // 阶乘,阶乘逆元 ll qpow(ll a, ll b) { ll res = 1; while (b) { if (b \u0026 1)res = res * a % mo998; b \u003e\u003e= 1; a = a * a % mo998; } return res; } ll inv(ll x) { return qpow(x, mo998 - 2); } void init() { // 预处理阶乘,阶乘逆元 fact[0] = invfact[0] = 1ll; for (int i = 1;i \u003c maxn;i++) { fact[i] = fact[i - 1] * i % mo998; invfact[i] = invfact[i - 1] * inv(i) % mo998; } } ll C(int n, int k) { // n选k的方案数 if (k \u003e n)return 0ll; ll res = fact[n] * invfact[k] % mo998 * invfact[n - k] % mo998; return res; } ll Stot[maxn], rec[2 * maxn][2 * maxn]; void solve() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { ll x1, y1, x2, y2; cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; a[i] = { x1,y1,x2,y2 }; X[i] = x1, X[i + n] = x2; Y[i] = y1, Y[i + n] = y2; } sort(X + 1, X + 1 + 2 * n); sort(Y + 1, Y + 1 + 2 * n); int t1 = unique(X + 1, X + 1 + 2 * n) - X - 1; int t2 = unique(Y + 1, Y + 1 + 2 * n) - Y - 1; for (int i = 1;i \u003c= n;i++) { auto [x1, y1, x2, y2] = a[i]; x1 = lower_bound(X + 1, X + 1 + t1, x1) - X; // 值x1在X[]中的位置 x2 = lower_bound(X + 1, X + 1 + t1, x2) - X; y1 = lower_bound(Y + 1, Y + 1 + t2, y1) - Y; y2 = lower_bound(Y + 1, Y + 1 + t2, y2) - Y; // 差分计数 rec[x1][y1]++, rec[x2][y1]--; rec[x1][y2]--, rec[x2][y2]++; } for (int i = 1;i \u003c= t1;i++) { for (int j = 1;j \u003c= t2;j++) { rec[i][j] += rec[i - 1][j] + rec[i][j - 1] - rec[i - 1][j - 1]; } } for (int i = 1;i \u003c t1;i++) { for (int j = 1;j \u003c t2;j++) { // 覆盖rec[i][j]次的矩形的面积 Stot[rec[i][j]] += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) % mo998; Stot[rec[i][j]] %= mo998; } } for (int k = 1;k \u003c= n;k++) { ll ans = 0, Cnk = C(n, k); ll iCnk = inv(Cnk); for (int i = 1;i \u003c= n;i++) { ll Si = Stot[i]; ans += (Cnk - C(n - i, k) + mo998) % mo998 * iCnk % mo998 * Si % mo998; ans %= mo998; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } } int main() { ios::sync_with_stdio(false); cin.tie(0); init(); int t = 1; // cin \u003e\u003e t;cin.tie(0); while (t--) solve(); return 0; } ","date":"2024-07-19","objectID":"/posts/hdu24sd1/:4:3","series":["题解记录"],"tags":["算法","杭电","2024暑假集训"],"title":"2024杭电钉耙编程联赛Day1||补题","uri":"/posts/hdu24sd1/#代码-3"},{"categories":["在学算法的日子里"],"content":" A-Floor Tiles","date":"2024-07-19","objectID":"/posts/nc24sd2/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#a-floor-tiles"},{"categories":["在学算法的日子里"],"content":" 题意存在A型、B型两种砖： 现用这两种砖拼成$N\\times M$的矩形，提问是否有恰好存在$K$条曲线的平铺方式，曲线如下： 数据范围 $1\\leq T\\leq 10^5$ $1\\leq N,M\\leq 800$ $1\\leq K \\leq 2\\times N\\times M$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意存在A型、B型两种砖： 现用这两种砖拼成$N\\times M$的矩形，提问是否有恰好存在$K$条曲线的平铺方式，曲线如下： 数据范围 $1\\leq T\\leq 10^5$ $1\\leq N,M\\leq 800$ $1\\leq K \\leq 2\\times N\\times M$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路边缘一圈的点所在的线一定不是一个环，所以最少的线数相当于都是A型或B型时的线数，也就是$N\\times M$个，若要比$N\\times M$个多，则多的部分只能是图形中环的数目，贪心的让所有的环最小，则能构造出最多的环，最小的环如例图中一样，当平铺的方式是 $$ AB\\\\BA $$ 时，形成的环是最小的。 同时注意到，成环的四块砖块是可以共用的，也就是说在： $$ ABAB\\\\ BABA\\\\ ABAB $$ 中有3个环。 首先构造成环数量最多的$N\\times M$，在输出时记录当前已经拥有多少个环，若超过所需的数量则不再输出可以成环的砖块类型。 ","date":"2024-07-19","objectID":"/posts/nc24sd2/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { int x, y; char ty; int n, m, k; char a = 'A', b = 'B'; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e ty; vector\u003cstring\u003eans(n + 1, string(m + 1, 'X')); for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (abs(i + j - x - y) % 2) { ans[i][j] = a + b - ty; } else { ans[i][j] = ty; } } } int cnt = n + m; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (ans[i][j] == a \u0026\u0026 ans[i][j - 1] == b \u0026\u0026 ans[i - 1][j] == b \u0026\u0026 ans[i - 1][j - 1] == a) cnt++; } } if (cnt \u003c k || k \u003c n + m) { cout \u003c\u003c \"No\\n\"; return; } k -= n + m; cout \u003c\u003c \"Yes\\n\"; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (k \u003e 0) { cout \u003c\u003c ans[i][j]; if (ans[i][j] == a \u0026\u0026 ans[i][j - 1] == b \u0026\u0026 ans[i - 1][j] == b \u0026\u0026 ans[i - 1][j - 1] == a) k--; } else cout \u003c\u003c ty; } cout \u003c\u003c '\\n'; } } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#代码"},{"categories":["在学算法的日子里"],"content":" B-MST","date":"2024-07-19","objectID":"/posts/nc24sd2/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#b-mst"},{"categories":["在学算法的日子里"],"content":" 题意给定一个$n$顶点的带权无向图$G$。 每次询问一个点集$S$，求$S$关于$G$的导出子图的最小生成树的质量，若无则输出-1。 数据范围 $2\\leq n\\leq 10^5$ $1\\leq m,q\\leq 10^5$ $1\\leq w_i \\leq 10^9$ $\\sum k_i\\leq 10^5$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给定一个$n$顶点的带权无向图$G$。 每次询问一个点集$S$，求$S$关于$G$的导出子图的最小生成树的质量，若无则输出-1。 数据范围 $2\\leq n\\leq 10^5$ $1\\leq m,q\\leq 10^5$ $1\\leq w_i \\leq 10^9$ $\\sum k_i\\leq 10^5$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路注意点数$n$和边数$m$的范围都不超过$10^5$，若通过枚举两个点来确定符合条件的边，则复杂度是$O(n^2)$，而如果按照枚举边来确定符合条件的边，复杂度是$O(m)$，于是优化的思路是根据每次$k$和$\\sqrt {maxn}$的大小关系来选择加入边的方式。 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; struct edge { int s, t, w; bool operator\u003c(const edge\u0026 e)const { return w \u003c e.w; } }; vector\u003cvector\u003cedge\u003e\u003egraph; map\u003cpair\u003cint, int\u003e, int\u003egp; int s[maxn]; int fa[maxn]; int findfa(int x) { if (x == fa[x])return x; return fa[x] = findfa(fa[x]); } ll krus(int n, vector\u003cedge\u003esubgraph) { ll res = 0; int cnt = 0; for (auto e : subgraph) { if (cnt == n - 1)break; if (!cnt) { fa[e.t] = e.s; res += e.w; ++cnt; continue; } auto [u, v, w] = e; int fu = findfa(u), fv = findfa(v); if (fu == fv)continue; fa[fu] = fv; res += w; ++cnt; } int fx = findfa(s[1]); for (int i = 2;i \u003c= n;i++) { if (fx != findfa(s[i])) { return -1ll; } } return res; } void solve() { int n, m, q;cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; graph.assign(n + 1, vector\u003cedge\u003e()); for (int i = 0;i \u003c= n;i++)fa[i] = i; for (int i = 1;i \u003c= m;i++) { int u, v, w;cin \u003e\u003e u \u003e\u003e v \u003e\u003e w; graph[u].push_back({ u,v,w }); graph[v].push_back({ v,u,w }); gp[{u, v}] = w; gp[{v, u}] = w; } while (q--) { int k;cin \u003e\u003e k; map\u003cint, bool\u003emp; for (int i = 1;i \u003c= k;i++) { cin \u003e\u003e s[i]; fa[s[i]] = s[i]; mp[s[i]] = true; } vector\u003cedge\u003esubgraph; if (k * k \u003c maxn) { // 点少 // 取出符合要求的边 for (int i = 1;i \u003c= k;i++) { for (int j = i + 1;j \u003c= k;j++) { int u = s[i], v = s[j]; if (gp.count({ u,v })) { int w = gp[{u, v}]; subgraph.push_back({ u,v,w }); } } } } else { for (int i = 1;i \u003c= k;i++) { int u = s[i]; for (auto e : graph[u]) { if (mp.count(e.t)) subgraph.push_back(e); } } } sort(subgraph.begin(), subgraph.end()); cout \u003c\u003c krus(k, subgraph) \u003c\u003c \"\\n\"; } } int main() { int t = 1; while (t--) solve(); return 0; } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路-1"},{"categories":["在学算法的日子里"],"content":" C-Red Walking on Grid","date":"2024-07-19","objectID":"/posts/nc24sd2/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#c-red-walking-on-grid"},{"categories":["在学算法的日子里"],"content":" 题意在一个$2\\times n$​的网格中，每个格子要么是红色（R），要么是白色（W）。每次只能踩在当前格子的上下左右相邻的红色格子上，并且在离开当前的格子之后，当前格子将从红色变为白色，提问最长。 数据范围 $1\\leq n\\leq 10^6$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意在一个$2\\times n$​的网格中，每个格子要么是红色（R），要么是白色（W）。每次只能踩在当前格子的上下左右相邻的红色格子上，并且在离开当前的格子之后，当前格子将从红色变为白色，提问最长。 数据范围 $1\\leq n\\leq 10^6$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路直接从左往右搜索即可，若当前列有红色格子，则它可以由前一列相邻格子的步数+1转移过来，或者是从下方或上方的红色格子转移过来，两者选更优的解作为答案即可。 ","date":"2024-07-19","objectID":"/posts/nc24sd2/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll maxn = 1e6 + 50; const ll mo = 1e9 + 7; ll n; char mp[3][maxn]; ll dp[3][maxn] = { 0 }; void solve() { cin \u003e\u003e n; for (ll i = 1;i \u003c= 2;i++) { for (ll j = 1;j \u003c= n;j++) cin \u003e\u003e mp[i][j]; } mp[1][0] = mp[2][0] = mp[1][n + 1] = mp[2][n + 1] = 'W'; ll ans = 0; for (ll i = 1;i \u003c= n;i++) { if (mp[1][i] == 'R')dp[1][i] = dp[1][i - 1] + 1; if (mp[2][i] == 'R')dp[2][i] = dp[2][i - 1] + 1; if (mp[1][i] == 'R' \u0026\u0026 mp[2][i] == 'R') { ll tmp = dp[1][i]; if (dp[1][i] \u003c dp[2][i] + 1) { dp[1][i] = dp[2][i] + 1; } if (dp[2][i] \u003c tmp + 1) { dp[2][i] = tmp + 1; } } ll tmp = max(dp[1][i], dp[2][i]); ans = max(tmp, ans); } cout \u003c\u003c max(ans - 1, 0ll) \u003c\u003c endl; } int main() { int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#代码-1"},{"categories":["在学算法的日子里"],"content":" E-GCD VS XOR有人卡签到。。。TAT ","date":"2024-07-19","objectID":"/posts/nc24sd2/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#e-gcd-vs-xor"},{"categories":["在学算法的日子里"],"content":" 题意给定正整数$x$，求满足$gcd(x,y)=x\\oplus y$的小于$x$的正整数$y$。若无则打印-1 数据范围 $1\\leq t\\leq 10^4$ $1\\leq x\\leq 10^{18}$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给定正整数$x$，求满足$gcd(x,y)=x\\oplus y$的小于$x$的正整数$y$。若无则打印-1 数据范围 $1\\leq t\\leq 10^4$ $1\\leq x\\leq 10^{18}$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路距离考虑，对于数$x=0b10011010$，考虑异或的性质$A\\oplus 0=A,A\\oplus A=0$，设$x\\oplus y=k$，$y\\lt x$，我们直接构造$k$为$x$最右侧的$1$开始的数，这样的$k$可以满足必然为$x$的倍数，同时，若要满足$gcd(x,y)=k$，构造$y$的时候要满足除了$lowbit(x)$以外的数位都与$x$相同。 ","date":"2024-07-19","objectID":"/posts/nc24sd2/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll N = 1000001; ll lowbit(ll x) { return x \u0026 -x; } void solve() { ll x;cin \u003e\u003e x; ll ans = -1; if (lowbit(x) != x) { ans = x - lowbit(x); } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { int _ = 1; cin \u003e\u003e _;cin.get(); while (_--) solve(); return 0; } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#代码-2"},{"categories":["在学算法的日子里"],"content":" H-Instructions Substring","date":"2024-07-19","objectID":"/posts/nc24sd2/:5:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#h-instructions-substring"},{"categories":["在学算法的日子里"],"content":" 题意有一个操作字符串，由W，S，A，D组成，对应上下左右位移一位，从原点$(0,0)$开始，将操作字符串的一个非空连续子段作为选择的操作，问有多少操作可以经过目标点$(x,y)$。 数据范围 $1\\leq n\\leq 2\\times 10^5$ $-10^5\\leq x,y\\leq 10^5$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意有一个操作字符串，由W，S，A，D组成，对应上下左右位移一位，从原点$(0,0)$开始，将操作字符串的一个非空连续子段作为选择的操作，问有多少操作可以经过目标点$(x,y)$。 数据范围 $1\\leq n\\leq 2\\times 10^5$ $-10^5\\leq x,y\\leq 10^5$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路考虑记录每次操作后的坐标$(u,v)$，对该偏移坐标$(\\Delta x,\\Delta y)$计数，并逐步计算到达目标$(x,y)$需要去除的偏移坐标量$(u-\\Delta x,v - \\Delta y)$，这个需要去掉的操作数乘以当前的步数坐标（去掉$(u-\\Delta x,v-\\Delta y)$之后，从当前步开始，之后不管在哪停下，都是有效的路径数目），之后对该偏移坐标数清零，避免重复计数（之后新出现的只在之后的操作中被计数）。 ","date":"2024-07-19","objectID":"/posts/nc24sd2/:5:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 ll n, x, y; string st; map\u003cchar, pair\u003cll, ll\u003e\u003edxy; map\u003cll, map\u003cll, ll\u003e\u003emp; // mp[i][j]:x位移量为i,y位移量为j的操作数量。 void solve() { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y; cin \u003e\u003e st; dxy['A'] = { 0,-1 }; dxy['D'] = { 0,1 }; dxy['S'] = { -1,0 }; dxy['W'] = { 1,0 }; if (!x \u0026\u0026 !y) { cout \u003c\u003c n * (n + 1) / 2 \u003c\u003c endl; return; } ll ans = 0; ll u = 0, v = 0; mp[0][0] = 1; // 原点形成的符合{0,0}方案数有1个 for (ll i = 0;i \u003c n;i++) { u += dxy[st[i]].second; v += dxy[st[i]].first; if (mp.count(u - x)) { // u-x:当前走了u步，去掉之前在x轴上走过的u-x步可以到目标x轴 if (mp[u - x].count(v - y)) { // 同理 // 满足去除前面的多余x,y位移，之后的操作都是符合要求的。 ans += mp[u - x][v - y] * (n - i); // 这次使用过去除符合要求的位移的操作方案数目了,之后重新出现的相同位移情况需要重新计数。 mp[u - x][v - y] = 0; } } mp[u][v]++; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:5:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#代码-3"},{"categories":["在学算法的日子里"],"content":" I-Red Playing Cards","date":"2024-07-19","objectID":"/posts/nc24sd2/:6:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#i-red-playing-cards"},{"categories":["在学算法的日子里"],"content":" 题意对于一个长度为$2\\times n$的一维数组，$1$到$n$每个元素恰好出现两次。每次操作可以删掉一个长度不小于$2$的首尾相同的连续子数组，获得该连续子数组的首尾元素值乘以元素数量的分数。为最终可以得到多少分。 数据范围 $1\\leq a_i\\leq n\\leq 3000$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:6:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意对于一个长度为$2\\times n$的一维数组，$1$到$n$每个元素恰好出现两次。每次操作可以删掉一个长度不小于$2$的首尾相同的连续子数组，获得该连续子数组的首尾元素值乘以元素数量的分数。为最终可以得到多少分。 数据范围 $1\\leq a_i\\leq n\\leq 3000$ ","date":"2024-07-19","objectID":"/posts/nc24sd2/:6:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路每个数有两个坐标，假设数$i$的坐标为$l_i$和$r_i$，预处理出以数$i$为一个操作时的分数$f(i)$，那么对于区间$[l_i,r_i]$，可以计算其中每个数的贡献（即$i$），若出现满足$l_i\\lt l_j \\lt r_j\\lt r_i $，则用$max(i,j)$代替区间$[l_j,r_j]$的贡献。 计算区间$[l_i,k]$的最大分数$g(k)$，$g(k)$符合： $$ g(k)= \\begin{cases} max(g(k-1) + i,g(l_j-1)+f(j)),\u0026 (k=r_j \\quad and \\quad l_i \\lt l_j)\\\\ g(k-1) + i \u0026 \\end{cases} $$ 直到$k=r_i$，得到$f(i)=g(r_i)$。 ","date":"2024-07-19","objectID":"/posts/nc24sd2/:6:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#思路-5"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(2 * n + 3); map\u003cll, plr\u003eidx; for (ll i = 2;i \u003c= 2 * n + 1;i++) { cin \u003e\u003e a[i]; if (idx.count(a[i])) { idx[a[i]].r = i; idx[a[i]].len = idx[a[i]].r - idx[a[i]].l + 1; } else idx[a[i]].l = i; } // 用0包裹数组，取0这一对不影响结果，但是方便统计最佳分数 a[1] = a[2 * n + 2] = 0ll; idx[0] = { 1,2 * n + 2,2 * n + 2 }; vector\u003cpair\u003cplr, ll\u003e\u003eidv; for (auto i : idx) { idv.push_back({ i.second, i.first }); } sort(idv.begin(), idv.end()); vector\u003cll\u003ef(n + 1); for (auto x : idv) { ll i = x.second; ll li = x.first.l, ri = x.first.r; vector\u003cll\u003eg(2 * n + 2); for (ll k = li;k \u003c= ri;k++) { ll j = a[k]; ll lj = idx[j].l, rj = idx[j].r; if (li \u003c lj \u0026\u0026 k == rj) { g[k] = max(g[k - 1] + i, g[lj - 1] + f[j]); } else { g[k] = g[k - 1] + i; } } f[i] = g[ri]; } cout \u003c\u003c f[0] \u003c\u003c endl; } ","date":"2024-07-19","objectID":"/posts/nc24sd2/:6:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day2||补题","uri":"/posts/nc24sd2/#代码-4"},{"categories":["在学算法的日子里"],"content":" A-Bit Common","date":"2024-07-16","objectID":"/posts/nc24sd1/:1:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#a-bit-common"},{"categories":["在学算法的日子里"],"content":" 题意计算满足长度为$n$，每个元素小于$2^m$，且存在至少一个子序列满足按位$AND$后是$1$的序列的数量。 答案对正整数$q$取模。 数据范围 $1\\leq n,m\\leq 5000$ $1\\leq q\\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#题意"},{"categories":["在学算法的日子里"],"content":" 题意计算满足长度为$n$，每个元素小于$2^m$，且存在至少一个子序列满足按位$AND$后是$1$的序列的数量。 答案对正整数$q$取模。 数据范围 $1\\leq n,m\\leq 5000$ $1\\leq q\\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:1:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路按位分析，对于一个长度为$n$的序列，序列中的数分为$k$个末尾是$1$的数和$n-k$个末尾是$0$的数。 末尾为$1$的数中，除末位以外的数位（$m-1$位），每一位的组合是$2^k-1$种（要除去全为1的情况）。 末尾为$0$的数中，除末位以外数位上的取值是任意的。 选择哪些数是末尾$1$需要考虑组合数。 所以，总方案数是： $$ \\binom{n}{k}\\times (2^k-1)^{m-1}\\times (2^{n-k})^{(m-1)} = \\binom{n}{k}\\times (2^n-2^{n-k})^{m-1} $$ 最后对$q$取模即可。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:1:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const ll maxn = 5050; ll qpow(ll a, ll b, ll m) { // 快速幂 ll res = 1; while (b) { if (b \u0026 1)res = res * a % m; a = a * a % m; b \u003e\u003e= 1; } return res % m; } ll C[maxn][maxn]; void solve() { ll n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; C[0][0] = 1; for (ll i = 1;i \u003c= n;i++) { C[i][0] = 1, C[i][i] = 1; for (ll j = 1;j \u003c i;j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % q; } } ll ans = 0; for (ll k = 1;k \u003c= n;k++) { ll tmp = C[n][k]; ll x = (qpow(2, n, q) - qpow(2, n - k, q) + q) % q; tmp *= qpow(x, m - 1, q); tmp %= q; ans = (ans + tmp + q) % q; } cout \u003c\u003c ans % q \u003c\u003c \"\\n\"; } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); return 0; } ","date":"2024-07-16","objectID":"/posts/nc24sd1/:1:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#代码"},{"categories":["在学算法的日子里"],"content":" B-A Bit More Common","date":"2024-07-16","objectID":"/posts/nc24sd1/:2:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#b-a-bit-more-common"},{"categories":["在学算法的日子里"],"content":" 题意在A题的条件下，增加要求满足存在两个不同的非空子序列$AND$和是$1$。 数据范围 $1\\leq n,m\\leq 5000$ $1\\leq q \\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意在A题的条件下，增加要求满足存在两个不同的非空子序列$AND$和是$1$。 数据范围 $1\\leq n,m\\leq 5000$ $1\\leq q \\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:2:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路有A题的基础，我们已知至少有$1$个子序列的组合数，接下来我们计算只有$1$个子序列的组合数。两者相减即可求出答案。 满足只有1个子序列的组合数所代表的情况是这样的： $$ let:k=3\\\\ 101111\\\\ 010101\\\\ 111011 $$ 需要满足每一个竖列至少有一个特殊的$0$（这个0同时是该数位上唯一的0），且这k个数每个数至少有1个$0$​（条件2）。 对于偶数的组合种数还是不变的，为$\\binom{n}{k}\\times 2^{(n-k)(m-1)}$。 当$k=1$时，子序列是$\\{0b00000001\\}$，只有一个数，剩余的$n-k$个数都是偶数。 当$k\\neq 1$时，考虑：一共有$m-1$个特殊$0$，每个$0$有对应的数位，要将这$m-1$个$0$分配到$k$个位置（位置并不互相区分），每个位置至少有$1$个，也就是第二类斯特林数。 考虑状态转移： 现在有$i$个数，要从$j-1$个特殊位的基础上再增加一个特殊0，这个特殊位要么增加到第$i$个数（第$i$个数已经有至少$1$个特殊$0$）上，要么增加到前$i-1$个（已经至少包含一个特殊$0$的）数上，这两种增加方法都有$i$种不同的方案。 这$i$个数中要包含$j$个特殊$0$的方案数记为$f[i][j]$，则存在递推式： $$ f[i][j]= i\\times (f[i-1][j-1] + f[i][j-1]) $$ 考虑到只有$k$个数中特殊$0$的个数大于等于k时的方案数才是有效的，同时，每个有效方案中，每一列除了作为特殊$0$的位置以外的位置都可以任意填（只要不是全1或者只有1个特殊$0$的情况），故这$k$个奇数的方案总数是$\\sum_{t=k}^{m-1} f[k][t]\\times (2^k-1-k)^{m-1-t}$，再乘此时的偶数方案数，即为$k$时的总数。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:2:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 ll qpow(ll a, ll b, ll m) { // 快速幂 ll res = 1; a %= m; while (b) { if (b \u0026 1)res = res * a % m; a = a * a % m; b \u003e\u003e= 1; } return res % m; } ll C[maxn][maxn]; ll f[maxn][maxn]; void solve() { ll n, m, q; cin \u003e\u003e n \u003e\u003e m \u003e\u003e q; C[0][0] = 1ll; for (ll i = 1;i \u003c= 5000;i++) { C[i][0] = 1, C[i][i] = 1; for (ll j = 1;j \u003c= 5000;j++) { C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % q; } } ll ans = 0; for (ll k = 1;k \u003c= n;k++) { ll tmp = C[n][k]; ll x = (qpow(2ll, n, q) - qpow(2ll, n - k, q) + q) % q; tmp *= qpow(x, m - 1ll, q); tmp %= q; ans = (ans + tmp + q) % q; } ll res = qpow(2ll, (n - 1) * (m - 1) % q, q) * n % q; // 存在1个子序列AND=1的，减去只有1个子序列AND=1的 f[0][0] = 1ll; for (ll i = 1;i \u003c= 5000;i++) { for (ll j = i;j \u003c= 5000;j++) { f[i][j] = i * ((f[i - 1][j - 1] + f[i][j - 1]) % q) % q; } } for (ll k = 2;k \u003c= n;k++) { ll tmp = qpow(2ll, (n - k) * (m - 1) % q, q) % q * C[n][k] % q; ll tmp2 = (qpow(2ll, k, q) - 1ll - k + q) % q; ll cur = 1ll; for (ll t = m - 1;t \u003e= k;t--) { res = (res + f[k][t] * cur % q * C[m - 1][t] % q * tmp % q) % q; cur = tmp2 * cur % q; } } cout \u003c\u003c (ans - res + q) % q \u003c\u003c \"\\n\"; } ","date":"2024-07-16","objectID":"/posts/nc24sd1/:2:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#代码-1"},{"categories":["在学算法的日子里"],"content":" C-Sum of Suffix Sums","date":"2024-07-16","objectID":"/posts/nc24sd1/:3:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#c-sum-of-suffix-sums"},{"categories":["在学算法的日子里"],"content":" 题意维护一个初始为空的非负整数序列，支持$q$次如下操作： 每次移除末尾的$t$个整数，然后在末尾假如一个整数$v$，操作后输出当前序列所有后缀和的总和，答案对$10^9+7$取模。 数据范围 $1\\leq q\\leq 5\\times 10^5$ $0\\leq v\\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意维护一个初始为空的非负整数序列，支持$q$次如下操作： 每次移除末尾的$t$个整数，然后在末尾假如一个整数$v$，操作后输出当前序列所有后缀和的总和，答案对$10^9+7$取模。 数据范围 $1\\leq q\\leq 5\\times 10^5$ $0\\leq v\\leq 10^9$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:3:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路每个数对后缀和总和的贡献是它当前位置的序号乘以它本身的值，也就是$a_i$的贡献是$a_i\\times i$​。根据这个特点和数据范围，我们可以维护后缀和总和。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:3:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#思路-2"},{"categories":["在学算法的日子里"],"content":" 代码 void solve() { ll q;cin \u003e\u003e q; vector\u003cll\u003ea; ll tot = 0; while (q--) { ll t, v;cin \u003e\u003e t \u003e\u003e v; v %= mo; for (ll i = 0;i \u003c t;i++) { if (a.empty())break; ll x = a.back(); tot -= x * a.size(); tot = (tot + mo) % mo; a.pop_back(); } a.push_back(v); ll n = a.size() % mo; tot = (tot + v * n % mo + mo) % mo; cout \u003c\u003c tot \u003c\u003c \"\\n\"; } } ","date":"2024-07-16","objectID":"/posts/nc24sd1/:3:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#代码-2"},{"categories":["在学算法的日子里"],"content":" H-World Finals签到题。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:4:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#h-world-finals"},{"categories":["在学算法的日子里"],"content":" 题意lzr010506队伍可以参加46th的WF和47th的WF，这两个WF将同时举行，所以lzr010506必须选择其中一个参加。lzr010506可以预知每个队伍的在比赛中的成绩（过题数和罚时），排名规则为过题数多优先，过题数相同则罚时少优先。 除了lzr010506队伍，还有其他有资格参加两场比赛的队伍。提问，在给出所有队伍的预测成绩之后，lzr010506队伍能够获得的最好成绩排名是多少。 数据范围 $1 \\leq number of teams \\leq 105$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意lzr010506队伍可以参加46th的WF和47th的WF，这两个WF将同时举行，所以lzr010506必须选择其中一个参加。lzr010506可以预知每个队伍的在比赛中的成绩（过题数和罚时），排名规则为过题数多优先，过题数相同则罚时少优先。 除了lzr010506队伍，还有其他有资格参加两场比赛的队伍。提问，在给出所有队伍的预测成绩之后，lzr010506队伍能够获得的最好成绩排名是多少。 数据范围 $1 \\leq number of teams \\leq 105$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:4:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路最优情况是，除了lzr010506队伍，同时可以参加两场比赛的队伍都参加lzr010506队伍没有参加那一场，然后计算最佳排名即可。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:4:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#思路-3"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct team { string s; ll p, t; bool operator\u003c(const team\u0026 other)const { if (other.p == p)return other.t \u003e t; return other.p \u003c p; } }; void solve() { ll n;cin \u003e\u003e n; vector\u003cteam\u003et46(n); map\u003cstring, bool\u003emp46; for (ll i = 0;i \u003c n;i++) { string s; ll p, t; cin \u003e\u003e s \u003e\u003e p \u003e\u003e t; t46[i] = { s,p,t }; mp46[s] = true; } ll m;cin \u003e\u003e m; vector\u003cteam\u003et47(m); map\u003cstring, bool\u003eboth; for (ll i = 0;i \u003c m;i++) { string s; ll p, t; cin \u003e\u003e s \u003e\u003e p \u003e\u003e t; t47[i] = { s,p,t }; if (mp46.count(s)) { both[s] = true; } } sort(t46.begin(), t46.end()); sort(t47.begin(), t47.end()); string st = \"lzr010506\"; ll rk = min(n, m); ll cnt = 1; for (ll i = 0;i \u003c n;i++) { if (t46[i].s == st) { rk = min(cnt, rk); break; } if (both.count(t46[i].s))continue; cnt++; } cnt = 1; for (ll i = 0;i \u003c m;i++) { if (t47[i].s == st) { rk = min(cnt, rk); break; } if (both.count(t47[i].s))continue; cnt++; } cout \u003c\u003c rk \u003c\u003c \"\\n\"; } int main() { int t = 1; // cin \u003e\u003e t;cin.get(); while (t--) solve(); return 0; } ","date":"2024-07-16","objectID":"/posts/nc24sd1/:4:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#代码-3"},{"categories":["在学算法的日子里"],"content":" I-Mirror Maze补出这题ddl也是死而无憾了。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:5:0","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#i-mirror-maze"},{"categories":["在学算法的日子里"],"content":" 题意在$n\\times m$​的矩阵镜子迷宫里，给出一个点光源，光的传播与镜子的类型\\、|、-、/有关（详情戳这）。 提问经过足够长的时间后，这束光被多少个不同的镜子反射过。 数据范围 $1\\leq n,m \\leq 1000$ $1\\leq q\\leq 10^5$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意在$n\\times m$​的矩阵镜子迷宫里，给出一个点光源，光的传播与镜子的类型\\、|、-、/有关（详情戳这）。 提问经过足够长的时间后，这束光被多少个不同的镜子反射过。 数据范围 $1\\leq n,m \\leq 1000$ $1\\leq q\\leq 10^5$ ","date":"2024-07-16","objectID":"/posts/nc24sd1/:5:1","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路考虑到光路可逆，在迷宫中的所有可能存在的光路必然是链或者环，不会出现分叉或者是汇集。考虑数据范围$1\\leq n,m\\leq 1000$和光的方向有上下左右4个，可以通过记忆化搜索来记录已经搜索过的状态，保证每次搜索的复杂度在$n\\times m$以内，总复杂度不超过$4\\times n\\times m$。 具体搜索方法见代码。 ","date":"2024-07-16","objectID":"/posts/nc24sd1/:5:2","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#思路-4"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; map\u003cpair\u003cll, char\u003e, ll\u003eredir; void initRedir() { redir[{1, '|'}] = 1; redir[{1, '-'}] = 2; redir[{1, '/'}] = 4; redir[{1, '\\\\'}] = 3; redir[{2, '|'}] = 2; redir[{2, '-'}] = 1; redir[{2, '/'}] = 3; redir[{2, '\\\\'}] = 4; redir[{3, '|'}] = 4; redir[{3, '-'}] = 3; redir[{3, '/'}] = 2; redir[{3, '\\\\'}] = 1; redir[{4, '|'}] = 3; redir[{4, '-'}] = 4; redir[{4, '/'}] = 1; redir[{4, '\\\\'}] = 2; } bool vis[1005][1005][5] = { false }, visp[1005][1005] = { false }; ll n, m; char maz[1005][1005]; ll mem[1005][1005][5] = { 0 }; ll circlelen; ll dfs(ll u, ll v, ll dr, ll cnt) { if (u\u003c1 || u\u003en || v\u003c1 || v\u003em) { // 通过边界出射的点是链型光路 vis[u][v][dr] = false;visp[u][v] = false; mem[u][v][dr] = cnt; return cnt; } if (vis[u][v][dr]) { // 因为访问过同样状态结束搜索的是环形光路 vis[u][v][dr] = false;visp[u][v] = false; circlelen = cnt; return cnt; } if (mem[u][v][dr])return mem[u][v][dr]; vis[u][v][dr] = true; ll rdr = redir[{dr, maz[u][v]}]; if (!visp[u][v] \u0026\u0026 dr != rdr) { cnt++; visp[u][v] = true; } if (rdr == 1) cnt = dfs(u - 1, v, 1, cnt); else if (rdr == 2) cnt = dfs(u + 1, v, 2, cnt); else if (rdr == 3) cnt = dfs(u, v - 1, 3, cnt); else cnt = dfs(u, v + 1, 4, cnt); // 回溯时复原状态 vis[u][v][dr] = false; visp[u][v] = false; // 若是环形光路，在dfs回溯时mem应该记录为环形路径的长度 if (circlelen) mem[u][v][dr] = circlelen; return cnt; } void solve() { cin \u003e\u003e n \u003e\u003e m; for (ll i = 1;i \u003c= n;i++) { for (ll j = 1;j \u003c= m;j++) { cin \u003e\u003e maz[i][j]; } } // pre(); ll q;cin \u003e\u003e q; while (q--) { ll u, v;string dir; cin \u003e\u003e u \u003e\u003e v \u003e\u003e dir; ll dr; if (dir == \"above\") { dr = 1;u--; } else if (dir == \"below\") { dr = 2;u++; } else if (dir == \"left\") { dr = 3; v--; } else if (dir == \"right\") { dr = 4; v++; } circlelen = 0; ll ans = dfs(u, v, dr, 0); cout \u003c\u003c ans \u003c\u003c endl; } } int main() { initRedir(); int t = 1; // cin \u003e\u003e t; cin.get(); while (t--) solve(); return 0; } ","date":"2024-07-16","objectID":"/posts/nc24sd1/:5:3","series":["题解记录"],"tags":["2024暑假集训","算法","牛客"],"title":"2024牛客暑假多校训练营Day1||补题","uri":"/posts/nc24sd1/#代码-4"},{"categories":["我们需要更多的鱼"],"content":" 前言本篇记录利用 github action 实现自动化构建和部署的过程。 本站除了部署在 github page 上，还部署在本人的服务器上，懒惰的 ddl 直到现在才去上手实验，因此利用在 github action 中实现两种部署方式。 ","date":"2024-07-05","objectID":"/posts/github_action/:1:0","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#前言"},{"categories":["我们需要更多的鱼"],"content":" Github ActionGithub Action 是 Github 提供的持续集成服务，可以在代码仓库中配置 workflow，实现自动化构建、测试、部署等功能。 有一些术语需要了解： Workflow：一个 workflow 由一个或多个 job 组成，可以在不同的操作系统环境中运行。 Job：一个 job 由一系列 step 组成，可以在同一个 runner 上运行。 Step：一个 step 由一个或多个 action 组成，可以在同一个 runner 上运行。 Action：一个 action 是一个独立的任务，可以在不同的 runner 上运行。 ","date":"2024-07-05","objectID":"/posts/github_action/:2:0","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#github-action"},{"categories":["我们需要更多的鱼"],"content":" 配置这里我使用的是 github action 自带的SSH Deploy action，使用 ssh 链接远程服务器，将代码部署到服务器上。使用方法可以参考这里。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:0","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#配置"},{"categories":["我们需要更多的鱼"],"content":" 1. 创建 SSH Key 并添加到 github secrets首先需要在服务器上生成一个 SSH Key，用于 github action 登录服务器。 ssh-keygen -m PEM -t rsa -b 4096 key 的生成过程中会提示输入密码，可以不输入，直接回车，默认保存在/root/.ssh目录下（这个可能不同的服务器环境会有区别，具体的默认位置在生成ssh-key的时候命令行有提示。 生成的 key 包含一个私钥id_rsa和一个公钥id_rsa.pub，私钥保存在本地，我们需要将公钥添加到服务器的/root/.ssh/authorized_keys文件中。 cat ./id_rsa.pub \u003e\u003e /root/.ssh/authorized_keys 考虑到我们并不想把私钥暴露在 github 公开仓库上，我们需要将私钥id_rsa添加到 github 的 secrets 中。 在仓库的Settings-\u003eSecurity-\u003eSecrets and variables-\u003eActions中，选择New repository secret，添加一个SSH_PRIVATE_KEY，将私钥内容粘贴进去。 再新建三个 secrets，分别是REMOTE_HOST、REMOTE_USER、REMOTE_TARGET，分别对应服务器的地址、用户名、目标路径。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:1","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#1-创建-ssh-key-并添加到-github-secrets"},{"categories":["我们需要更多的鱼"],"content":" 2. 创建 workflow在代码仓库的.github/workflows目录下创建一个.yml文件，文件名可以自定义，如deploy.yml。 一个库可以有多个 workflow，github 只要发现.github/workflows目录下有.yml文件，就会自动运行 workflow。 内容可以参考如下： name: Deploy # 触发条件 on: push: branches: [main] workflow_dispatch: # 手动触发 jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install Node.js uses: actions/setup-node@v3 with: node-version: \"16.x\" - name: ssh deploy uses: easingthemes/ssh-deploy@v5.0.3 with: SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }} ARGS: \"-rlgoDzvc -i\" SOURCE: \"\" REMOTE_HOST: ${{ secrets.REMOTE_HOST }} REMOTE_USER: ${{ secrets.REMOTE_USER }} TARGET: ${{ secrets.REMOTE_TARGET }} 向 github 仓库 push 代码之后，我们在Actions选项卡中可以看到 workflow 的运行情况。假如运行失败，可以点进去查看具体的错误信息，进行调试。 之后每次 push 到 main 分支或者手动触发 workflow，github action 就会自动运行 workflow，将代码部署到服务器上。 ","date":"2024-07-05","objectID":"/posts/github_action/:3:2","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#2-创建-workflow"},{"categories":["我们需要更多的鱼"],"content":" 更新 2024-09-22之前部署的时候只上传了public/文件夹，最近有同步源码的需求，但是源码包含一些隐私信息，并不适合上传到 github 的公开仓库，所以现在的需求是： 将源码上传到一个私有仓库 从私有仓库中将public/文件夹同步到\u003cusername\u003e.github.io公开仓库中，并部署到github page 因此新增了一个在源码仓库根目录下的 workflow，将源码上传到私有仓库，通过 hugo 官方提供的 action，将生产的站点文件同步到\u003cusername\u003e.github.io公开仓库中。 ","date":"2024-07-05","objectID":"/posts/github_action/:4:0","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#更新-2024-09-22"},{"categories":["我们需要更多的鱼"],"content":" 创建私有仓库首先在 github 上创建一个私有仓库，用于存放源码。 ","date":"2024-07-05","objectID":"/posts/github_action/:4:1","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#创建私有仓库"},{"categories":["我们需要更多的鱼"],"content":" 创建 personal access token在 github 的Settings-\u003eDeveloper settings-\u003ePersonal access tokens中，点击Generate new token，勾选repo权限，生成一个 token，将 token 复制下来。 ","date":"2024-07-05","objectID":"/posts/github_action/:4:2","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#创建-personal-access-token"},{"categories":["我们需要更多的鱼"],"content":" 添加 secrets在源码仓库的Settings-\u003eSecurity-\u003eSecrets and variables-\u003eActions中，添加一个ACTION_ACCESS_TOKEN，将刚刚生成的 token 粘贴进去，这个命名要和 workflow 文件中的一致。 ","date":"2024-07-05","objectID":"/posts/github_action/:4:3","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#添加-secrets"},{"categories":["我们需要更多的鱼"],"content":" 创建 workflow在私有仓库的.github/workflows目录下创建一个gh-page.yml文件。 文件内容如下： name: github pages deploy on: push: branches: - main permissions: contents: read jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 # 引用actions/checkout这个action，与所在的github仓库同名 with: submodules: flase # 是否获取子模块 fetch-depth: 0 - name: Install Node.js uses: actions/setup-node@v3 - name: Setup Hugo # 步骤名自取 uses: peaceiris/actions-hugo@v3 # hugo官方提供的action，用于在任务环境中获取hugo with: hugo-version: \"latest\" # 获取最新版本的hugo extended: true - name: Build run: hugo --minify # 使用hugo构建静态网页 - name: Deploy uses: peaceiris/actions-gh-pages@v4 # 一个自动发布github pages的action with: # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo external_repository: Florae006/Florae006.github.io # 发布到哪个repo personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }} # 发布到其他repo需要提供上面生成的personal access token publish_dir: ./public/ # 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容 keep_files: true # 是否保留其他文件 publish_branch: main # 发布到哪个branch commit_message: ${{ github.event.head_commit.message }} # 提交信息 由于现在的xxx.github.io对应的仓库是在GitHub action中构建站点后直接commit同步的，故原来在公开仓库中的workflows并不方便添加到这个commit里，我这里的解决思路是将原来ssh连接云服务器进行deploy的代码进行修改，添加自动构建内容，再直接用ssh连接到云服务器，完成云服务器的内容更新。修改后的remote-deploy.yml参考如下： name: Deploy to remote server # 触发条件 on: push: branches: [ main ] workflow_dispatch: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Install Node.js uses: actions/setup-node@v3 with: node-version: '16.x' - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' extended: true - name: Build run: hugo --minify - name: ssh deploy uses: easingthemes/ssh-deploy@v5.1.0 with: SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }} ARGS: \"-rlgoDzvc -i\" REMOTE_HOST: ${{ secrets.REMOTE_HOST }} REMOTE_USER: ${{ secrets.REMOTE_USER }} TARGET: ${{ secrets.REMOTE_TARGET }} SOURCE: \"public/\" # SCRIPT_BEFORE: | # whoami # ls -al # SCRIPT_AFTER: | # cd ${{ secrets.REMOTE_TARGET }} # ls -al # pwd # echo \"Deployed successfully\" ","date":"2024-07-05","objectID":"/posts/github_action/:4:4","series":[],"tags":["Github Action","自动化部署"],"title":"Github Action实践","uri":"/posts/github_action/#创建-workflow"},{"categories":["在学算法的日子里"],"content":"GYM地址：2024吉林省赛 题目顺序按照从易到难排序。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:0:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#"},{"categories":["在学算法的日子里"],"content":" I. The Easiest Problem","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#i-the-easiest-problem"},{"categories":["在学算法的日子里"],"content":" 题意数一数 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:1","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve() { string s = \"Scan the QR code to sign in now.\"; ll cnt = 0; for (auto c : s) { if (c \u003c= 'z' \u0026\u0026 c \u003e= 'a')cnt++; } cout \u003c\u003c cnt \u003c\u003c endl; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; // cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:1:2","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码"},{"categories":["在学算法的日子里"],"content":" L. Recharge","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#l-recharge"},{"categories":["在学算法的日子里"],"content":" 题意有$x$次获得$1$格能量的机会，$y$次获得$2$格能量的机会，充满一个电池需要$k$格能量，溢出的能量会被浪费，问最多能充满多少电池。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:1","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; void solve() { ll k, x, y;cin \u003e\u003e k \u003e\u003e x \u003e\u003e y; if (k == 1) { cout \u003c\u003c x + y \u003c\u003c \"\\n\";return; } ll ans = 0; if (k \u0026 1) { ll yi = k / 2; if (x \u003c= y / yi) { ans += x; y -= x * yi; x = 0; ans += y / (yi + 1); } else { ans += y / yi; x -= (y / yi); y -= (y / yi) * yi; if (y * 2 + x \u003e= k) { ans += 1;x -= (k - 2 * y);y = 0; } ans += x / k; } } else { ll tot = x + 2 * y; ans = tot / k; } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:2:2","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-1"},{"categories":["在学算法的日子里"],"content":" G. Platform Game","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#g-platform-game"},{"categories":["在学算法的日子里"],"content":" 题意在二维平面中有$n$个平台，每个平台有一个高度$h_i$，以及一个左端点$l_i$和右端点$r_i$。机器人从$(x,y)$出发，保持向右前进，如果遇到平台端点则会垂直下落，问机器人最终的落点。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:1","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-2"},{"categories":["在学算法的日子里"],"content":" 思路排序题，按照高度从高到低、左端点从小到大排序，遍历平台，如果机器人在平台上则更新机器人的位置。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:2","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct PLAT { ll l, r, y; operator\u003c(const PLAT\u0026 P)const { if (y == P.y)return l \u003c P.l; return y \u003e P.y; } }; void solve() { ll n;cin \u003e\u003e n; vector\u003cPLAT\u003eplats; for (ll i = 0;i \u003c n;i++) { ll l, r, y;cin \u003e\u003e l \u003e\u003e r \u003e\u003e y; plats.push_back({ l,r,y }); } sort(plats.begin(), plats.end()); ll sx, sy;cin \u003e\u003e sx \u003e\u003e sy; for (auto p : plats) { if (p.l \u003c sx \u0026\u0026 p.r \u003e= sx \u0026\u0026 p.y \u003c sy) { sy = p.y; sx = p.r; } } cout \u003c\u003c sx \u003c\u003c \"\\n\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; cin \u003e\u003e _;cin.get(); while(_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:3:3","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-2"},{"categories":["在学算法的日子里"],"content":" D. Parallel Lines","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#d-parallel-lines"},{"categories":["在学算法的日子里"],"content":" 题意二维平面上有$k$条平行线，这些直线上有$n$个点，已知每条直线上至少有$2$个点。现在给出$n$个点，找出这$k$条平行线（用点表示）。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:1","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-3"},{"categories":["在学算法的日子里"],"content":" 数据范围$2 \\leq n \\leq 10^4$ $1 \\leq k \\leq \\min(50, \\frac{n}{2})$ ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:2","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路注意$k$的范围，$k$最多为$50$，可以枚举$k$来选择平行线的斜率，对于$k$条平行线，当我选择了$k+1$个点时，这$k+1$个点中必然至少有两个点之间的斜率是$k$条平行线的斜率。 确定斜率$k_i$之后，我们分别计算过每个点斜率为$k_i$的直线在$y$轴上的截距，并计数相同截距的点的数目，注意垂直于$x$轴的情况。 只有同时符产生截距数目恰好为$k$，且每个截距的点数目至少为$2$时，我们才找到了所要的$k$条平行线。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:3","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路-1"},{"categories":["在学算法的日子里"],"content":" 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; typedef double ld; struct Point { ll x, y; }; void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cPoint\u003epoints(n); map\u003cll, vector\u003cll\u003e\u003erx; for (ll i = 0;i \u003c n;i++) { cin \u003e\u003e points[i].x \u003e\u003e points[i].y; rx[points[i].x].push_back(i + 1); } if (rx.size() == k) { bool f = true; for (auto i : rx) { if (i.second.size() \u003c 2) { f = false;break; } } if (f) { for (auto i : rx) { cout \u003c\u003c i.second.size() \u003c\u003c \" \"; for (auto j : i.second) { cout \u003c\u003c j \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return; } } ll b = 1000000; map\u003cll, bool\u003empk; for (ll i = 0;i \u003c k + 1;i++) { for (ll j = i + 1;j \u003c k + 1;j++) { ll px = points[i].x, py = points[i].y, qx = points[j].x, qy = points[j].y; if (px == qx) { continue; } ld ki = 1.0 * (py - qy) / (px - qx); ll kk = (ll)(ki * b); if (mpk.count(kk) == 0)mpk[kk] = true; } } for (auto kk : mpk) { ld ki = 1.0 * kk.first / b; map\u003cll, vector\u003cll\u003e\u003ecnt; for (ll i = 0;i \u003c n;i++) { ll x = points[i].x, y = points[i].y; ld bi = y - ki * x; ll bb = (ll)(bi * b); cnt[bb].push_back(i + 1); if (cnt.size() \u003e k)break; } if (cnt.size() == k) { bool f = true; for (auto i : cnt) { if (i.second.size() \u003c 2) { f = false;break; } } if (!f)continue; for (auto i : cnt) { cout \u003c\u003c i.second.size() \u003c\u003c \" \"; for (auto j : i.second) { cout \u003c\u003c j \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; } return; } } } int main() { ios::sync_with_stdio(false); cin.tie(0); int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); return 0; } ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:4:4","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#代码-3"},{"categories":["在学算法的日子里"],"content":" E. Connected Components","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:0","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#e-connected-components"},{"categories":["在学算法的日子里"],"content":" 题意有$n$个王国，编号从$1$到$n$，每个王国有两个属性值$a_i$和$b_i$，如果两个王国的属性值满足$a_i - a_j \\leq i - j \\leq b_i - b_j$或$a_j - a_i \\leq j - i \\leq b_j - b_i$，则这两个王国是相连的。问有多少个连通块。 ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:1","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#题意-4"},{"categories":["在学算法的日子里"],"content":" 数据范围$1 \\leq n \\leq 10^6$ ","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:2","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路","date":"2024-07-05","objectID":"/posts/24jilinccpc/:5:3","series":["题解记录"],"tags":["算法"],"title":"2024吉林省赛补题记录","uri":"/posts/24jilinccpc/#思路-2"},{"categories":["在学习计算机系统的日子里"],"content":"记录CS-APP Datalab实验过程","date":"2024-07-04","objectID":"/posts/datalab/","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/"},{"categories":["在学习计算机系统的日子里"],"content":" 0. before start实验需要的材料在这里：CSAPP Datalab CSAPP原书在线阅读 将datalab-handout.tar下载复制到计划用来实验的目录下，解压： tar xvf datalab-handout.tar 解压之后，文件中bit.c是包含13个编程题中每个题的骨架。实验要求是使用没有任何循环或条件语句，以及有限的c算术和逻辑运算符来完成其中每个函数的内容，只能使用如下8个运算符： ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e ","date":"2024-07-04","objectID":"/posts/datalab/:1:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#0-before-start"},{"categories":["在学习计算机系统的日子里"],"content":" 测评在btest文件夹中，包含了一个测试程序，可以用来测试我们的实现是否正确。我们可以通过make命令编译btest，然后运行： # 编译并运行 make \u0026\u0026 ./btest # 对某个函数进行单元测试 make \u0026\u0026 ./btest -f bitXnor # 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推 make \u0026\u0026 ./btest -f bitXnor -1 7 -2 0xf dlc：用于检查我们的实现是否符合实验要求： ./dlc bits.c 接下来，按照难度从易到难，我们依次完成实验 ","date":"2024-07-04","objectID":"/posts/datalab/:1:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#测评"},{"categories":["在学习计算机系统的日子里"],"content":" 1. bitXor异或等价于不是同0且不是同1。 ","date":"2024-07-04","objectID":"/posts/datalab/:2:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#1-bitxor"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 //1 /* * bitXor - x^y using only ~ and \u0026 * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026 * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~x\u0026~y)\u0026~(x\u0026y); } ","date":"2024-07-04","objectID":"/posts/datalab/:2:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码"},{"categories":["在学习计算机系统的日子里"],"content":" 2. tmin获得对2补码的最小int值。在C中，int是32位的，所以补码的最小值就是符号位为1，其余位为0的值，对0x1左移31位即可。 ","date":"2024-07-04","objectID":"/posts/datalab/:3:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#2-tmin"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * tmin - return minimum two's complement integer * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u003c\u003c 31; } ","date":"2024-07-04","objectID":"/posts/datalab/:3:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-1"},{"categories":["在学习计算机系统的日子里"],"content":" 3. isTmax判断$x$是否是int的最大整数。最大整数tmax应该为0x7fffffff。 题目提示不允许使用移位操作。 注意到： $$ Tmax=0x7fffffff,Tmin=0x80000000\\\\ so,that:Tmax=\\sim Tmin,Tmax+1 = Tmin\\\\ -Tmin = \\sim Tmin + 1 = Tmax + 1 = Tmin\\\\ so,that:\\\\ -(\\sim Tmax) = Tmax + 1 = \\sim Tmax\\\\ $$ 也就是说，假如~x的相反数与~x相等，则满足x=Tmax。 注意除了Tmax拥有这个性质，当x=-1时： $$ x=0xffffffff\\\\ \\sim x=0x00000000\\\\ -(\\sim x)=\\sim (\\sim x)+1 = x+1 = 0x00000000 $$ 也满足这个上述特点，需要排除。 ","date":"2024-07-04","objectID":"/posts/datalab/:4:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#3-istmax"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isTmax - returns 1 if x is the maximum, two's complement number, * and 0 otherwise * Legal ops: ! ~ \u0026 ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !!(~x)\u0026!((~x)^(x+1)); } 提示 注意返回值是int型的，所以需要使用!!将结果转换为0或1。 ","date":"2024-07-04","objectID":"/posts/datalab/:4:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-2"},{"categories":["在学习计算机系统的日子里"],"content":" 4. allOddBits当$x$中所有奇数位都为$1$时返回true。 奇数位都为$1$的数形如： $$ x=0b1x_{30}1x_{28}1…1x_{2}1x_{0} $$ 思路是构造偶数位都为$1$的掩码0x55555555，再与$x$按位取或，若能构造出0xffffffff则复合要求。 由于实验要求不允许使用长度超过8位的常量，所以通过移位操作来构造掩码。 ","date":"2024-07-04","objectID":"/posts/datalab/:5:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#4-alloddbits"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int mask = 0x55 + (0x55 \u003c\u003c 8); mask = mask + (mask \u003c\u003c 16); return !(~(mask | x)); } ","date":"2024-07-04","objectID":"/posts/datalab/:5:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-3"},{"categories":["在学习计算机系统的日子里"],"content":" 5. negate返回$x$的相反数。 这个操作在第三个实验里其实已经使用过了。 $$ -x=\\sim x + 1 $$ ","date":"2024-07-04","objectID":"/posts/datalab/:6:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#5-negate"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:6:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-4"},{"categories":["在学习计算机系统的日子里"],"content":" 6. isAsciDigit判断$x$是否是ASCII码0~9中的某一个，即判断$0x30\\leq x\\leq 0x39$。 注意到$0x30\\sim 0x39$的低4位从$0000\\sim 1001$，低5~8位为$0011$，可以分别判断。 在满足低5~8位为$0011$的前提下，若倒数第4位为0则符合要求，若倒数第4位为1则需判断是否为$1000$或$1001$，即中间2位是否是0。 ","date":"2024-07-04","objectID":"/posts/datalab/:7:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#6-isascidigit"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isAsciiDigit - return 1 if 0x30 \u003c= x \u003c= 0x39 (ASCII codes for characters '0' to '9') * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { int f3 = !((x \u003e\u003e 4) ^ 3); int f0t9 =!! (!(x \u0026 8) + !(x \u0026 6)); return f3 \u0026 f0t9; } ","date":"2024-07-04","objectID":"/posts/datalab/:7:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-5"},{"categories":["在学习计算机系统的日子里"],"content":" 7. conditional实现出w =( x ? y : z)的条件判断。 感觉在上个题就实现了，上题相当于对一个二进制数$x=x_4 x_3 x_2 x_1$，是否满足$(x_4 == 1)?(x \u0026 6 == 0):1$。 判断$x$通过!!x获得0/1，再通过按位取反+1分别获得0x00000000和0xffffffff，再与$y$和$z$按位或并相加，获得结果。 ","date":"2024-07-04","objectID":"/posts/datalab/:8:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#7-conditional"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { int f = !!x; int mask = ~f + 1; return (y \u0026 mask) + (z \u0026 ~mask); } ","date":"2024-07-04","objectID":"/posts/datalab/:8:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-6"},{"categories":["在学习计算机系统的日子里"],"content":" 8. isLessOrEqual判断是否符合$x\\leq y$的关系。 首先比较符号位，若符号位相同，则判断$x-y\\leq 0$是否成立。减号可以由按位取反+1获得相反数，再相加实现。 ","date":"2024-07-04","objectID":"/posts/datalab/:9:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#8-islessorequal"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * isLessOrEqual - if x \u003c= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int fx = x \u003e\u003e 31; int fy = y \u003e\u003e 31; int f = fx ^ fy; int z = x + ~y + 1; return !!((f \u0026 fx) | ((!f) \u0026 ((!z) | z \u003e\u003e 31))); } ","date":"2024-07-04","objectID":"/posts/datalab/:9:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-7"},{"categories":["在学习计算机系统的日子里"],"content":" 9. logicalNeg实现逻辑取反，$x$非0返回0，$x$为0返回1。 通过取反+1获得相反数，如果x是0，其相反数与x拥有相同的符号位0，否则在x和其相反数两个数之间一定会有至少一个符号位为1。 在Tmin = 0x80000000中也一致，-Tmin = ~Tmin + 1 = 0x7fffffff + 1 = 0x80000000。 ","date":"2024-07-04","objectID":"/posts/datalab/:10:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#9-logicalneg"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { return (((~x + 1) | x) \u003e\u003e 31) + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:10:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-8"},{"categories":["在学习计算机系统的日子里"],"content":" 10. howManyBits计算出表示$x$​需要的最少补码位数。 $$ 0=0b0,1bit\\\\ 1=0b01,2bits\\\\ -1=0b1,1bit\\\\ 2=0b010,3bits\\\\ -2=0b10,2bits\\\\ 3=0b011,3bits\\\\ -3=0b101,3bits $$ 如果是正数的话x补码形如：0x00001...，所需补码位数是从左向右第一个1的位置在+1（符号位），负数的话x补码形如：0x11110...，取反之后是0x00001...，所需位数是从左向右第一个1的位置+1。 不能通过循环来从左向右找，尝试二分找第一个1的位置。 int型有32位，逐渐二分为16、8、4、2、1位。 $$ \\begin{aligned} \u0026x = 0b0001,1…,….,….,….,….,….,….\\\\ loop1:\u0026 !!(x»16)=1,b16=16\\\\ \u0026\\text{高16位存在1，则可以舍去低16位，将x右移16位}\\\\ \u0026x = x»16=0b0001,1…,…,…\\\\ loop2:\u0026… \\end{aligned} $$ 最后统计完毕之后要+1符号位。 ","date":"2024-07-04","objectID":"/posts/datalab/:11:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#10-howmanybits"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* howManyBits - return the minimum number of bits required to represent x in * two's complement * Examples: howManyBits(12) = 5 * howManyBits(298) = 10 * howManyBits(-5) = 4 * howManyBits(0) = 1 * howManyBits(-1) = 1 * howManyBits(0x80000000) = 32 * Legal ops: ! ~ \u0026 ^ | + \u003c\u003c \u003e\u003e * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { int f = !!(x \u003e\u003e 31); f = ~f + 1; x = (x \u0026 ~f) + (~x \u0026 f); int b16 = (!!(x \u003e\u003e 16)) \u003c\u003c 4; x = x \u003e\u003e b16; int b8 = (!!(x \u003e\u003e 8)) \u003c\u003c 3; x = x \u003e\u003e b8; int b4 = (!!(x \u003e\u003e 4)) \u003c\u003c 2; x = x \u003e\u003e b4; int b2 = (!!(x \u003e\u003e 2)) \u003c\u003c 1; x = x \u003e\u003e b2; int b1 = !!(x \u003e\u003e 1); x = x \u003e\u003e b1; return b16 + b8 + b4 + b2 + b1 + x + 1; } ","date":"2024-07-04","objectID":"/posts/datalab/:11:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-9"},{"categories":["在学习计算机系统的日子里"],"content":" 11. floatScale2求一个float浮点数乘2之后的值。 float的各位： 符号 指数(exp) 尾数 1 8 23 0/1 0x01111111+e 小数部分 通过定义先按指数是否为0x00000000或0x11111111、≠0 \u0026 ≠255分类。 对规格化数进行指数+1（若+1后为255则返回无穷大） 非规格化数保持符号位不变，左移一位（注意：若尾数最左边一位为1时，乘2后恰好是规格化数，故保留符号位整体左移即可） 无穷大保持不变 NaN保持不变。 ","date":"2024-07-04","objectID":"/posts/datalab/:12:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#11-floatscale2"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ unsigned floatScale2(unsigned uf) { unsigned s = uf \u0026 0x80000000; unsigned exp = uf \u0026 0x7f800000; unsigned f = uf \u0026 0x007fffff; if(!exp){ return s | (uf \u003c\u003c 1); } if(!(exp ^ 0x7f800000)){ return uf; } exp = exp + 0x00800000; if(exp == 0x7f800000){ return 0x7f800000 | s; } return s | (exp \u0026 0x7f800000) | f; } ","date":"2024-07-04","objectID":"/posts/datalab/:12:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-10"},{"categories":["在学习计算机系统的日子里"],"content":" 12. floatFloat2Int将float浮点数转化为int类型。 算出真实的Exp：Exp + 0b0111111 = e， 再给尾数最左侧补一位1，整体右移|Exp-23|位（舍位），再通过正负性取补码。 注意，若溢出或是NaN返回0x80000000u ","date":"2024-07-04","objectID":"/posts/datalab/:13:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#12-floatfloat2int"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. also if, while * Max ops: 30 * Rating: 4 */ int floatFloat2Int(unsigned uf) { unsigned s = uf \u0026 0x80000000, e = uf \u0026 0x7f800000, f = uf \u0026 0x007fffff; int exp = (e \u003e\u003e 23) - 0x7f; unsigned res = f | 0x00800000; if(exp \u003c 0) return 0; if(exp \u003e= 31) return 0x80000000; if(exp \u003c 23)exp = 23 - exp; else exp = exp - 23; res = res \u003e\u003e exp; if(s)return -res; else return res; } ","date":"2024-07-04","objectID":"/posts/datalab/:13:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-11"},{"categories":["在学习计算机系统的日子里"],"content":" 13. floatPower2求浮点表示下的$2.0$的$x$次。 emmm其实就是exp + x，那就处理好$0b000000$和$0b11111111$的情况就好了。 ","date":"2024-07-04","objectID":"/posts/datalab/:14:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#13-floatpower2"},{"categories":["在学习计算机系统的日子里"],"content":" 代码 /* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, \u0026\u0026. Also if, while * Max ops: 30 * Rating: 4 */ unsigned floatPower2(int x) { int exp = 0x7f + x; if(exp \u003c 0x00)return 0; if(exp \u003e= 0xff)return 0x7f800000; if(exp == 0x00)return 1; return exp \u003c\u003c 23; } 写完哩~最后一个样例似乎跑了好久（。 ","date":"2024-07-04","objectID":"/posts/datalab/:14:1","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#代码-12"},{"categories":["在学习计算机系统的日子里"],"content":" 总结碎碎念做完实验第一次感觉到!f和~f的区别（迫真。 下个实验再见(∪.∪ )…zzz ","date":"2024-07-04","objectID":"/posts/datalab/:15:0","series":["CS:APP实验记录"],"tags":["CSAPP"],"title":"CS-APP Datalab","uri":"/posts/datalab/#总结碎碎念"},{"categories":[],"content":" 更新日志 2024.7.4 计划有变，换成DoIt主题，正在优化搬运中… 2024.7.3 更换主题为LoveIt，正在优化搬运中… 评论区支持上传图片功能，但是请勿上传违规图片，否则会被删除。 已设置评论回复邮件提醒，欢迎留言哦~ 2023.11.28 建站，初次上传 ","date":"2024-07-04","objectID":"/comments/:0:0","series":[],"tags":[],"title":"留言板","uri":"/comments/#更新日志"},{"categories":[],"content":" 留言板 ","date":"2024-07-04","objectID":"/comments/:0:0","series":[],"tags":[],"title":"留言板","uri":"/comments/#留言板"},{"categories":[],"content":"友链 挂挂","date":"2024-07-04","objectID":"/links/","series":[],"tags":[],"title":"友達です！","uri":"/links/"},{"categories":[],"content":" 友链 思想犯 一个活的相对失败的 CSer Windlinxy 测试岗牛马的失败生活 DODOLA-github.io ddlの初始域名自链接 YorkWu's Blog ddl:一个很强的学长QwQ！！ 无双 ddl:是很强的陈老师！ Roses NENU 唯一懂 C++ 的人 Echo 的小窝 漂泊于互联网中的小窝 KAMIASUKA’s Blog Patience is key in life 松種小窝 花开又花落，时节暗中迁 幻雪的博客 腐烂于花海，致死于所爱 ✨️✨️ 本站友链信息： name: DODOLA url: https://dodolalorc.cn/ avatar: https://dodolalorc.cn/img/dodola.png bio: Wit beyond measure is man’s greatest treasure. ✨️✨️ 申请友链信息格式： name: #名称 url: #链接 avatar: #头像 bio: #站点描述 ","date":"2024-07-04","objectID":"/links/:1:0","series":[],"tags":[],"title":"友達です！","uri":"/links/#友链"},{"categories":[],"content":" 🎇🎇 友链申请要求 QwQ🎉 本站支持交换友链，在您提出申请之前，请将本站添加至友链 🏵️ 为了保障本站用户，本站仅支持个人网站的友链申请 🍧 申请本站友链需要拥有独立域名（非免费域名），建议开启全站 HTTPS 💐 友链中的链接信息需要保证可以正常访问哦 🍖 站内文章能持续更新，没有太多广告 🎴 感谢您对本站的支持，如果您已经满足上述要求，请在下方评论区提交友链申请~~~ ","date":"2024-07-04","objectID":"/links/:1:1","series":[],"tags":[],"title":"友達です！","uri":"/links/#-友链申请要求-qwq"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 一篇学习 MutationObserver 的文章 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:0:0","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 背景今天调整新主题的时候，在重新设计友链样式的时候想保留原本的随机背景颜色，之前数量少的时候似乎不太明显，现在本地测试发觉加载太慢了。于是上网寻找解决思路，找到了 MutationObserver 这个 API，于是就学习了一下//此处记录一下学习过程。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:1:0","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#背景"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 需求分析我有不知数量的div元素，每个div元素都有一个class名为friend-link-div，我需要在每个单个的div元素被加载完成的同时，对它设置一个随机的背景颜色。而不是等待整个页面或窗口加载完毕 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:2:0","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#需求分析"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 想法分析","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:0","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#想法分析"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" window.onload和'DOMContentLoaded'的问题原本的实现代码： window.onload=function () { const randomHex = () =\u003e `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 0.5)`; var friendArr=document.getElementsByClassName(\"friend-div\"),temp=[]; for(var i=0;i\u003cfriendArr.length;i++){ friendArr[i].style.background=randomHex(); } } 原本的思路就是简单的在页面加载完成后，获取所有的友链元素，然后给每个元素设置一个随机的背景颜色。但是这样的实现方式有一个问题，就是当友链数量较多的时候，会导致页面加载变慢，因为每次都要重新计算随机颜色，并且在等待本页面加载的时候，友链的背景颜色是白色的，这样会导致页面的视觉体验不好。 在网上询问得到的另一个思路是用document.addEventListener('DOMContentLoaded', function() {})，但是这个方法也是等待整个页面加载完毕后才会执行，观察发现还是挺慢的…所以也不适合。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:1","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#windowonload和domcontentloaded的问题"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 仅利用CSS实现随机色彩的思路还有一个仅利用CSS实现随机色彩的思路，该思路是在CSS中定义一个颜色数组，然后通过nth-child选择器来实现，但是这样的实现方式有一个问题，就是颜色的数量是固定的，而且颜色的选择是有规律的，不是真正的随机颜色。 不过还是展示一下如何伪随机实现： .friend-link-div:nth-child(1) { background: #f00; } .friend-link-div:nth-child(2) { background: #0f0; } .friend-link-div:nth-child(3) { background: #00f; } .friend-link-div:nth-child(4) { background: #ff0; } ... 搭配scss的话可以这样写： $colors: #f00, #0f0, #00f, #ff0, #f0f, #0ff, #000, #fff; @for $i from 1 through length($colors) { .friend-link-div:nth-child(#{$i}) { background: nth($colors, $i); } } 于是放弃window.onload和'DOMContentLoaded'，以及CSS的伪随机实现方法。改用 MutationObserver 来实现。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:3:2","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#仅利用css实现随机色彩的思路"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 解决思路使用MutationObserver API来观察DOM的变化，并在新的盒子被添加到DOM中时应用背景色更改。这样，每当有新的盒子被添加到页面上时，你就可以立即更改它的背景，而不需要等待其他内容加载完成。 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:0","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#解决思路"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 代码 // 定义一个生成随机背景色的函数 const randomHex = () =\u003e `rgba(${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, 0.5)`; // 遍历所有已经存在的盒子，为每个盒子设置随机背景色 document.querySelectorAll('.friend-link-div').forEach(div =\u003e { div.style.background = randomHex(); }); // 定义一个回调函数，用于处理每当DOM树中添加新节点时的操作 const callback = function (mutationsList, observer) { for (const mutation of mutationsList) { if (mutation.type === 'childList' \u0026\u0026 mutation.addedNodes.length \u003e 0) { mutation.addedNodes.forEach(node =\u003e { // 检查是否为目标盒子节点 if (node.nodeType === 1 \u0026\u0026 node.classList.contains('friend-link-div')) { // 更改背景色 node.style.background = randomHex(); } }); } } }; // 创建MutationObserver实例 const observer = new MutationObserver(callback); // 配置观察选项：观察子节点的添加 const config = { childList: true, subtree: true }; // 选择要观察变化的DOM节点（在这个例子中，是body，但你可以根据需要更改） const targetNode = document.body; // 启动观察 observer.observe(targetNode, config); ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:1","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#代码"},{"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"content":" 关于用于hugo主题的一些Tips有的时候DOM初始化时已经存在一些盒子，因此我们需要在初始化时为这些盒子设置随机背景色。然后，我们创建一个MutationObserver实例，并配置它以观察DOM树中的子节点添加。最后，我们选择要观察变化的DOM节点（在这个例子中是body，但你可以根据需要更改），并启动观察。 假如直接将js插入到friend.html中，打开控制台会发现该段js被渲染了好多次，这是因为hugo的模板渲染机制导致的，所以我们需要将js放在整个大页面的js中，这样就不会出现重复渲染的问题了。 一个合适的地方是在layouts/partials/footer.html中，这样就可以保证在整个页面加载完毯后再执行这段js。 不过直接放在footer.html中也会有一个问题，就是我们只需要在友链页面加载这段js，而不是每个页面都加载，所以我们可以在footer.html中加入一个判断条件，判断当前页面是否是友链页面，如果是则加载这段js。 可以在content/links.md中加入一个isLink字段，然后在footer.html中判断是否为友链页面，如果是则加载这段js。 {{ if .Params.isLink }} \u003cscript\u003e // 代码 \u003c/script\u003e {{ end }} 假如不想每次都把新增的js直接写在footer.html等地方中，可以在static/js/文件夹下新建一个js文件，然后在footer.html中引入这个js文件。 {{ if .Params.isLink }} \u003cscript src=\"/js/_extended/friend-link.js\"\u003e\u003c/script\u003e {{ end }} 另注：githubPage是jekyll模板似乎不能识别下划线开头的文件，所以有需要的话可以把_extended改成其他名字。 完成！现在，每当新的friend-link-div盒子被添加到DOM中时，它的背景颜色将立即更改为随机颜色。 可以在本站的友链页面查看效果：友链 ","date":"2024-07-04","objectID":"/posts/mutationobserver/:4:2","series":[],"tags":["前端","JavaScript"],"title":"MutationObserver学习+实践","uri":"/posts/mutationobserver/#关于用于hugo主题的一些tips"},{"categories":["关于Hugo的一些设置"],"content":" 一篇私有配置图床，给twikoo评论插件添加图片功能的文章。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:0:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#"},{"categories":["关于Hugo的一些设置"],"content":" 背景背景：最近回想起来本站的twikoo评论尚未配置过图床，所以此前评论区不能上传图片，这篇就记录一下twikoo官方推荐的lsky-pro私有部署图床。 选用的图床是兰空图床👉lsky-org/lsky-pro: ☁️兰空图床(Lsky Pro) - Your photo album on the cloud. (github.com) 文档：Lsky Pro 服务器环境： 宝塔面板 8.0.6 PHP 8.0.26 MySQL 5.7.43 Nginx 1.22.1 要注意版本哦( ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:1:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#背景"},{"categories":["关于Hugo的一些设置"],"content":" 添加站点进入宝塔后，在左侧网站导航页内点击添加站点，新建一个网站，配置如图： ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:2:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#添加站点"},{"categories":["关于Hugo的一些设置"],"content":" 配置站点在Releases · lsky-org/lsky-pro (github.com)选择Assets中的第一个.zip下载下来。定位到上述创建的站点的根目录(/www/wwwroot/img.dodolalorc.cn)下，将解压后的文件放在该目录下。 将程序所在目录的所有文件夹、子文件夹、文件的权限，用户组和所有者改为 www，权限改为 0755 回到网站导航页，点击刚刚创建的站点，进行如下修改： 网站目录下，将网站目录中的路径后添加/public，并保存 Nginx需要设置伪静态，点击伪静态，添加如下代码并保存： location / { try_files $uri $uri/ /index.php?$query_string; } 在SSL中，申请Let's Encrypt证书，申请成功并安装保存之后，在证书页开启强制HTTPS ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:3:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#配置站点"},{"categories":["关于Hugo的一些设置"],"content":" PHP扩展+禁用函数根据文档所提示的安装要求，我们需要添加两个扩展：Fileinfo PHP 扩展和Imagick 拓展。 在宝塔软件商店内搜索使用的PHP，点击管理，在安装扩展中选择下载fileinfo和imagemagick扩展。 在禁用函数页面，删除exec、shell_exec、readlink、symlink、putenv、getenv、chmod、chown、fileperms 函数。 若由于可用内存小于1G，没有安装上fileinfo，可以在软件商店搜索找到Linux工具箱，在工具箱中的Swap/虚拟内存中添加Swap，设置为1024MB并确定，重试即可。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:4:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#php扩展禁用函数"},{"categories":["关于Hugo的一些设置"],"content":" 安装程序在完成上述内容后，访问站点，显示符合要求之后，点击下一步，填写配置后进行安装。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:5:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#安装程序"},{"categories":["关于Hugo的一些设置"],"content":" 获取token在站点的仪表盘页，点击接口，复制接口URL。 在这个网站Getman.cn，按照这个格式填写： { \"email\": \"管理员邮箱\", \"password\":\"管理员密码\" } ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:6:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#获取token"},{"categories":["关于Hugo的一些设置"],"content":" 配置Twikoo获取到token后，在twikoo管理页，IMAGE_CDN 配置图床首页 URL 地址（注意不要加尾随斜杠），IMAGE_CDN_TOKEN填入刚刚获取的token。 保存后，即可上传图片。 ","date":"2024-05-29","objectID":"/posts/twikoo_with_imgs/:7:0","series":null,"tags":["Twikoo"],"title":"为twikoo添加图片功能","uri":"/posts/twikoo_with_imgs/#配置twikoo"},{"categories":["在前端搬砖的日子里"],"content":" Vue3+Vite+Svg以前使用Svg的时候会图简单直接将内容巨长的Svg代码粘贴在项目中，结果导致需要用Svg图标的部分代码巨长，今天写项目又需要使用Svg了，于是想着对其进行封装。 ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:0:0","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#vue3vitesvg"},{"categories":["在前端搬砖的日子里"],"content":" 插件安装使用vite-plugin-svg-icons插件。 安装： npm i vite-plugin-svg-icons -D 在src/assets/下新建icon文件夹，这个文件夹下存放我们以后要用的.svg文件。 ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:0","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#插件安装"},{"categories":["在前端搬砖的日子里"],"content":" 配置vite.config.ts import {createSvgIconsPlugin} from 'vite-plugin-svg-icons'; export default defineConfig({ //... plugins:[ //... createSvgIconsPlugin({ iconDirs:[ // 自己的svg存放目录 path.resolve(process.cwd(),'src/assets/icon'), ], symbolId:'icon-[name]', // 设置symbol的id }) ] }) ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:1","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#配置viteconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 在main.ts中加入： import 'virtual:svg-icons-register'; ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:2","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#在maints中加入"},{"categories":["在前端搬砖的日子里"],"content":" 封装SvgIcon组件在src/components/新建SvgIcon文件夹，在其中新建index.vue，内容： \u003cscript lang=\"ts\" setup\u003e const props = defineProps({ name: { type: String, required: true }, color: { type: String, default: '#ccc' }, width: { type: String, default: '1em' }, height: { type: String, default: '1em' }, }); const symbleId = `#icon-${props.name}`; \u003c/script\u003e \u003ctemplate\u003e \u003csvg aria-hidden=\"true\" class=\"svg-icon\" :width=\"width\" :height=\"height\"\u003e \u003cuse :xlink:href=\"symbleId\" :fill=\"color\" /\u003e \u003c/svg\u003e \u003c/template\u003e \u003cstyle scoped\u003e \u003c/style\u003e 之后就能在页面使用svg啦。 \u003ctemplate\u003e \u003cSvgIcon name=\"dashboard\" color=\"red\" width=\"50px\" height=\"50px\"/\u003e \u003c/template\u003e ","date":"2024-03-23","objectID":"/posts/vue_svgicon/:1:3","series":null,"tags":["Vue","Vite","Svg","组件","前端"],"title":"Vue3封装一个SVG组件","uri":"/posts/vue_svgicon/#封装svgicon组件"},{"categories":["在学算法的日子里"],"content":" 线段树介绍 线段树是一棵二叉树，每个节点维护一个区间内$[l,r]$的信息 左子树区间维护$[l,\\lfloor \\frac{l+r}{2} \\rfloor]$的信息，右子树维护$[\\lfloor \\frac{l+r}{2} \\rfloor+1,r]$的信息 节点信息可以由两个子节点合并得到 任意一个区间会被分为线段树上$O(\\log n)$个节点 线段树可以在$O(\\log N)$的时间复杂度内实现单点修改、区间修改、**区间查询（区间求和/区间最大值/区间最小值）**等操作。 线段树一般解决类似这样的问题： 已知一个数列，你需要进行下面几种操作： 将某区间每一个数加上 $k$。（修改） 求出某区间每一个数的和。（查询） 将某区间的每个数修改为$x$。（修改） 求某区间的最大值/最小值。（查询） ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:0","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树介绍"},{"categories":["在学算法的日子里"],"content":" 建树 实现递归实现 struct segTreeNode { ll d = 0ll, lazy = 0ll; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); // 左边 build(m + 1, r, (p \u003c\u003c 1) | 1); // 右边 tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#建树"},{"categories":["在学算法的日子里"],"content":" 建树 实现递归实现 struct segTreeNode { ll d = 0ll, lazy = 0ll; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); // 左边 build(m + 1, r, (p \u003c\u003c 1) | 1); // 右边 tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:1:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现"},{"categories":["在学算法的日子里"],"content":" 查询\u0026修改\u0026求值","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:0","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#查询修改求值"},{"categories":["在学算法的日子里"],"content":" 区间查询进行区间查询的时候，区间和节点区间的关系有三种可能： 当前要查询的区间与正在询问的区间没有交集，返回空 当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值 当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况 实现 ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#区间查询"},{"categories":["在学算法的日子里"],"content":" 区间查询进行区间查询的时候，区间和节点区间的关系有三种可能： 当前要查询的区间与正在询问的区间没有交集，返回空 当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值 当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况 实现 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-1"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (cr\u003cl || cl\u003er)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (cr\u003cl || cl\u003er)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (cr\u003cl || cl\u003er)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#区间修改懒标记"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-2"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#参考"},{"categories":["在学算法的日子里"],"content":" 区间修改（懒标记）区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。 假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。 思考： 当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。 实现 void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } 相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。 ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } 例题指路： 区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板1：实现区间加/求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazy; // 数据\u0026懒标记 bool used; // 标记是否修改过 }; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { if (l == r) { tree[p].d = a[l]; return; } int m = l + ((r - l) \u003e\u003e 1); build(l, m, p \u003c\u003c 1); build(m + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } void update(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x // if (crr)return; if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].lazy += x; return; } int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].d += tree[p].lazy * (m - cl + 1); tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p \u003c\u003c 1].lazy += tree[p].lazy; tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p].lazy = 0ll; } if (m \u003e= l)update(l, r, cl, m, p \u003c\u003c 1, x); if (m \u003c r)update(l, r, m + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d; } ll getsum(int l, int r, int cl, int cr, int p) { // if (crr)return 0ll; // 操作正确的话不可能会出现这种情况 if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int m = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazy) { tree[p \u003c\u003c 1].lazy += tree[p].lazy, tree[(p \u003c\u003c 1) | 1].lazy += tree[p].lazy; tree[p \u003c\u003c 1].d += tree[p].lazy * (m + 1 - cl), tree[(p \u003c\u003c 1) | 1].d += tree[p].lazy * (cr - m); tree[p].lazy = 0; } ll sum = 0ll; if (m \u003e= l) sum += getsum(l, r, cl, m, p \u003c\u003c 1); if (m \u003c r) sum += getsum(l, r, m + 1, cr, (p \u003c\u003c 1) | 1); return sum; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (m--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; update(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } 思考相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？ ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:2","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#思考"},{"categories":["在学算法的日子里"],"content":" 例题1（两种懒标记）P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 操作 1： 格式：1 x y k 含义：将区间$[x,y]$内每个数乘上k 操作 2： 格式：2 x y k 含义：将区间$[x,y]$ 内每个数加上k 操作 3： 格式：3 x y 含义：输出区间 $[x,y]$ 内每个数的和对m取模所得的结果 这题需要考虑两种修改值的操作之间的相互影响。 每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递 判断时应该先乘后加 参考 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板2：实现区间加+乘、求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazyPlus, lazyTime; /*TIP:在开结构体vector时已有初始值会使所有初始值塞入程序，会导致编译时间过长+内存溢出*/ bool used; // 标记是否修改过 }; ll mo; vector\u003cll\u003ea(maxn); // 原数据 vector\u003csegTreeNode\u003etree(maxn * 4); void build(int l, int r, int p) { tree[p].lazyTime = 1ll; if (l == r) { tree[p].d = a[l] % mo; return; } int mid = l + ((r - l) \u003e\u003e 1); build(l, mid, p \u003c\u003c 1); build(mid + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void pd(int cl, int cr, int p) { int l = p \u003c\u003c 1; int r = (p \u003c\u003c 1) | 1; // 先乘后加 if (tree[p].lazyTime != 1ll) { tree[l].lazyTime *= tree[p].lazyTime; tree[r].lazyTime *= tree[p].lazyTime; tree[l].lazyTime %= mo; tree[r].lazyTime %= mo; // 对子节点懒标记乘 tree[l].lazyPlus *= tree[p].lazyTime; tree[r].lazyPlus *= tree[p].lazyTime; tree[l].lazyPlus %= mo; tree[r].lazyPlus %= mo; // 对子节点数值乘 tree[l].d *= tree[p].lazyTime; tree[r].d *= tree[p].lazyTime; tree[l].d %= mo; tree[r].d %= mo; tree[p].lazyTime = 1ll; } int mid = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazyPlus) { tree[l].d += tree[p].lazyPlus * (mid - cl + 1); tree[l].d %= mo; tree[r].d += tree[p].lazyPlus * (cr - mid); tree[r].d %= mo; tree[l].lazyPlus += tree[p].lazyPlus; tree[l].lazyPlus %= mo; tree[r].lazyPlus += tree[p].lazyPlus; tree[r].lazyPlus %= mo; tree[p].lazyPlus = 0ll; } } void updateTime(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都乘上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].lazyTime *= x; tree[p].lazyTime %= mo; tree[p].lazyPlus *= x; tree[p].lazyPlus %= mo; tree[p].d *= x; tree[p].d %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updateTime(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updateTime(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].d %= mo; tree[p].lazyPlus += x; tree[p].lazyPlus %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updatePlus(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int mid = cl + ((cr - cl) \u003e\u003e 1); pd(cl, cr, p); ll sum = 0ll; if (mid \u003e= l) sum += getsum(l, r, cl, mid, p \u003c\u003c 1); sum %= mo; if (mid \u003c r) sum += getsum(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1); return sum % mo; } void solve() { int n, q;cin \u003e\u003e n \u003e\u003e q \u003e\u003e mo; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (q--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updateTime(x, y, 1, n, 1, k); } else if (op == 2) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updatePlus(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:3","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#例题1两种懒标记"},{"categories":["在学算法的日子里"],"content":" 例题1（两种懒标记）P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 操作 1： 格式：1 x y k 含义：将区间$[x,y]$内每个数乘上k 操作 2： 格式：2 x y k 含义：将区间$[x,y]$ 内每个数加上k 操作 3： 格式：3 x y 含义：输出区间 $[x,y]$ 内每个数的和对m取模所得的结果 这题需要考虑两种修改值的操作之间的相互影响。 每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递 判断时应该先乘后加 参考 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 10; /* 线段树模板2：实现区间加+乘、求和的模板 洛谷P3372 */ struct segTreeNode { ll d, lazyPlus, lazyTime; /*TIP:在开结构体vector时已有初始值会使所有初始值塞入程序，会导致编译时间过长+内存溢出*/ bool used; // 标记是否修改过 }; ll mo; vectora(maxn); // 原数据 vectortree(maxn * 4); void build(int l, int r, int p) { tree[p].lazyTime = 1ll; if (l == r) { tree[p].d = a[l] % mo; return; } int mid = l + ((r - l) \u003e\u003e 1); build(l, mid, p \u003c\u003c 1); build(mid + 1, r, (p \u003c\u003c 1) | 1); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void pd(int cl, int cr, int p) { int l = p \u003c\u003c 1; int r = (p \u003c\u003c 1) | 1; // 先乘后加 if (tree[p].lazyTime != 1ll) { tree[l].lazyTime *= tree[p].lazyTime; tree[r].lazyTime *= tree[p].lazyTime; tree[l].lazyTime %= mo; tree[r].lazyTime %= mo; // 对子节点懒标记乘 tree[l].lazyPlus *= tree[p].lazyTime; tree[r].lazyPlus *= tree[p].lazyTime; tree[l].lazyPlus %= mo; tree[r].lazyPlus %= mo; // 对子节点数值乘 tree[l].d *= tree[p].lazyTime; tree[r].d *= tree[p].lazyTime; tree[l].d %= mo; tree[r].d %= mo; tree[p].lazyTime = 1ll; } int mid = cl + ((cr - cl) \u003e\u003e 1); if (tree[p].lazyPlus) { tree[l].d += tree[p].lazyPlus * (mid - cl + 1); tree[l].d %= mo; tree[r].d += tree[p].lazyPlus * (cr - mid); tree[r].d %= mo; tree[l].lazyPlus += tree[p].lazyPlus; tree[l].lazyPlus %= mo; tree[r].lazyPlus += tree[p].lazyPlus; tree[r].lazyPlus %= mo; tree[p].lazyPlus = 0ll; } } void updateTime(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都乘上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].lazyTime *= x; tree[p].lazyTime %= mo; tree[p].lazyPlus *= x; tree[p].lazyPlus %= mo; tree[p].d *= x; tree[p].d %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updateTime(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updateTime(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]的每个数都加上x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += (cr - cl + 1) * x; tree[p].d %= mo; tree[p].lazyPlus += x; tree[p].lazyPlus %= mo; return; } pd(cl, cr, p); int mid = cl + ((cr - cl) \u003e\u003e 1); if (mid \u003e= l)updatePlus(l, r, cl, mid, p \u003c\u003c 1, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1, x); tree[p].d = (tree[p \u003c\u003c 1].d + tree[(p \u003c\u003c 1) | 1].d) % mo; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; int mid = cl + ((cr - cl) \u003e\u003e 1); pd(cl, cr, p); ll sum = 0ll; if (mid \u003e= l) sum += getsum(l, r, cl, mid, p \u003c\u003c 1); sum %= mo; if (mid \u003c r) sum += getsum(l, r, mid + 1, cr, (p \u003c\u003c 1) | 1); return sum % mo; } void solve() { int n, q;cin \u003e\u003e n \u003e\u003e q \u003e\u003e mo; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; build(1, n, 1); while (q--) { int op;cin \u003e\u003e op; if (op == 1) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updateTime(x, y, 1, n, 1, k); } else if (op == 2) { int x, y;ll k; cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; updatePlus(x, y, 1, n, 1, k); } else { int x, y;cin \u003e\u003e x \u003e\u003e y; cout \u003c\u003c getsum(x, y, 1, n, 1) \u003c\u003c '\\n'; } } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:2:3","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#参考-1"},{"categories":["在学算法的日子里"],"content":" 动态开点一般来说，线段树处理的范围在$[1,n]$，$n$一般是$1e5$的大小。 如果我们想处理负数的范围，或者是$n$达到$1e9$的数量级时，我们就需要可以动态开点的线段树。 线段树我们一般开到$4n$的大小是充足的，为了节省空间以及直接建立全树的时间，我们也可以对线段树动态开点，也就是只有当我们需要用到某些节点的时候，才去创造它。 比如，我们已经一个节点表示$[11,16]$的相关数据，我们需要修改$[13,15]$上的信息，我们就创造$[11,13]$和$[14,16]$的节点，并继续递归创建节点，直到这个线段树可以完全表示到已被修改的信息。 ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:3:0","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#动态开点"},{"categories":["在学算法的日子里"],"content":" 实现 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxv = 8e6; // 一般有多大开多大 /* 线段树模板3：动态开点技巧 */ struct segTreeNode { ll d, lazy; int lson, rson; // 记录左右子的下标 }; vector\u003csegTreeNode\u003etree(maxv); int tot = 1; // 总节点数 void update(int cl, int cr, int\u0026 p, ll addnum) { if (!p)p = ++tot; tree[p].d += addnum * (cr - cl + 1); tree[p].lazy += addnum; } void pushdown(int p, int cl, int cr) { // 节点p没有左右子时给它开点。 if (cr - cl + 1 \u003c= 1)return; int mid = (cr + cl - 1) \u003e\u003e 1; update(cl, mid, tree[p].lson, tree[p].lazy); update(mid + 1, cr, tree[p].rson, tree[p].lazy); tree[p].lazy = 0; } void updatePlus(int l, int r, int cl, int cr, int p, ll x) { // 给区间[l,r]里每个数加x if (cl \u003e= l \u0026\u0026 cr \u003c= r) { tree[p].d += x * (cr - cl + 1); tree[p].lazy += x; return; } pushdown(p, cl, cr); int mid = (cl + cr - 1) \u003e\u003e 1; if (mid \u003e= l)updatePlus(l, r, cl, mid, tree[p].lson, x); if (mid \u003c r)updatePlus(l, r, mid + 1, cr, tree[p].rson, x); int ls = tree[p].lson, rs = tree[p].rs; tree[p].d = tree[ls].d + tree[rs].d; } ll getsum(int l, int r, int cl, int cr, int p) { if (cl \u003e= l \u0026\u0026 cr \u003c= r)return tree[p].d; pushdown(p, cl, cr); int mid = (cl + cr - 1) / 2; // 可以处理区间两端是负数的情况 ll sum = 0ll; sum += getsum(l, r, cl, mid, tree[p].lson); sum += getsum(l, r, mid + 1, cr, tree[p].rson); return sum; } void solve() { ll n, q;cin \u003e\u003e n \u003e\u003e q; while (q--) { ll l, r, k;cin \u003e\u003e l \u003e\u003e r \u003e\u003e k; if(k==1){} } } int main() { int _ = 1; // cin \u003e\u003e _;cin.get(); while (_--) solve(); } ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:3:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#实现-3"},{"categories":["在学算法的日子里"],"content":" 线段树合并与分裂","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:0","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树合并与分裂"},{"categories":["在学算法的日子里"],"content":" 线段树合并线段树合并通过递归实现，需要有合并操作的线段树需要使用动态开点的技巧。 将线段树a和b合并，从1号点开始递归，若递归到某个节点为空，直接返回另一个树上的对应节点；若递归到叶子节点，我们合并两棵树上的对应节点。 void pushup(int a) { int ls = tree[a].lson, rs = tree[a].rson; tree[a].d = tree[ls].d + tree[rs].d; } int merge(int a, int b, int l, int r) { if (!a)return b; if (!b)return a; if (l == r) { // do sth return a; } int mid = (l + r) \u003e\u003e 1; tree[a].lson = merge(tree[a].lson, tree[b].lson, l, mid); tree[a].rson = merge(tree[a].rson, tree[b].rson, mid + 1, r); pushup(a); return a; } 模板题：[P4556 Vani有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树合并"},{"categories":["在学算法的日子里"],"content":" 线段树分裂线段树分裂是线段树合并的逆过程。 线段树分裂只适用于有序的序列，无序的序列是没有意义的，常用在动态开点的权值线段树上。 当分裂和合并都存在时，要注意回收节点，以免分裂时会出现节点重复/占用的问题。 当$[s,t]$与$[l,r]$有交集时开新节点 当$[s,t]$包含于$[l,r]$时，直接将当前节点接到新的树下面，把旧边断开。 void pushup(int a) { int ls = tree[a].lson, rs = tree[a].rson; tree[a].d = tree[ls].d + tree[rs].d; } void split(int\u0026 p, int\u0026 q, int s, int t, int l, int r) { // 从[s,t]的线段树中分裂出区间是[l,r]的线段树 if (t \u003c l || r \u003c s) return; if (!p) return; if (l \u003c= s \u0026\u0026 t \u003c= r) { q = p; p = 0; return; } if (!q) q = ++tot; int m = s + t \u003e\u003e 1; if (l \u003c= m) split(tree[p].lson, tree[p].rson, s, m, l, r); if (m \u003c r) split(tree[p].lson, tree[p].rson, m + 1, t, l, r); pushup(p); pushup(q); } 模板题：P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:4:2","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#线段树分裂"},{"categories":["在学算法的日子里"],"content":" 练习题一览一些模板题/测测你的板子(! P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) Problem - 5306 (hdu.edu.cn) [P4556 Vani有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) [P4097 【模板】李超线段树 / HEOI2013] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3391 【模板】文艺平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) ","date":"2024-03-13","objectID":"/posts/segtreelecnote/:5:0","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树讲义||寒假","uri":"/posts/segtreelecnote/#练习题一览"},{"categories":["在学算法的日子里"],"content":" A-Shuffle Party","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#a-shuffle-party"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，起初是$a_i=i$ 对操作swap(k)： 设$d$是不等于$k$本身的$k$的最大除数，然后交换元素$a_d$和$a_k$。 按顺序对每一个$i=2,3,..,n$进行$swap(i)$之后，找出$1$在数组中的位置。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，起初是$a_i=i$ 对操作swap(k)： 设$d$是不等于$k$本身的$k$的最大除数，然后交换元素$a_d$和$a_k$。 按顺序对每一个$i=2,3,..,n$进行$swap(i)$之后，找出$1$在数组中的位置。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路简单模拟之后可以发现，$a_1=1$最后会挪到不大于$n$的最大2的次幂处。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { vector\u003cll\u003ep; ll x = 1; while (x \u003c= 1e9) { p.push_back(x); x *= 2; } int t;cin \u003e\u003e t; while(t--){ ll n;cin \u003e\u003e n; ll ans = upper_bound(p.begin(), p.end(), n) - p.begin(); cout \u003c\u003c p[ans - 1] \u003c\u003c endl; } } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Binary Path","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#b-binary-path"},{"categories":["在学算法的日子里"],"content":" 题意一个$2\\times n$网格，网格充满$0,1$，找一条从$(1,1)$走到$(2,n)$的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤2\\times 10^5)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意一个$2\\times n$网格，网格充满$0,1$，找一条从$(1,1)$走到$(2,n)$的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤2\\times 10^5)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路路径的组成是第一行的前部分+第二行的后部分，长度是$n+1$。对从第一行到第二行的转折的位置进行枚举，假设往后一位可以获得字典序更小的则重新计数，若相同则累计路径数，若不同则代表没有更好的路径。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cstring\u003es(2); cin \u003e\u003e s[0] \u003e\u003e s[1]; string st = s[0] + s[1]; ll cnt = 1; ll ix = 2; for (int i = 2;i + n - 2 \u003c 2 * n - 1;i++) { ll j = i + n - 2;//[i,j] if (st[i - 1] == '0' \u0026\u0026 st[j] == '1') { cnt = 1; ix = i; } else if (st[i - 1] == st[j]) { cnt++; } else { break; } } string res = st.substr(0, ix) + st.substr(ix + n - 1); string res1 = s[0][0] + s[1]; if (res1 \u003c res)res = res1; cout \u003c\u003c res \u003c\u003c '\\n'; cout \u003c\u003c cnt \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Bitwise Operation Wizard","date":"2024-03-13","objectID":"/posts/cfround930div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#c-bitwise-operation-wizard"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 对一个神秘序列$p_0,p_1,…,p_{n-1}$（是${0,1,…,n-1}$的排列组合）。我们通过询问需要获得$p_i\\oplus p_j$最大的一个$(i,j)$对。 每次询问任意索引$(a,b,c,d)$评审团计算$x=(p_a|p_b)$和$y=(p_c|p_d)$，并告知是$x\\lt y,x\\gt y$还是$x=y$。最多使用$3n$个查询。 数据范围$t(1≤t≤1000)$ $n(2≤n≤10^4)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 对一个神秘序列$p_0,p_1,…,p_{n-1}$（是${0,1,…,n-1}$的排列组合）。我们通过询问需要获得$p_i\\oplus p_j$最大的一个$(i,j)$对。 每次询问任意索引$(a,b,c,d)$评审团计算$x=(p_a|p_b)$和$y=(p_c|p_d)$，并告知是$x\\lt y,x\\gt y$还是$x=y$。最多使用$3n$个查询。 数据范围$t(1≤t≤1000)$ $n(2≤n≤10^4)$​ ","date":"2024-03-13","objectID":"/posts/cfround930div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路先两两比较找到最大的数，再找到与最大的数异或的结果最大的另一个数。 ","date":"2024-03-13","objectID":"/posts/cfround930div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 char r; char ask(int a, int b, int c, int d) { cout \u003c\u003c \"? \" \u003c\u003c a \u003c\u003c ' ' \u003c\u003c b \u003c\u003c ' ' \u003c\u003c c \u003c\u003c ' ' \u003c\u003c d \u003c\u003c endl; cin \u003e\u003e r; return r; } void solve() { int n;cin \u003e\u003e n; int pm = 0; // 找n-1 for (int i = 1;i \u003c n;i++) { if (ask(pm, pm, i, i) == '\u003c') { pm = i; } } // 另一个数pn：与pm取或大于pm的最小值 int pn = 0; for (int i = 1;i \u003c n;i++) { ask(pm, i, pm, pn); if (r == '\u003e') { pn = i; } else if (r == '=' \u0026\u0026 ask(i, i, pn, pn) == '\u003c') { pn = i; } } cout \u003c\u003c \"! \" \u003c\u003c pm \u003c\u003c \" \" \u003c\u003c pn \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround930div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 930(div2)","uri":"/posts/cfround930div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Too Min Too Max","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#a-too-min-too-max"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，找到索引$(i,j,k,l)$使得$|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|$最大的值。 数据范围$t(1≤t≤500)$ $n(4≤n≤100)$​ $a_i(-10^6\\le a_i\\le 10^6)$ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组，找到索引$(i,j,k,l)$使得$|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|$最大的值。 数据范围$t(1≤t≤500)$ $n(4≤n≤100)$​ $a_i(-10^6\\le a_i\\le 10^6)$ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路选则最大的两个数和最小的两个数，结果为最大-最小+次大-最小+最大-次小+次大-次小。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) cin \u003e\u003e a[i]; sort(a.begin(), a.end()); cout \u003c\u003c a[n - 1] - a[0] + a[n - 2] - a[0] + a[n - 1] - a[1] + a[n - 2] - a[1] \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Yet Another Coin Problem","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#b-yet-another-coin-problem"},{"categories":["在学算法的日子里"],"content":" 题意有一些5种不同面值的金币，面值有：$1,3,6,10,15$。找到使用金币数目最少的组合方式达到数值为$n$的组合。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有一些5种不同面值的金币，面值有：$1,3,6,10,15$。找到使用金币数目最少的组合方式达到数值为$n$的组合。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^9)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路打表。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ep = { 0, 1,2,1,2,3,1,2,3,2,1, 2,2,2,3,1,2,3,2,3,2, 2,3,3,3,2,3,3,3,4,2 }; ll ans = n / 15 + p[n % 15]; if (n / 15 \u003e 0) ans = min(ans, n / 15 - 1 + p[n % 15 + 15]); cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Find a Mine","date":"2024-03-13","objectID":"/posts/cfround931div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#c-find-a-mine"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 $n\\times m$的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。 数据范围$t(1≤t≤3\\times 10^3)$ $n,m (2≤n≤10^8,2\\le m\\le 10^8)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意交互题。 $n\\times m$的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。 数据范围$t(1≤t≤3\\times 10^3)$ $n,m (2≤n≤10^8,2\\le m\\le 10^8)$​ ","date":"2024-03-13","objectID":"/posts/cfround931div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路第一次询问可以获得一条斜线，斜线上至少有一个地雷。 第二次询问可能可以找到正好一个交点，这个交点可能正好是地雷或者是两个地雷的行列序号的组合。再做第三次询问，得到两个交点至少有一个是地雷。第四次询问即可排除。 ","date":"2024-03-13","objectID":"/posts/cfround931div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 bool f = false; int ask(int x, int y) { cout \u003c\u003c \"? \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; int res;cin \u003e\u003e res; if (res == 0) { cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; f = true; } return res; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; f = false; int x1 = ask(1, 1); if (f) { return; } int x2 = ask(1, m); if (f) { return; } int x3 = ask(n, 1); if (f) { return; } int x, y; if (x2 + x3 == n + m - 2) { // 同一条斜线 y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; return; } else if ((n + m - x2 - x3) % 2 != 0) { // 有一个交点 if ((x1 + x2 - m + 1) % 2 == 0) { x = (x1 + x2 - m + 1) / 2; y = x1 - x; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; } else { y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; } return; } y = (x1 + x3 - n + 1) / 2; x = x1 - y; x += 1;y += 1; if (x \u003c 1 || x \u003e n || y \u003c 1 || y \u003e m) { f = true; } if (!f) { int x4 = ask(x, y); if (f) { return; } } x = (x1 + x2 - m + 1) / 2; y = x1 - x; x += 1;y += 1; cout \u003c\u003c \"! \" \u003c\u003c x \u003c\u003c ' ' \u003c\u003c y \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround931div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 931(div2)","uri":"/posts/cfround931div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Entertainment in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#a-entertainment-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个字符串进行两种操作： 将字符串反转 将该字符串反转后接在原串的后面。 可以进行任意次上述操作，获得字典序最小的字符串。 数据范围$t(1≤t≤500)$ $n(2≤n≤10^9)$​ $s(1\\le |s|\\le 100)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个字符串进行两种操作： 将字符串反转 将该字符串反转后接在原串的后面。 可以进行任意次上述操作，获得字典序最小的字符串。 数据范围$t(1≤t≤500)$ $n(2≤n≤10^9)$​ $s(1\\le |s|\\le 100)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路对比反转前后的字符串字典序大小，再决定是操作1还是操作2 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; string s;cin \u003e\u003e s; string t = s; reverse(t.begin(), t.end()); if (s \u003e t) { cout \u003c\u003c t \u003c\u003c s \u003c\u003c endl; } else { cout \u003c\u003c s \u003c\u003c endl; } } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Informatics in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#b-informatics-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意$MEX$：不属于该数组的最小非负整数。 对一个数组分成$k$个子段，要求每段的$MEX$都等于相同的数。 找到这样的子段分法，或者报告不存在合法的分法。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$​ $a_i(0\\le a_i\\lt n)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意$MEX$：不属于该数组的最小非负整数。 对一个数组分成$k$个子段，要求每段的$MEX$都等于相同的数。 找到这样的子段分法，或者报告不存在合法的分法。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$​ $a_i(0\\le a_i\\lt n)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路假设$MEX=2$，则分成$k$段的方式为前$k-1$段只要都出现过$0,1$就进行分段，最后一段保证含$0,1$和达到第$n$个数。 确定$MEX$：遍历数组$a$，找到最小的没有出现过的数（该数不大于$n$），该数即为$MEX$。 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 // MEX:不属于该数组的最小非负整数 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); vector\u003cbool\u003eck(n + 1, false); for (int i = 1;i \u003c= n;i++) { ll x;cin \u003e\u003e x; a[i] = x; ck[x] = true; } bool f = false; int y = -1; for (int i = 0;i \u003c n;i++) { if (ck[i] == false) { y = i; f = true; break; } } if (!f) { cout \u003c\u003c -1 \u003c\u003c endl; return; } // MEX=y // cout \u003c\u003c y \u003c\u003c endl; if (y == 0) { cout \u003c\u003c n \u003c\u003c endl; for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c i \u003c\u003c ' ' \u003c\u003c i \u003c\u003c endl; } return; } int p = 1; int cnt = 0; vector\u003cpair\u003cint, int\u003e\u003eans; vector\u003cbool\u003ehs(y, false); vector\u003cbool\u003ehsf(y, false); for (int i = 1;i \u003c= n;i++) { if (a[i] \u003c y \u0026\u0026 !hs[a[i]]) { hs[a[i]] = true; cnt++; } if (cnt == y) { ans.push_back({ p, i }); p = i + 1; cnt = 0; // 会不会Tle hs = hsf; } } if (ans.size() == 1) { cout \u003c\u003c -1 \u003c\u003c endl; return; } cout \u003c\u003c ans.size() \u003c\u003c endl; for (int i = 0;i \u003c ans.size();i++) { if (i != ans.size() - 1) cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c ans[i].second \u003c\u003c endl; else { cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c n \u003c\u003c endl; } } } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" D-Exam in MAC","date":"2024-03-13","objectID":"/posts/cfround932div2/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#d-exam-in-mac"},{"categories":["在学算法的日子里"],"content":" 题意有一个集合$s$。 找到满足$0\\le x\\le y\\le c$且$x+y$和$y-x$均不包含在集合$s$中的整数对$(x,y)$的个数。 数据范围$t(1≤t≤2\\times 10^4)$ $n(1≤n≤3\\times 10^5)$​ $c(1\\le c\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个集合$s$。 找到满足$0\\le x\\le y\\le c$且$x+y$和$y-x$均不包含在集合$s$中的整数对$(x,y)$的个数。 数据范围$t(1≤t≤2\\times 10^4)$ $n(1≤n≤3\\times 10^5)$​ $c(1\\le c\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround932div2/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路容斥。 合格的整数对=满足$x+y\\in s$+满足$y-x\\in s$-既满足$x+y\\in s$又满足$y-x\\in s$。 ","date":"2024-03-13","objectID":"/posts/cfround932div2/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, c;cin \u003e\u003e n \u003e\u003e c; ll tot = (c + 1) * (c + 2) / 2; ll cnt0 = 0, cnt1 = 0; for (ll i = 0;i \u003c n;i++) { ll x;cin \u003e\u003e x; tot -= x / 2 + 1; tot -= c + 1 - x; if (x \u0026 1)cnt1++; else cnt0++; } tot += (cnt0 + 1) * cnt0 / 2 + cnt1 * (cnt1 + 1) / 2; cout \u003c\u003c tot \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround932div2/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 932(div2)","uri":"/posts/cfround932div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Rudolf and the Ticket","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#a-rudolf-and-the-ticket"},{"categories":["在学算法的日子里"],"content":" 题意左边口袋有一些面值为$b_1,b_2,b_3,…,b_n$的硬币，右边有一些面值为$c_1,c_2,c_3,…,c_m$的硬币，问有多少个$(f,s)$可以使得$b_f+c_s\\le k$成立 数据范围$t(1≤t≤100)$ $n,m(1≤n,m≤100)$ $k(1\\le k\\le 2000)$ $b_i,c_i(1\\le b_i,c_i\\le 1000)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意左边口袋有一些面值为$b_1,b_2,b_3,…,b_n$的硬币，右边有一些面值为$c_1,c_2,c_3,…,c_m$的硬币，问有多少个$(f,s)$可以使得$b_f+c_s\\le k$成立 数据范围$t(1≤t≤100)$ $n,m(1≤n,m≤100)$ $k(1\\le k\\le 2000)$ $b_i,c_i(1\\le b_i,c_i\\le 1000)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路双层循环遍历 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, k;cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; vector\u003cll\u003eb(n), c(m); for (ll i = 0; i \u003c n; i++) cin \u003e\u003e b[i]; for (ll i = 0; i \u003c m; i++) cin \u003e\u003e c[i]; ll ans = 0; sort(b.begin(), b.end()); sort(c.begin(), c.end()); for (ll i = 0;i \u003c n;i++) { for (ll j = 0;j \u003c m;j++) { if (b[i] + c[j] \u003c= k) { ans++; } else { break; } } } cout\u003c\u003cans\u003c\u003cendl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Rudolf and 121","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#b-rudolf-and-121"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个数组执行如下操作： 选中一个索引$i(2\\le i\\le n-1)$： $a_{i-1}=a_{i-1}-1$ $a_i=a_i-2$ $a_{i+1}=a_{i+1}-1$​ 询问是否可以通过这个运算使得所有元素变为0 数据范围$t(1≤t≤10^4)$ $n(3≤n≤2\\times 10^5)$​ $a_i(0\\leq a_i\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意可以对一个数组执行如下操作： 选中一个索引$i(2\\le i\\le n-1)$： $a_{i-1}=a_{i-1}-1$ $a_i=a_i-2$ $a_{i+1}=a_{i+1}-1$​ 询问是否可以通过这个运算使得所有元素变为0 数据范围$t(1≤t≤10^4)$ $n(3≤n≤2\\times 10^5)$​ $a_i(0\\leq a_i\\le 10^9)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路从左向右遍历，若有大于0的数则对其进行置零，且更新其后一位和两位的数值，直到出现负数或无法执行为止。检查操作后的$a$数组是否符合要求 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (ll i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } for (ll i = 0;i \u003c n;i++) { if (a[i] \u003c 0) { cout \u003c\u003c \"NO\\n\"; return; } if (a[i] \u003e 0) { if(i+2\u003cn){ a[i + 1] -= 2 * a[i]; a[i + 2] -= a[i]; a[i] = 0; } else { cout \u003c\u003c \"NO\\n\";return; } } } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Rudolf and the Ugly String","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#c-rudolf-and-the-ugly-string"},{"categories":["在学算法的日子里"],"content":" 题意对字符串$s$，询问至少需要多少次删除字符的操作可以使得字符串中没有子段$map$和$pie$。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^6)$​ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意对字符串$s$，询问至少需要多少次删除字符的操作可以使得字符串中没有子段$map$和$pie$。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^6)$​ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路先查询子段$mapie$的数量，并删去字符$p$，再对剩下的字符串中存在的$map$和$pie$进行计数。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int p = s.find(\"mapie\"); ll cnt = 0; while (p != -1) { s[p + 2] = 'x'; p = s.find(\"mapie\", p + 1); cnt++; } p = s.find(\"map\"); while (p != -1) { s[p + 2] = 'x'; p = s.find(\"map\", p + 1); cnt++; } p = s.find(\"pie\"); while (p != -1) { s[p] = 'x'; p = s.find(\"pie\", p + 1); cnt++; } cout \u003c\u003c cnt \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Rudolf and the Ball Game","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#d-rudolf-and-the-ball-game"},{"categories":["在学算法的日子里"],"content":" 题意扔球游戏，$n$个人围成一圈，每次球可以选择顺时针或逆时针传球$r_i(1\\le r_i \\le n-1)$个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤1000,1\\le m\\le 1000)$ $x(1\\le x\\le n)$​ $r_i(1\\le r_i\\le n-1)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意扔球游戏，$n$个人围成一圈，每次球可以选择顺时针或逆时针传球$r_i(1\\le r_i \\le n-1)$个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤1000,1\\le m\\le 1000)$ $x(1\\le x\\le n)$​ $r_i(1\\le r_i\\le n-1)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路按题意模拟即可，每次记录球的所有可能位置，并更新。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, x;cin \u003e\u003e n \u003e\u003e m \u003e\u003e x; set\u003cll\u003exi; xi.insert(x); for (ll i = 0;i \u003c m;i++) { ll r;string c;cin \u003e\u003e r \u003e\u003e c; if (c == \"?\") { set\u003cll\u003eyi; for (auto j : xi) { ll b1 = (j + r) % n, b2 = (j - r + n) % n; if (b1 == 0) b1 = n; if (b2 == 0) b2 = n; yi.insert(b1);yi.insert(b2); } xi = yi; } else if (c == \"1\") { set\u003cll\u003eyi; for (auto j : xi) { ll b1 = (j - r + n) % n; if (b1 == 0) b1 = n; yi.insert(b1); } xi = yi; } else { set\u003cll\u003eyi; for (auto j : xi) { ll b2 = (j + r) % n; if (b2 == 0) b2 = n; yi.insert(b2); } xi = yi; } } cout \u003c\u003c xi.size() \u003c\u003c endl; for (auto i : xi) { cout \u003c\u003c i \u003c\u003c \" \"; }cout \u003c\u003c '\\n'; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Rudolf and k Bridges","date":"2024-03-13","objectID":"/posts/cfround933div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#e-rudolf-and-k-bridges"},{"categories":["在学算法的日子里"],"content":" 题意需要在一条河上建桥，每个位置建立桥墩的花费是$a_{i,j}+1$，$a_{i+j}$是到水面的深度。桥要求宽为$k$，任意两个桥墩的距离不能超过$d$，桥的首尾都需要有支架。 数据范围$t(1≤t≤1000)$ $n,k(1≤k\\le n≤100)$​ $m(3\\le m\\le 2\\times 10^5)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意需要在一条河上建桥，每个位置建立桥墩的花费是$a_{i,j}+1$，$a_{i+j}$是到水面的深度。桥要求宽为$k$，任意两个桥墩的距离不能超过$d$，桥的首尾都需要有支架。 数据范围$t(1≤t≤1000)$ $n,k(1≤k\\le n≤100)$​ $m(3\\le m\\le 2\\times 10^5)$ ","date":"2024-03-13","objectID":"/posts/cfround933div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路对每一行进行DP，可以获得每一行建桥的最小花费。再对其求前缀和，找到总花费最小的连续$k$段。 进行DP状态转移时，需要优先选中距离不大于$d$的桥墩点中，花费最小的桥墩。 ","date":"2024-03-13","objectID":"/posts/cfround933div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m, k, d; cin \u003e\u003e n \u003e\u003e m \u003e\u003e k \u003e\u003e d; vector\u003cvector\u003cll\u003e\u003ea(n, vector\u003cll\u003e(m)); for (ll i = 0;i \u003c n;i++) { for (ll j = 0;j \u003c m;j++) { cin \u003e\u003e a[i][j]; a[i][j] += 1; } } // 每行dp vector\u003cll\u003espd(n, 0); for (ll ni = 0;ni \u003c n;ni++) { vector\u003cll\u003edp(m, 0); for (ll i = 0;i \u003c m;i++) { dp[i] = a[ni][i]; } // 维护前d个值中的最小值 queue\u003cll\u003eq1; deque\u003cll\u003eqmin; q1.push(dp[0]); qmin.push_back(dp[0]); for (ll i = 1;i \u003c m;i++) { if (i == 1) dp[i] += dp[0]; else { ll mn = qmin.front(); dp[i] = mn + dp[i]; } if (q1.size() == d + 1) { if (q1.front() == qmin.front()) { qmin.pop_front(); } q1.pop(); } q1.push(dp[i]); while (!qmin.empty() \u0026\u0026 dp[i] \u003c qmin.back()) { qmin.pop_back(); } qmin.push_back(dp[i]); } spd[ni] = dp[m - 1]; } vector\u003cll\u003esum(n + 1, 0); sum[0] = 0; for (ll i = 1;i \u003c= n;i++) { sum[i] = sum[i - 1] + spd[i - 1]; } ll ans = sum[k]; for (ll i = k;i \u003c= n;i++) { ans = min(ans, sum[i] - sum[i - k]); } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-03-13","objectID":"/posts/cfround933div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 933(div3)","uri":"/posts/cfround933div3/#参考代码-4"},{"categories":["在前端搬砖的日子里"],"content":" 创建项目 npm create vite@latest dodola -- --template vue-ts cd dodola npm install npm run dev 转到根目录下后 ","date":"2024-03-10","objectID":"/posts/vuemod/:1:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#创建项目"},{"categories":["在前端搬砖的日子里"],"content":" 规范目录 ├── dist/ └── src/ ├── api │ └── ... // 抽取出API请求 ├── assets/ // 静态资源目录 ├── common/ // 通用类库目录 ├── components/ // 公共组件目录 ├── routers/ // 路由配置目录 ├── store/ // pinia 状态管理目录 ├── index.ts // 导出 store 的地方 ├── home.ts // 模块 └── user.ts // 模块 ├── style/ // 通用 CSS 目录 ├── utils/ // 工具函数目录 ├── views/ // 页面组件目录 ├── App.vue ├── main.ts ├── vite-env.d.ts ├── index.html ├── tsconfig.json // TypeScript 配置文件 ├── vite.config.ts // Vite 配置文件 └── package.json ","date":"2024-03-10","objectID":"/posts/vuemod/:1:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#规范目录"},{"categories":["在前端搬砖的日子里"],"content":" path模板+代理在vite.config.ts中，设置@指向src、服务器启动端口、打包路径、代理等等设置 先进行path模板的安装： npm i @types/node -D 如果需要使用代理的话，可以先下载： npm i @vitejs/plugin-basic-ssl -D 或者这个： npm i vite-plugin-mkcert -D 这两个二选一即可 ","date":"2024-03-10","objectID":"/posts/vuemod/:2:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#path模板代理"},{"categories":["在前端搬砖的日子里"],"content":" 集成工具","date":"2024-03-10","objectID":"/posts/vuemod/:3:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#集成工具"},{"categories":["在前端搬砖的日子里"],"content":" Vue Router 4.x npm i vue-router@4 ","date":"2024-03-10","objectID":"/posts/vuemod/:3:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#vue-router-4x"},{"categories":["在前端搬砖的日子里"],"content":" 集成状态管理工具Pinia npm i pinia ","date":"2024-03-10","objectID":"/posts/vuemod/:3:2","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#集成状态管理工具pinia"},{"categories":["在前端搬砖的日子里"],"content":" Axios npm i axios ","date":"2024-03-10","objectID":"/posts/vuemod/:4:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#axios"},{"categories":["在前端搬砖的日子里"],"content":" CSS预编译器 Stylus/Sass/Less使用CSS预编译器Stylus 安装(按序选择就好) npm i stylus -D # or npm i sass -D npm i less -D ","date":"2024-03-10","objectID":"/posts/vuemod/:4:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#css预编译器-stylussassless"},{"categories":["在前端搬砖的日子里"],"content":" 自动引入插件通过插件 unplugin-vue-components 和 unplugin-auto-import 实现组件自动按需导入（推荐！） npm i @varlet/import-resolver unplugin-vue-components unplugin-auto-import -D ","date":"2024-03-10","objectID":"/posts/vuemod/:5:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#自动引入插件"},{"categories":["在前端搬砖的日子里"],"content":" 移动端适配","date":"2024-03-10","objectID":"/posts/vuemod/:6:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#移动端适配"},{"categories":["在前端搬砖的日子里"],"content":" postcss 插件 npm i postcss-px-to-viewport -D postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } 组件库设计基于 375px 宽度设计稿，推荐使用 postcss 插件将 px 单位转换成 vmin 单位从而实现移动端适配。 在 webpack/vite 项目根路径下创建 postcss.config.js 并做如下配置之后 375px -\u003e 100vmin。 ","date":"2024-03-10","objectID":"/posts/vuemod/:6:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#postcss-插件"},{"categories":["在前端搬砖的日子里"],"content":" 桌面端适配 npm i @varlet/touch-emulator ","date":"2024-03-10","objectID":"/posts/vuemod/:7:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#桌面端适配"},{"categories":["在前端搬砖的日子里"],"content":" 组件库","date":"2024-03-10","objectID":"/posts/vuemod/:8:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#组件库"},{"categories":["在前端搬砖的日子里"],"content":" Element Plus npm install element-plus --save ","date":"2024-03-10","objectID":"/posts/vuemod/:8:1","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#element-plus"},{"categories":["在前端搬砖的日子里"],"content":" varlet npm i @varlet/ui -S VsCode 插件市场搜索： varlet-vscode-extension。 ","date":"2024-03-10","objectID":"/posts/vuemod/:8:2","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#varlet"},{"categories":["在前端搬砖的日子里"],"content":" Arco.design npm install --save-dev @arco-design/web-vue ","date":"2024-03-10","objectID":"/posts/vuemod/:8:3","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#arcodesign"},{"categories":["在前端搬砖的日子里"],"content":" Naive UI npm i -D naive-ui ","date":"2024-03-10","objectID":"/posts/vuemod/:8:4","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#naive-ui"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#配置文件示例"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#tsconfigjson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#tsconfignodejson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#viteconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#postcssconfigts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#packagejson"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#vite-envdts"},{"categories":["在前端搬砖的日子里"],"content":" 配置文件示例 tsconfig.json { \"compilerOptions\": { \"paths\":{ \"@/*\": [\"./src/*\"] }, \"target\": \"ES2020\", \"useDefineForClassFields\": true, \"module\": \"ESNext\", \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"], \"skipLibCheck\": true, /* Bundler mode */ \"moduleResolution\": \"bundler\", \"allowImportingTsExtensions\": true, \"resolveJsonModule\": true, \"isolatedModules\": true, \"noEmit\": true, \"jsx\": \"preserve\", /* Linting */ \"strict\": true, \"noUnusedLocals\": true, \"noUnusedParameters\": true, \"noFallthroughCasesInSwitch\": true }, \"include\": [ \"src/**/*.ts\", \"src/**/*.tsx\", \"src/**/*.vue\", \"auto-imports.d.ts\", \"components.d.ts\" ], \"references\": [{ \"path\": \"./tsconfig.node.json\" }] } tsconfig.node.json { \"compilerOptions\": { \"composite\": true, \"skipLibCheck\": true, \"module\": \"ESNext\", \"moduleResolution\": \"bundler\", \"allowSyntheticDefaultImports\": true, \"strict\": true }, \"include\": [\"vite.config.ts\"] } vite.config.ts import { defineConfig } from 'vite' import vue from '@vitejs/plugin-vue' import { resolve } from \"path\" import AutoImport from 'unplugin-auto-import/vite' import Components from 'unplugin-vue-components/vite'; import { ArcoResolver, NaiveUiResolver } from 'unplugin-vue-components/resolvers'; import { VarletImportResolver } from '@varlet/import-resolver' import basicSSL from '@vitejs/plugin-basic-ssl' // https://vitejs.dev/config/ export default defineConfig({ define: { // 定义全局变量替换方式 'process.env': process.env, 'process.env.NODE_ENV': '\"development\"', __APP_VERSION__: JSON.stringify(require('./package.json').version), __API_URL__: 'window.__backend_api_url', }, plugins: [ vue(), AutoImport({ resolvers: [ArcoResolver()], }), Components({ resolvers: [ ArcoResolver({ importStyle: 'less', sideEffect: true, }), NaiveUiResolver(), VarletImportResolver(), ], }), ], resolve: { alias: { \"@\": resolve(__dirname, \"src\"), // 设置'@'指向'src' }, }, root: './', // index.html所在的位置，即根目录 base: './', // 设置打包路径，用于嵌入式开发 mode: process.env.NODE_ENV, // 设置模式，'development' 用于开发，'production' 用于构建(见define中的process.env.NODE_ENV) publicDir: 'public', // 设置静态资源目录 cacheDir: 'node_modules/.vite', // 设置缓存目录 envDir: './', // 设置环境变量目录 css: { preprocessorOptions: { less: { modifyVars: { // 'primary-color': '#1890ff', // 'link-color': '#1890ff', // 'border-radius-base': '2px', }, javascriptEnabled: true, math: 'parens-division', }, }, }, server: { host: 'localhost', // 设置服务器启动地址，默认为'localhost port: 5173, // 设置服务器启动端号,如果端口已经被使用，Vite 会自动尝试下一个可用的端口，所以这可能不是开发服务器最终监听的实际端口。 strictPort: false, // 设置是否严格检查端口号 open: false, // 设置服务启动时是否自动打开浏览器 cors: true, // 允许跨域 // proxy: { // // 带选项写法：http://localhost:5173/api/bar -\u003e http://jsonplaceholder.typicode.com/bar // '/api': { // target: 'http://jsonplaceholder.typicode.com', // changeOrigin: true, // rewrite: (path) =\u003e path.replace(/^\\/api/, ''), // }, // // 代理 websockets 或 socket.io 写法：ws://localhost:5173/socket.io -\u003e ws://localhost:5174/socket.io // '/socket.io': { // target: 'ws://localhost:5174', // ws: true, // }, // }, }, }) postcss.config.ts module.exports = { plugins: { 'postcss-px-to-viewport': { viewportWidth: 375, unitPrecision: 6, unitToConvert: 'px', viewportUnit: 'vmin', fontViewportUnit: 'vmin', propList: ['*'], } } } package.json { \"name\": \"aixinmarket-frontend-2024\", \"private\": true, \"version\": \"0.0.0\", \"type\": \"module\", \"scripts\": { \"dev\": \"vite\", \"build\": \"vue-tsc \u0026\u0026 vite build\", \"preview\": \"vite preview\" }, \"dependencies\": { \"@varlet/import-resolver\": \"^3.0.7\", \"@varlet/touch-emulator\": \"^3.0.7\", \"@varlet/ui\": \"^3.0.7\", \"axios\": \"^1.6.7\", \"element-plus\": \"^2.6.1\", \"pinia\": \"^2.1.7\", \"vue\": \"^3.4.19\", \"vue-router\": \"^4.3.0\" }, \"devDependencies\": { \"@arco-design/web-vue\": \"^2.54.6\", \"@types/node\": \"^20.11.25\", \"@vitejs/plugin-basic-ssl\": \"^1.1.0\", \"@vitejs/plugin-vue\": \"^5.0.4\", \"less\": \"^4.2.0\", \"naive-ui\": \"^2.38.1\", \"postcss-px-to-viewport\": \"^1.1.1\", \"stylus\": \"^0.63.0\", \"typescript\": \"^5.2.2\", \"unplugin-auto-import\": \"^0.17.5\", \"unplugin-vue-components\": \"^0.26.0\", \"vite\": \"^5.1.4\", \"vite-plugin-mkcert\": \"^1.17.4\", \"vue-tsc\": \"^","date":"2024-03-10","objectID":"/posts/vuemod/:9:0","series":null,"tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"title":"一个Vue项目的基础模板||PC端+移动端适配","uri":"/posts/vuemod/#maints"},{"categories":["在学算法的日子里"],"content":" 线性动态规划线性动态规划，即具有线性阶段划分的动态规划。 ","date":"2024-03-09","objectID":"/posts/lineardp/:1:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#线性动态规划"},{"categories":["在学算法的日子里"],"content":" [P1216]数字三角形","date":"2024-03-09","objectID":"/posts/lineardp/:2:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1216数字三角形"},{"categories":["在学算法的日子里"],"content":" 题目描述观察下面的数字金字塔。 写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。 在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。 输入格式 第一个行一个正整数 $r$ ,表示行的数目。 后面每行为这个数字金字塔特定行包含的整数。 输出格式 单独的一行,包含那个可能得到的最大的和。 样例 #1 样例输入 #1 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 样例输出 #1 30 提示 【数据范围】 对于 $100%$ 的数据，$1\\le r \\le 1000$，所有输入在 $[0,100]$ 范围内。 题目翻译来自NOCOW。 USACO Training Section 1.5 IOI1994 Day1T1 ","date":"2024-03-09","objectID":"/posts/lineardp/:2:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:2:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码"},{"categories":["在学算法的日子里"],"content":" [P1020]导弹拦截","date":"2024-03-09","objectID":"/posts/lineardp/:3:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1020导弹拦截"},{"categories":["在学算法的日子里"],"content":" 题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式 一行，若干个整数，中间由空格隔开。 输出格式 两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 样例 #1 样例输入 #1 389 207 155 300 299 170 158 65 样例输出 #1 6 2 提示 对于前 $50%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\\mathcal O(n^2)$ 做法通过。 对于后 $50%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$ 做法通过。 对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。 此外本题开启 spj，每点两问，按问给分。 $\\text{upd 2022.8.24}$：新增加一组 Hack 数据。 ","date":"2024-03-09","objectID":"/posts/lineardp/:3:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; vector\u003cint\u003ea, b, c; int main() { int n; while (cin \u003e\u003e n) { a.push_back(n); } for (int i = 0;i \u003c a.size();i++) { if (b.size() == 0 || a[i] \u003c= b.back()) b.push_back(a[i]); else { int l = 0, r = b.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (b[pos] \u003e= a[i])l = pos + 1; else r = pos; } b[l] = a[i]; } if (c.size() == 0 || c.back() \u003c a[i]) c.push_back(a[i]); else { int l = 0, r = c.size() - 1; int pos = 0; while (l \u003c r) { pos = (l + r) / 2; if (c[pos] \u003c a[i])l = pos + 1; else r = pos; } c[l] = a[i]; } } cout \u003c\u003c b.size() \u003c\u003c endl; cout \u003c\u003c c.size() \u003c\u003c endl; return 0; } ","date":"2024-03-09","objectID":"/posts/lineardp/:3:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" [P1091]合唱队形","date":"2024-03-09","objectID":"/posts/lineardp/:4:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1091合唱队形"},{"categories":["在学算法的日子里"],"content":" 题目描述$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。 合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1\u003c \\cdots \u003ct_i\u003et_{i+1}\u003e$ … $\u003et_k(1\\le i\\le k)$。 你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入格式 共二行。 第一行是一个整数 $n$（$2\\le n\\le100$），表示同学的总数。 第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\\le t_i\\le230$）是第 $i$ 位同学的身高（厘米）。 输出格式 一个整数，最少需要几位同学出列。 样例 #1 样例输入 #1 8 186 186 150 200 160 130 197 220 样例输出 #1 4 提示 对于 $50%$ 的数据，保证有 $n \\le 20$。 对于全部的数据，保证有 $n \\le 100$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:4:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003et; for (int i = 0; i \u003c n; i++) { int x;cin \u003e\u003e x; t.push_back(x); } int k = 1; for (int m = 0;m \u003c n;m++) { // 枚举中间位m vector\u003cint\u003el, r; // 左边最长上升子序列 for (int i = 0;i \u003c m;i++) { if (t[i] \u003e= t[m])continue; if (l.size()!=0) { if (t[i] \u003e l.back()) { l.push_back(t[i]); } else { auto it = lower_bound(l.begin(), l.end(), t[i]); *it = t[i]; } } else { l.push_back(t[i]); } } // 右边最长上升子序列 for (int i = n - 1;i \u003e m;i--) { if (t[i] \u003e= t[m])continue; if (r.size()!=0) { if (t[i] \u003e r.back()) { r.push_back(t[i]); } else { auto it = lower_bound(r.begin(), r.end(), t[i]); *it = t[i]; } } else { r.push_back(t[i]); } } k = max(k, (int)l.size() + (int)r.size() + 1); } cout \u003c\u003c n - k \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:4:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" [P1095]守望者的逃离题目背景 恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1095守望者的逃离"},{"categories":["在学算法的日子里"],"content":" 题目描述守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。 为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。 守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动 $60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。 现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间 $T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。 注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。 输入格式 输入数据共一行三个非负整数，分别表示 $M$，$S$，$T$。 输出格式 输出数据共两行。 第一行一个字符串 $\\texttt{Yes}$ 或 $\\texttt{No}$，即守望者是否能逃离荒岛。 第二行包含一个整数。第一行为 $\\texttt{Yes}$ 时表示守望者逃离荒岛的最短时间；第一行为 $\\texttt{No}$ 时表示守望者能走的最远距离。 样例 #1 样例输入 #1 39 200 4 样例输出 #1 No 197 样例 #2 样例输入 #2 36 255 10 样例输出 #2 Yes 6 提示 对于 $30%$ 的数据，$1 \\le T \\le 10$，$ 1 \\le S \\le 100$； 对于 $50%$ 的数据，$1 \\le T \\le 10^3$，$ 1 \\le S \\le 10^4$； 对于 $100%$ 的数据，$1 \\le T \\le 3\\times 10^5$，$0 \\le M \\le 10^3$，$ 1 \\le S \\le 10^8$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:5:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll m, s, t;cin \u003e\u003e m \u003e\u003e s \u003e\u003e t; vector\u003cll\u003ef(t + 1); f[0] = 0;ll bl = m; for (ll i = 1;i \u003c= t;i++) { if (bl \u003e= 10) { f[i] = f[i - 1] + 60; bl -= 10; } else { f[i] = f[i - 1]; bl += 4; } } for (int i = 1;i \u003c= t;i++) { f[i] = max(f[i], f[i - 1] + 17); } if (f[t] \u003e= s) { cout \u003c\u003c \"Yes\\n\"; cout \u003c\u003c lower_bound(f.begin(), f.end(), s) - f.begin() \u003c\u003c endl; } else { cout \u003c\u003c \"No\\n\" \u003c\u003c f[t] \u003c\u003c endl; } } ","date":"2024-03-09","objectID":"/posts/lineardp/:5:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" [P1541]乌龟棋题目背景 小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1541乌龟棋"},{"categories":["在学算法的日子里"],"content":" 题目描述乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$ 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有 $1,2,3,4$ 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入格式 每行中两个数之间用一个空格隔开。 第 $1$ 行 $2$ 个正整数 $N,M$，分别表示棋盘格子数和爬行卡片数。 第 $2$ 行 $N$ 个非负整数，$a_1,a_2,…,a_N$，其中 $a_i$ 表示棋盘第 $i$ 个格子上的分数。 第 $3$ 行 $M$ 个整数，$b_1,b_2,…,b_M$，表示 $M$ 张爬行卡片上的数字。 输入数据保证到达终点时刚好用光$M$张爬行卡片。 输出格式 $1$ 个整数，表示小明最多能得到的分数。 样例 #1 样例输入 #1 9 5 6 10 14 2 8 8 18 5 17 1 3 1 2 1 样例输出 #1 73 提示 每个测试点 1s。 小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$ 格的分数 $6$。 对于 $30%$ 的数据有 $1≤N≤30,1≤M≤12$。 对于 $50%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。 对于 $100%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:6:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ea(n + 1); for (ll i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } vector\u003cll\u003ecnt(5); for (int i = 0;i \u003c m;i++) { ll x;cin \u003e\u003e x; cnt[x]++; } vector\u003cvector\u003cvector\u003cvector\u003cll\u003e\u003e\u003e\u003edp(cnt[1] + 1, vector\u003cvector\u003cvector\u003cll\u003e\u003e\u003e(cnt[2] + 1, vector\u003cvector\u003cll\u003e\u003e(cnt[3] + 1, vector\u003cll\u003e(cnt[4] + 1, 0)))); dp[0][0][0][0] = a[1]; for (int i = 0;i \u003c= cnt[1];i++) { for (int j = 0;j \u003c= cnt[2];j++) { for (int k = 0;k \u003c= cnt[3];k++) { for (int l = 0;l \u003c= cnt[4];l++) { ll x = i * 1 + j * 2 + k * 3 + l * 4 + 1; // 走到的格子是x if (i \u003e 0) // 走到x的时候，如果i \u003e 0，那么就可以从i - 1走到i，下面同理 dp[i][j][k][l] = max(dp[i][j][k][l], dp[i - 1][j][k][l] + a[x]); if (j \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j - 1][k][l] + a[x]); if (k \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k - 1][l] + a[x]); if (l \u003e 0) dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k][l - 1] + a[x]); } } } } cout \u003c\u003c dp[cnt[1]][cnt[2]][cnt[3]][cnt[4]] \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:6:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" [P1868]饥饿的奶牛","date":"2024-03-09","objectID":"/posts/lineardp/:7:0","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#p1868饥饿的奶牛"},{"categories":["在学算法的日子里"],"content":" 题目描述有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。 现用汉语翻译为： 有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。 对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。 输入格式 第一行一个整数 $N$。 接下来 $N$ 行，每行两个数 $x,y$，描述一个区间。 输出格式 输出最多能吃到的牧草堆数。 样例 #1 样例输入 #1 3 1 3 7 8 3 4 样例输出 #1 5 提示 $1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。 ","date":"2024-03-09","objectID":"/posts/lineardp/:7:1","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; map\u003cll, vector\u003cll\u003e\u003e mp; ll my = 0; for (ll i = 0;i \u003c n;i++) { ll x, y;cin \u003e\u003e x \u003e\u003e y; x += 1;y += 1; // 避免越界 my = max(my, y); mp[y].push_back(x); } vector\u003cll\u003edp(my + 1, 0); dp[0] = 0; for (ll i = 1;i \u003c= my;i++) { dp[i] = dp[i - 1]; if (mp.count(i)) { for (ll j = 0;j \u003c mp[i].size();j++) { ll y = mp[i][j]; dp[i] = max(dp[i], dp[y - 1] + i - y + 1); } } } cout \u003c\u003c dp[my] \u003c\u003c endl; } ","date":"2024-03-09","objectID":"/posts/lineardp/:7:2","series":["题解记录"],"tags":["算法","DP"],"title":"刷题记录||线性动态规划","uri":"/posts/lineardp/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" A-Moving Chips","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#a-moving-chips"},{"categories":["在学算法的日子里"],"content":" 题意每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。 现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。 数据范围$t(1≤t≤1000)$ $n(2≤n≤50)$​ $a_i(a_i∈{1,0})$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。 现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。 数据范围$t(1≤t≤1000)$ $n(2≤n≤50)$​ $a_i(a_i∈{1,0})$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路统计数组中第一个1和最后一个1之间的0的数目。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ea(n); bool f = false; int cnt = 0; int ans = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; if (a[i] == 1 \u0026\u0026 !f) { f = true; } if (f) { if (a[i] == 0) cnt++; else { ans += cnt; cnt = 0; } } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Monsters Attack!","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#b-monsters-attack"},{"categories":["在学算法的日子里"],"content":" 题意玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于$k$颗子弹，每个子弹可以造成怪物的血量$a_i$下降1点，降为0后怪物将倒下并从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。 询问是否可能使玩家消灭所有$n$只怪物，不让任何一只怪物靠近玩家。 数据范围$t(1≤t≤3\\times 10^4)$ $n,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)$​ $a_i(1\\le a_i\\le 10^9)$ $x_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于$k$颗子弹，每个子弹可以造成怪物的血量$a_i$下降1点，降为0后怪物将倒下并从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。 询问是否可能使玩家消灭所有$n$只怪物，不让任何一只怪物靠近玩家。 数据范围$t(1≤t≤3\\times 10^4)$ $n,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)$​ $a_i(1\\le a_i\\le 10^9)$ $x_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路将所有怪物折合成同一个方向，每次玩家向怪物移动一格，每次都使用完所有的$k$颗子弹。遍历模拟，判断是否能在到达最远坐标之前消灭所有怪物。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 struct monster { ll a, x; bool operator\u003c(const monster\u0026 other) { return x \u003c other.x; } }; void solve() { ll n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; vector\u003cll\u003ex(n); for(int i = 0;i \u003c n;i++) { cin \u003e\u003e x[i]; if (x[i] \u003c 0)x[i] *= -1; } vector\u003cmonster\u003emonsters; for (int i = 0;i \u003c n;i++) { monsters.push_back({a[i], x[i]}); } sort(monsters.begin(), monsters.end()); map\u003cll, ll\u003eturns; for (int i = 0;i \u003c n;i++) { ll t = monsters[i].a; ll s = monsters[i].x; turns[s] += t; } ll lk = 0; // 剩余子弹 ll ix = 0; for (auto i = turns.begin();i != turns.end();i++) { ll iy = i-\u003efirst; // 位置 ll t = i-\u003esecond; if ((iy - ix) * k + lk \u003c t) { cout \u003c\u003c \"NO\\n\";return; } else { lk = (iy - ix) * k + lk - t; ix = iy; } } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Find B","date":"2024-02-29","objectID":"/posts/cfedu162div2/:0:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#c-find-b"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组$a$，每次截取一段$[l,r]$的子数组$b$，判断该数组是否可以变化成一个数组$c$，满足： $\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i$ 任意$i∈[l,r]$，都满足$b_i≠c_i$ 任意$c_i\\gt 0$​ 数据范围$t(1≤t≤10^4)$ $n,q(1≤n,q≤3\\times 10^5)$​ $a_i(1\\le a_i\\le 10^9)$ $l_i,r_i(1\\le l_i\\le r_i\\le n)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组$a$，每次截取一段$[l,r]$的子数组$b$，判断该数组是否可以变化成一个数组$c$，满足： $\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i$ 任意$i∈[l,r]$，都满足$b_i≠c_i$ 任意$c_i\\gt 0$​ 数据范围$t(1≤t≤10^4)$ $n,q(1≤n,q≤3\\times 10^5)$​ $a_i(1\\le a_i\\le 10^9)$ $l_i,r_i(1\\le l_i\\le r_i\\le n)$ ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:1:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路预处理数组$a$。 对于子数组$b$，考虑：将所有不为1的数变成1，将所有的1至少再加1。 这样生成的数组$c$是符合要求的。 如果上述操作可以实现总和不变，则可行。 ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:2:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, q;cin \u003e\u003e n \u003e\u003e q; vector\u003cll\u003ec(n + 1);c[0] = 0; vector\u003cll\u003epc(n + 1);pc[0] = 0; vector\u003cll\u003ect(n + 1);ct[0] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e c[i]; pc[i] = c[i] + pc[i - 1]; if (c[i] == 1)ct[i] = ct[i - 1] + 1; else ct[i] = ct[i - 1]; } while (q--) { ll l, r;cin \u003e\u003e l \u003e\u003e r; if (l == r) { cout \u003c\u003c \"NO\\n\";continue; } ll sum = pc[r] - pc[l - 1]; ll lr = r - l + 1; lr -= ct[r] - ct[l - 1]; // 非1的个数 if (sum - lr \u003e= 2 * (ct[r] - ct[l - 1])) { cout \u003c\u003c \"YES\\n\"; } else cout \u003c\u003c \"NO\\n\"; } } ","date":"2024-02-29","objectID":"/posts/cfedu162div2/:3:0","series":["题解记录"],"tags":["算法"],"title":"Educational Codeforces Round 162(div2)","uri":"/posts/cfedu162div2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" A-Turtle Puzzle: Rearrange and Negate","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#a-turtle-puzzle-rearrange-and-negate"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组执行两个操作： 对数组进行重新排序或保持元素顺序不变 选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。 求进行上述操作之后数组的最大和是多少。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ $a_i(-100\\le a_i\\le 100)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组执行两个操作： 对数组进行重新排序或保持元素顺序不变 选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。 求进行上述操作之后数组的最大和是多少。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ $a_i(-100\\le a_i\\le 100)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路遍历数组，对所有的数取非负后相加。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; ll ans = 0ll; for (int i = 0;i \u003c n;i++) { ll x;cin \u003e\u003e x; if (x \u003c 0)ans -= x; else ans += x; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Turtle Math: Fast Three Task","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#b-turtle-math-fast-three-task"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组，可以对数组中的数进行任意次下方两种操作： 将数移除 将该数的数值加1 求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？ 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组，可以对数组中的数进行任意次下方两种操作： 将数移除 将该数的数值加1 求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？ 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路统计数组$a$中模3为0、1、2的数量和余数总和。记总和为$sum$，余1的数量为$x$，余2的数量为$y$。考虑： 若$sum$模3为0，则不需要操作 若$sum$模3为2，则给任意一个数加1即可，操作1次。 若$sum$模3为1，若有余1的数，则去掉这个数即可，否则进行两次加1操作。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003eaa(n); ll ans = 0; ll x = 0, y = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e aa[i]; aa[i] %= 3; ans += aa[i]; if (aa[i] == 1)x++; else if (aa[i] == 2)y++; } if (ans%3 == 0) { cout\u003c\u003c0\u003c\u003c'\\n'; } else if (ans % 3 == 2) { cout \u003c\u003c 1 \u003c\u003c '\\n'; } else { if (x \u003e 0)cout \u003c\u003c 1 \u003c\u003c '\\n'; else cout \u003c\u003c 2 \u003c\u003c '\\n'; } } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-Turtle Fingers: Count the Values of k","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#c-turtle-fingers-count-the-values-of-k"},{"categories":["在学算法的日子里"],"content":" 题意给3个正整数$a,b,l$，找出满足$l=k\\times a^x\\times b^y$的$k$的个数，$k,x,y$均为非负整数。 数据范围$t(1≤t≤10^4)$ $a,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给3个正整数$a,b,l$，找出满足$l=k\\times a^x\\times b^y$的$k$的个数，$k,x,y$均为非负整数。 数据范围$t(1≤t≤10^4)$ $a,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路$2^{20}\\gt 10^6$，可知，$x,y$的范围不超过20。 预处理$a^x$和$b^y$，然后暴力遍历即可。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll a, b, l;cin \u003e\u003e a \u003e\u003e b \u003e\u003e l; vector\u003cll\u003eax, by; ax.push_back(1);by.push_back(1); for (int i = 1;ax.back() \u003c= l;i++) { ax.push_back(ax.back() * a); } for (int i = 1;by.back() \u003c= l;i++) { by.push_back(by.back() * b); } set\u003cll\u003ek; for (int i = 0;i \u003c ax.size();i++) { for (int j = 0;j \u003c by.size();j++) { if (l%(ax[i] * by[j]) == 0) { k.insert(l/(ax[i] * by[j])); } } } cout \u003c\u003c k.size() \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Turtle Tenacity: Continual Mods","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#d-turtle-tenacity-continual-mods"},{"categories":["在学算法的日子里"],"content":" 题意给数组$a$重新排序，判断是否存在排序使得$a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots a_{n-1}\\text{ }mod\\text{ }a_n=0$。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$ $a_i(1\\le a_i\\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给数组$a$重新排序，判断是否存在排序使得$a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots a_{n-1}\\text{ }mod\\text{ }a_n=0$。 数据范围$t(1≤t≤10^4)$ $n(2≤n≤10^5)$ $a_i(1\\le a_i\\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路思考$x\\text{ }mod\\text{ }y$ 如果$x\\lt y$，则结果还是$x$ 如果$x=y$​，则结果是0 如果最小的数是唯一的，则一定有解；如果最小的数不唯一，考虑是否有较大的数$z$使得$z\\text{ }mod\\text{ }x≠0$，如果存在，则有更小的唯一最小值，可以有解，否则无解。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } sort(a.begin(), a.end()); if (a[0] != a[1]) { cout \u003c\u003c \"YES\\n\"; return; } for (int i = 1;i \u003c n;i++) { if (a[i] % a[0] != 0) { cout \u003c\u003c \"YES\\n\"; return; } } cout \u003c\u003c \"NO\\n\"; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Turtle vs. Rabbit Race: Optimal Trainings","date":"2024-02-29","objectID":"/posts/cfround929div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#e-turtle-vs-rabbit-race-optimal-trainings"},{"categories":["在学算法的日子里"],"content":" 题意训练量$k$是连续一段时间的每天的训练量的总和，每次训练的提高值$u$按照训练次数递减（第1次$u$，第2次$u-1$，第3次$u-2$，…，第$k$次$u-k+1$，，提高值可以是负数），每次给定一个起始日$l$和提高值$u$，寻找一个最佳的结束日$r$，使得训练提高值总和最高，如果有多个$r$的结果提供最高训练值，选$r$较小的那个。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$ $a_i(1\\le a_i\\le 10^4)$ $q(1\\le q\\le 10^5)$ $l,u(1\\le l\\le n,1\\le u \\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意训练量$k$是连续一段时间的每天的训练量的总和，每次训练的提高值$u$按照训练次数递减（第1次$u$，第2次$u-1$，第3次$u-2$，…，第$k$次$u-k+1$，，提高值可以是负数），每次给定一个起始日$l$和提高值$u$，寻找一个最佳的结束日$r$，使得训练提高值总和最高，如果有多个$r$的结果提供最高训练值，选$r$较小的那个。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤10^5)$ $a_i(1\\le a_i\\le 10^4)$ $q(1\\le q\\le 10^5)$ $l,u(1\\le l\\le n,1\\le u \\le 10^9)$ ","date":"2024-02-29","objectID":"/posts/cfround929div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路训练提高值总量$S$与训练量$k$之间的关系是$S(k)=u\\times k-\\frac{k\\times (k-1)}{2}$，是一个关于$k$先增后减的函数，最高值在$k=u+0.5$处取到，由于$k$为整数，$S(k)$的最高值应该在$u$和$u+1$处取到。 在对称轴左边，二分查找在$[l,u]$的范围内最靠近$u$的$k$的取值，即小于等于$u$的最后一个$k$值。 在对称轴右边，二分查找$[u+1,n]$的范围内最靠近$u+1$的$k$值，即大于等于$u+1$的第一个$k$值。 $k$值可以通过前缀和进行筛选，$k=pre[r]-pre[l-1]$，则对$pre$数组进行二分查找$u+pre[l-1]$和$u+1+pre[l-1]$即可。 对比这两个值对应的$S(k)$和$r$，以及只在$l$那天训练的效果，择优选择。 ","date":"2024-02-29","objectID":"/posts/cfround929div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll f(ll u, ll k) { return k * u - k * (k - 1) / 2; } void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); vector\u003cll\u003epre(n + 1); pre[0] = 0;a[0] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; pre[i] = pre[i - 1] + a[i]; } int q;cin \u003e\u003e q; while (q--) { ll l, u;cin \u003e\u003e l \u003e\u003e u; ll x = pre[l - 1]; int ru = upper_bound(pre.begin() + l, pre.end(), x + u) - pre.begin() - 1; ll ans = a[l], ansr = l; if (ru \u003e= l \u0026\u0026 ru \u003c= n) { if (f(u, pre[ru] - x) \u003e ans) { ans = f(u, pre[ru] - x); ansr = ru; } } int ru1 = lower_bound(pre.begin() + l, pre.end(), x + u + 1) - pre.begin(); if (ru1 \u003e= l, ru1 \u003c= n) { if (f(u, pre[ru1] - x) \u003e ans) { ans = f(u, pre[ru1] - x); ansr = ru1; } } cout \u003c\u003c ansr \u003c\u003c ' '; } cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround929div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 929(div3)","uri":"/posts/cfround929div3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-Thorns and Coins","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#a-thorns-and-coins"},{"categories":["在学算法的日子里"],"content":" 题意长度为$n$的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ .代表空，*代表荆棘，@代表金币 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意长度为$n$的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。 数据范围$t(1≤t≤1000)$ $n(1≤n≤50)$​ .代表空，*代表荆棘，@代表金币 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路从左往右，寻找第一个含有2个以上*的*连通块，其前的金币都可以达到。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int cnt = 0; bool f = true; for (int i = 0;i \u003c n;i++) { if (s[i] == '@')cnt++; if (i \u003e 0 \u0026\u0026 s[i] == '*' \u0026\u0026 s[i - 1] == '*'){ break; } } cout \u003c\u003c cnt \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Chaya Calendar","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#b-chaya-calendar"},{"categories":["在学算法的日子里"],"content":" 题意查亚部落相信世界末日有$n$个征兆，第$i$个征兆每隔$a_i$年出现一次，当观测到第$i-1$个征兆后才会等待第$i$个征兆。给出每个征兆的出现间隔，询问观测到所有$n$个征兆所需要的年数。 ps:当第$i$个征兆在第$x$年被观测，部落会从第$x+1$年开始等待第$i+1$个征兆。 数据范围$t(1≤t≤1000)$ $n(1≤n≤100)$​ $a_i(1\\le a_i\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意查亚部落相信世界末日有$n$个征兆，第$i$个征兆每隔$a_i$年出现一次，当观测到第$i-1$个征兆后才会等待第$i$个征兆。给出每个征兆的出现间隔，询问观测到所有$n$个征兆所需要的年数。 ps:当第$i$个征兆在第$x$年被观测，部落会从第$x+1$年开始等待第$i+1$个征兆。 数据范围$t(1≤t≤1000)$ $n(1≤n≤100)$​ $a_i(1\\le a_i\\le 10^6)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路第$i$个征兆间隔$a_i$年出现，若上一个征兆在第$x$年被观测，则下一个征兆将在第$y=k\\times a_i$年出现（$x\\lt y\\le x+a_i$）。等待的时间是$y-x$，也就是$a_i-x\\text{ }mod\\text{ }a_i$年。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; ll lf = a[i] - sum % a[i]; sum += lf; } cout \u003c\u003c sum \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-LR-remainders","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#c-lr-remainders"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组$a$，一个正整数$m$和长度为$n$的命令（由L和R组成的字符串），每次求数组中剩余数的积模$m$的余数并输出，然后按照命令删数（L删去最左边的数，R删去最右边的数）。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个数组$a$，一个正整数$m$和长度为$n$的命令（由L和R组成的字符串），每次求数组中剩余数的积模$m$的余数并输出，然后按照命令删数（L删去最左边的数，R删去最右边的数）。 数据范围$t(1≤t≤10^4)$ $n,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路反过来考虑，从最后一个删去的数开始，每次对积乘上上一次被删去的数，记录模m的值，逆序输出。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } string s;cin \u003e\u003e s; vector\u003cint\u003eb; int l = 0, r = n - 1; for (int i = 0;i \u003c n;i++) { if (s[i] == 'L')b.push_back(a[l++]); else b.push_back(a[r--]); } ll ans = 1; vector\u003cint\u003eres; reverse(b.begin(), b.end()); for (int i = 0;i \u003c n;i++) { ans *= b[i]; res.push_back(ans % m); ans %= m; } reverse(res.begin(), res.end()); for (int i = 0;i \u003c n;i++) { cout \u003c\u003c res[i] \u003c\u003c \" \"; }cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-Card Game","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#d-card-game"},{"categories":["在学算法的日子里"],"content":" 题意纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花色之间比较数字大小。 给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。 数据范围$t(1≤t≤100)$ $n(1\\le n \\le 16)$​ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花色之间比较数字大小。 给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。 数据范围$t(1≤t≤100)$ $n(1\\le n \\le 16)$​ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路模拟。 先对不同花色的牌分类，然后遍历同花色的牌，排序后，将非王牌花色放入一个序列，王牌花色单独一个序列。 从非王牌花色序列开始遍历，如果当前牌和其后一牌是同一种花色，凑成一对局；如果不是，用一张王牌花色和它凑成一个对局。假如可以凑成所有的对局，输出这些对局，否则不能构成对局。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string w;cin \u003e\u003e w; int f = 0; switch (w[0]) { case 'S':f = 3;break; case 'H':f = 2;break; case 'D':f = 1;break; case 'C':f = 0;break; default:break; } vector\u003cvector\u003cstring\u003e\u003esp(4); for (int i = 0;i \u003c 2 * n;i++) { string s;cin \u003e\u003e s; if (s[1] == 'C')sp[0].push_back(s); else if (s[1] == 'D')sp[1].push_back(s); else if (s[1] == 'H')sp[2].push_back(s); else sp[3].push_back(s); } vector\u003cstring\u003erk; for (int i = 0;i \u003c 4;i++) { if (i == f)continue; sort(sp[i].begin(), sp[i].end()); for (int j = 0;j \u003c sp[i].size();j++) rk.push_back(sp[i][j]); } sort(sp[f].begin(), sp[f].end()); for (int j = 0;j \u003c sp[f].size();j++) rk.push_back(sp[f][j]); vector\u003cpair\u003cstring, string\u003e\u003eans; int cnt = 0;int p = rk.size() - 1; for (int i = 0;i \u003c p;i++) { if (rk[i][1] == rk[i + 1][1]) { ans.push_back({ rk[i],rk[i + 1] });i++; cnt++; } else { if (f == 0 \u0026\u0026 rk[p][1] == 'C') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 1 \u0026\u0026 rk[p][1] == 'D') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 2 \u0026\u0026 rk[p][1] == 'H') { ans.push_back({ rk[i],rk[p] });p--; } else if (f == 3 \u0026\u0026 rk[p][1] == 'S') { ans.push_back({ rk[i],rk[p] });p--; } else { cout \u003c\u003c \"IMPOSSIBLE\\n\";return; } } } for (int i = 0;i \u003c n;i++) { cout \u003c\u003c ans[i].first \u003c\u003c \" \" \u003c\u003c ans[i].second \u003c\u003c '\\n'; } } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-Final Countdown","date":"2024-02-29","objectID":"/posts/cfround927div3/:0:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#e-final-countdown"},{"categories":["在学算法的日子里"],"content":" 题意倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。 求实际上需要多少秒完成倒计时。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤4\\times 10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。 求实际上需要多少秒完成倒计时。 数据范围$t(1≤t≤10^4)$ $n(1≤n≤4\\times 10^5)$​ $a_i(1\\le a_i\\le 10^4)$ ","date":"2024-02-29","objectID":"/posts/cfround927div3/:1:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路计数模拟： 12345 1234 123 12 1 -----+ 13715 则对从第一位开始做前缀和，对(前缀和+进位)倒着取模，最后输出即可。 ","date":"2024-02-29","objectID":"/posts/cfround927div3/:2:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int x = 0; while (s[x] == '0') { x++; } s = s.substr(x); vector\u003cll\u003ev; for (int i = 0;i \u003c s.size();i++) { if (i != 0) v.push_back(v.back() + s[i] - '0'); else { v.push_back(s[i] - '0'); } } reverse(v.begin(), v.end()); ll k = 0; vector\u003cint\u003eres; for (int i = 0;i \u003c v.size();i++) { res.emplace_back((v[i] + k) % 10); k = (v[i] + k) / 10; } while(k \u003e 0) { res.emplace_back(k % 10); k /= 10; } reverse(res.begin(), res.end()); for (int i = 0;i \u003c res.size();i++) { cout \u003c\u003c res[i]; }cout \u003c\u003c '\\n'; } ","date":"2024-02-29","objectID":"/posts/cfround927div3/:3:0","series":["题解记录"],"tags":["算法","CF"],"title":"Codeforces Round 927(div3)","uri":"/posts/cfround927div3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-宇宙的终结","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#a-宇宙的终结"},{"categories":["在学算法的日子里"],"content":" 题意在$[l,r]$中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。 数据范围$1\\leq l\\leq r \\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意"},{"categories":["在学算法的日子里"],"content":" 题意在$[l,r]$中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。 数据范围$1\\leq l\\leq r \\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路数据小，模拟即可 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { vector\u003cbool\u003eisprime(101, true); // 判断素数 isprime[0] = isprime[1] = false; for (int i = 2;i \u003c= 100;i++) { if (isprime[i]) { for (int j = i + i;j \u003c= 100;j += i) { isprime[j] = false; } } } int l, r; cin \u003e\u003e l \u003e\u003e r; for (int i = 2;i \u003c= r;i++) { for (int j = 2;j \u003c= r;j++) { for (int k = 2;k \u003c= r;k++) { if (isprime[i] \u0026\u0026 isprime[j] \u0026\u0026 isprime[k] \u0026\u0026 i != j \u0026\u0026 j != k \u0026\u0026 i != k) { if (i * j * k \u003e= l \u0026\u0026 i * j * k \u003c= r) { cout \u003c\u003c i * j * k;return; } } } } } cout \u003c\u003c -1; } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-爱恨的纠葛","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#b-爱恨的纠葛"},{"categories":["在学算法的日子里"],"content":" 题意定义两个等长数组的亲密值：$|a_i-b_i|(1\\leq i\\leq n)$的最小值。给定2个数组，可以任意排列$a$数组的元素顺序，输出一个亲密度最小的方案（数组$a$的操作结果）。 数据范围$1\\leq n\\leq 10^5$ $1\\leq a,b \\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意定义两个等长数组的亲密值：$|a_i-b_i|(1\\leq i\\leq n)$的最小值。给定2个数组，可以任意排列$a$数组的元素顺序，输出一个亲密度最小的方案（数组$a$的操作结果）。 数据范围$1\\leq n\\leq 10^5$ $1\\leq a,b \\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路将$a,b$数组的数据放入 一个数组中，进行排序，从第一位开始遍历，如果某两个相邻的数一个来自于$a$数组，一个来自于$b$数组，更新最小的差的绝对值，将$a$数组中的这两个相匹配的位置进行互换后输出$a$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n), b(n); vector\u003cpair\u003cll, pair\u003cint,int\u003e\u003e\u003ec; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; c.push_back({ a[i],{0,i} }); } for (int i = 0;i \u003c n;i++) { cin \u003e\u003e b[i]; c.push_back({ b[i],{1,i} }); } sort(c.begin(), c.end()); ll ans = 1e9 + 20; int pa = 0, pb = 0; for (int i = 1;i \u003c 2 * n;i++) { if (c[i].second.first != c[i - 1].second.first) { if (c[i].first - c[i - 1].first \u003c ans) { ans = c[i].first - c[i - 1].first; if(c[i].second.first == 0) { pa = c[i].second.second; pb = c[i - 1].second.second; } else { pa = c[i - 1].second.second; pb = c[i].second.second; } } } } ll tp = a[pa];a[pa] = a[pb];a[pb] = tp; for (int i = 0;i \u003c n;i++) { cout \u003c\u003c a[i] \u003c\u003c ' '; } } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-心绪的解剖","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#c-心绪的解剖"},{"categories":["在学算法的日子里"],"content":" 题意将$n$分解为三个斐波那契数列之和。 数据范围$1\\leq q \\leq 10^5$ $1\\leq n\\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意将$n$分解为三个斐波那契数列之和。 数据范围$1\\leq q \\leq 10^5$ $1\\leq n\\leq 10^9$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路斐波那契数列到$F_{45}$是大于$10^{10}$的，联系到斐波那契数列的单调性，每次二分出不大于$n$的一位$F_x$，再在$n$中减去这个$F_x$直到$n$为0，如果三次二分后无法使得$n=0$则无解。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll q;cin \u003e\u003e q; vector\u003cll\u003ef(45, 0); f[0] = 0;f[1] = 1; for (int i = 2;i \u003c 45;i++) { f[i] = f[i - 1] + f[i - 2]; } while (q--) { ll n;cin \u003e\u003e n; int p1 = upper_bound(f.begin(), f.end(), n) - f.begin(); p1--; n -= f[p1]; ll f1 = f[p1]; if (n == 0) { cout \u003c\u003c f1 \u003c\u003c \" 0 0\\n\";continue; } int p2 = upper_bound(f.begin(), f.end(), n) - f.begin(); p2--; n -= f[p2]; ll f2 = f[p2]; if (n == 0) { cout \u003c\u003c f1 \u003c\u003c ' ' \u003c\u003c f2 \u003c\u003c \" 0\\n\";continue; } int p3 = upper_bound(f.begin(), f.end(), n) - f.begin(); p3--; n -= f[p3]; ll f3 = f[p3]; if (n == 0) cout \u003c\u003c f1 \u003c\u003c ' ' \u003c\u003c f2 \u003c\u003c ' ' \u003c\u003c f3 \u003c\u003c '\\n'; else cout \u003c\u003c \"-1\\n\"; } } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-友谊的套路","date":"2024-02-26","objectID":"/posts/nc24wd6/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#d-友谊的套路"},{"categories":["在学算法的日子里"],"content":" 题意一场$BO5$的游戏（五局三胜），已知某队伍获胜的概率是$p$，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局） 数据范围$0\\lt p\\lt 1$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意一场$BO5$的游戏（五局三胜），已知某队伍获胜的概率是$p$，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局） 数据范围$0\\lt p\\lt 1$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路赢赢输输输or输输赢赢赢 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { double p;cin \u003e\u003e p; double ans = 0.0; double q = 1 - p; ans += p * p * q * q * q + q * q * p * p * p; printf(\"%.6f\", ans); } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E-未来的预言","date":"2024-02-26","objectID":"/posts/nc24wd6/:5:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#e-未来的预言"},{"categories":["在学算法的日子里"],"content":" 题意BO机制：$BOx$代表$x$局先胜$x/2+1$次为赢，$x$为奇数。 给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。 判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。 数据范围$1\\leq x\\leq 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意BO机制：$BOx$代表$x$局先胜$x/2+1$次为赢，$x$为奇数。 给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。 判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。 数据范围$1\\leq x\\leq 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路遍历统计，先赢到$x/2$次的获胜。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:5:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n; scanf(\"BO%d\", \u0026n); n = n / 2 + 1; string res;cin \u003e\u003e res; int a = 0, b = 0; for (int i = 0;i \u003c res.size();i++) { if (res[i] == 'R') { a++; } else { b++; } if (a == n) { cout \u003c\u003c \"kou!\\n\" \u003c\u003c i + 1; return; } if (b == n) { cout \u003c\u003c \"yukari!\\n\" \u003c\u003c i + 1; return; } } cout \u003c\u003c \"to be continued.\\n\"; cout \u003c\u003c res.size(); } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:5:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" I-时空的交织","date":"2024-02-26","objectID":"/posts/nc24wd6/:6:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#i-时空的交织"},{"categories":["在学算法的日子里"],"content":" 题意一个$n$行$m$列的矩阵，每个元素由$a$数组和$b$数组决定，第$i$行第$j$列的元素为$a_i\\times b_j$，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。 数据范围$1\\leq n,m\\leq 10^5$ $-10^4 \\leq a_i,b_i\\leq 10^4$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意一个$n$行$m$列的矩阵，每个元素由$a$数组和$b$数组决定，第$i$行第$j$列的元素为$a_i\\times b_j$，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。 数据范围$1\\leq n,m\\leq 10^5$ $-10^4 \\leq a_i,b_i\\leq 10^4$ ","date":"2024-02-26","objectID":"/posts/nc24wd6/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路对$a、b$数组分别求最大子段和和最小子段和，最大子矩阵元素和是这四个数分别相乘的积中最大的一个。 ","date":"2024-02-26","objectID":"/posts/nc24wd6/:7:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ea(n), b(m); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; for (int i = 0;i \u003c m;i++)cin \u003e\u003e b[i]; vector\u003cll\u003epa(n), qa(n); pa[0] = qa[0] = a[0]; ll xa, ya;xa = ya = a[0]; for (int i = 1;i \u003c n;i++) { if(pa[i-1]+a[i]\u003ea[i]){ pa[i] = pa[i - 1] + a[i]; } else{ pa[i] = a[i]; } xa = max(xa, pa[i]); if (qa[i - 1] + a[i] \u003c a[i]) { qa[i] = qa[i - 1] + a[i]; } else{ qa[i] = a[i]; } ya = min(ya, qa[i]); } vector\u003cll\u003epb(m), qb(m); pb[0] = qb[0] = b[0]; ll xb, yb;xb = yb = b[0]; for (int i = 1;i \u003c m;i++) { if(pb[i-1]+b[i]\u003eb[i]){ pb[i] = pb[i - 1] + b[i]; } else{ pb[i] = b[i]; } xb = max(xb, pb[i]); if(qb[i-1]+b[i]\u003cb[i]){ qb[i] = qb[i - 1] + b[i]; } else{ qb[i] = b[i]; } yb = min(yb, qb[i]); } cout \u003c\u003c max(xa * xb, max(xa * yb, max(ya * yb, ya * xb))) \u003c\u003c endl; } ","date":"2024-02-26","objectID":"/posts/nc24wd6/:7:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营6||补题","uri":"/posts/nc24wd6/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" A-柠檬可乐","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#a-柠檬可乐"},{"categories":["在学算法的日子里"],"content":" 题意输入$a,b,k$，判断$a\\ge k\\times b$是否成立 数据范围$a,b,k(1\\leq a,b,k\\leq 100)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意"},{"categories":["在学算法的日子里"],"content":" 题意输入$a,b,k$，判断$a\\ge k\\times b$是否成立 数据范围$a,b,k(1\\leq a,b,k\\leq 100)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路简单判断 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int a, b, k;cin \u003e\u003e a \u003e\u003e b \u003e\u003e k; if (a \u003e= k * b)cout \u003c\u003c \"good\\n\"; else cout \u003c\u003c \"bad\\n\"; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-左右互博","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#b-左右互博"},{"categories":["在学算法的日子里"],"content":" 题意有$n$堆石子，每次选择某堆石子，选一个整数$y(2\\leq y\\leq x)$，将石子分为$\\lfloor \\frac{x}{y} \\rfloor$和$x-\\lfloor \\frac{x}{y} \\rfloor$，直到某人不能操作时结束，不能操作者输。 数据范围$n,a_i(1\\leq n,a_i \\leq 2\\times 10^5)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意有$n$堆石子，每次选择某堆石子，选一个整数$y(2\\leq y\\leq x)$，将石子分为$\\lfloor \\frac{x}{y} \\rfloor$和$x-\\lfloor \\frac{x}{y} \\rfloor$，直到某人不能操作时结束，不能操作者输。 数据范围$n,a_i(1\\leq n,a_i \\leq 2\\times 10^5)$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路相当于每次至少分出1个石子出来，计算将所有石头分出1颗一份的操作数，判断拿到最后一颗石子的是谁即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0; for (int i = 0;i \u003c n;i++){ cin \u003e\u003e a[i]; sum += a[i] - 1; } if (sum % 2) { cout \u003c\u003c \"gui\\n\"; } else cout \u003c\u003c \"sweet\\n\"; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-冬眠","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#c-冬眠"},{"categories":["在学算法的日子里"],"content":" 题意给一个$n\\times m$的字符矩阵，每天有$q$次行循环移动或列循环移动，共执行$p$次，最后询问第$x$行$y$​列是什么字符。 $op=1$表示行循环移动 $op=2$表示列循环移动 数据范围$1\\leq n,m,p,q\\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意给一个$n\\times m$的字符矩阵，每天有$q$次行循环移动或列循环移动，共执行$p$次，最后询问第$x$行$y$​列是什么字符。 $op=1$表示行循环移动 $op=2$表示列循环移动 数据范围$1\\leq n,m,p,q\\leq 100$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路记录循环移动顺序，然后将$(x,y)$的字符逆顺序模拟即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m, x, y; cin \u003e\u003e n \u003e\u003e m \u003e\u003e x \u003e\u003e y; x -= 1, y -= 1; vector\u003cstring\u003erec(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e rec[i]; } int p, q;cin \u003e\u003e p \u003e\u003e q; vector\u003cpair\u003cint, int\u003e\u003eopz; for (int i = 0;i \u003c q;i++) { int z, op;cin \u003e\u003e op \u003e\u003e z; opz.push_back({ op,z }); } for (int i = 0;i \u003c p;i++) { for (int j = q - 1;j \u003e= 0;j--) { int op = opz[j].first, z = opz[j].second; if (op == 1 \u0026\u0026 x == z - 1) { y -= 1; y = (y + m) % m; } else if (op == 2 \u0026\u0026 y == z - 1) { x -= 1; x = (x + n) % n; } // cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c '\\n'; } } cout \u003c\u003c rec[x][y] \u003c\u003c '\\n'; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-守恒","date":"2024-02-26","objectID":"/posts/nc24wd4/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#d-守恒"},{"categories":["在学算法的日子里"],"content":" 题意有一个长度为$n$的数组，每次操作可以对数组$a$中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少种不同的值？ 数据范围$1\\leq n,a_i\\leq 2\\times 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有一个长度为$n$的数组，每次操作可以对数组$a$中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少种不同的值？ 数据范围$1\\leq n,a_i\\leq 2\\times 10^5$ ","date":"2024-02-26","objectID":"/posts/nc24wd4/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路特判$n=1$的时候（答案为1） $n\\ge 2$时，枚举最大公约数，计数合适的数的数量即可。 ","date":"2024-02-26","objectID":"/posts/nc24wd4/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll sum = 0ll; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i];sum += a[i]; } if (n == 1) { cout \u003c\u003c 1 \u003c\u003c '\\n';return; } set\u003cll\u003eres; ll f = sum / n; for (ll k = 1;k * k \u003c= sum;k++) { if (sum % k == 0) { ll x = sum / k; if (x \u003e= n \u0026\u0026 k \u003c= f) { res.insert(k); } if (k * k != sum \u0026\u0026 k \u003e= n \u0026\u0026 sum / k \u003c= f) { res.insert(sum / k); } } } cout \u003c\u003c res.size() \u003c\u003c '\\n'; } ","date":"2024-02-26","objectID":"/posts/nc24wd4/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营4||补题","uri":"/posts/nc24wd4/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" A-mutsumi的质数合数","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#a-mutsumi的质数合数"},{"categories":["在学算法的日子里"],"content":" 题意一个由$n$个正整数组成的数组，求其中质数和合数共有几个。 数据范围$n(1\\leq n\\leq 100)$ $a_i(1\\leq a_i\\leq 100)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意"},{"categories":["在学算法的日子里"],"content":" 题意一个由$n$个正整数组成的数组，求其中质数和合数共有几个。 数据范围$n(1\\leq n\\leq 100)$ $a_i(1\\leq a_i\\leq 100)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路1不是质数也不是合数。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; int ans = 0; for (int i = 0;i \u003c n;i++) { int x;cin \u003e\u003e x; if (x\u003e1)ans++; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码"},{"categories":["在学算法的日子里"],"content":" C-anon的私货","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#c-anon的私货"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组中一些位置插入$0$，要求插入后任意不是全$0$子段的平均值大于等于$1$，询问最多插入多少个$0$ 数据范围$n(1\\leq n\\leq 10^5)$ $a_i(1\\leq a_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意给一个数组中一些位置插入$0$，要求插入后任意不是全$0$子段的平均值大于等于$1$，询问最多插入多少个$0$ 数据范围$n(1\\leq n\\leq 10^5)$ $a_i(1\\leq a_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路从第一位开始贪，统计在每一位前最多可以插入多少个0，考虑两数之间的0的数目不能大于这2位之间允许的最大值。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 2); vector\u003cll\u003eb(n + 2); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; b[i] = a[i] - 1; } b[0] = 1e9 + 50; b[n + 1] = 1e9 + 50; ll ans = 0; for (int i = 0;i \u003c= n;i++) { // for (int j = 0;j \u003c= n + 1;j++)cout \u003c\u003c b[j] \u003c\u003c ' ';cout \u003c\u003c endl; if (b[i] \u003e= b[i + 1]) { ans += b[i + 1]; ll tmp = b[i + 1]; b[i + 1] = 0; b[i] -= tmp; } else { ans += b[i]; ll tmp = b[i]; b[i] = 0; b[i + 1] -= tmp; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" E-soyorin的数组操作（easy）","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#e-soyorin的数组操作easy"},{"categories":["在学算法的日子里"],"content":" 题意有一个长为$n$的数组$a$ 操作：选择一个不超过$n$的偶数$k$，$a_i=a_i+i(1\\leq i\\leq k)$ 询问是否能在任意操作后使得数组非降序。 数据范围$T(1≤T≤10^6)$ $n(1≤n≤10^5)$ $a_i(1\\leq a_i\\leq 10^{12})$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一个长为$n$的数组$a$ 操作：选择一个不超过$n$的偶数$k$，$a_i=a_i+i(1\\leq i\\leq k)$ 询问是否能在任意操作后使得数组非降序。 数据范围$T(1≤T≤10^6)$ $n(1≤n≤10^5)$ $a_i(1\\leq a_i\\leq 10^{12})$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路操作的效果是使得$a_{i+1}-a{i}$的值增大1，从后往前遍历，将靠后的部分先操作为非降序（操作的效果会影响到前段） ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } if (n % 2 == 0 || n == 1) { // 加個無窮次總能彌補不合適的地方 cout \u003c\u003c \"YES\\n\";return; } // a(n-1)上限是a(n)，在這個上限下能不能把它變成需要的 ll d = 0; // 操作次數(對應相鄰兩個數之間的差距減少d(越靠後增加的越多 for (int i = n - 1;i \u003e= 1;i--) { if (a[i] \u003e a[i + 1] + d) { cout \u003c\u003c \"NO\\n\";return; } if (i % 2 == 0) d += (a[i + 1] - a[i] + d) / i; } cout \u003c\u003c \"YES\\n\"; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" G\u0026H-sakiko的排列构造（easy/hard）","date":"2024-02-21","objectID":"/posts/nc24wd5/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#gh-sakiko的排列构造easyhard"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长为$n$的排列，使得排列中每个$p_i+i(1\\leq i\\leq n)$都是质数。 输出符合要求的排列，若无解输出-1。 数据范围$n(1\\leq n\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意构造一个长为$n$的排列，使得排列中每个$p_i+i(1\\leq i\\leq n)$都是质数。 输出符合要求的排列，若无解输出-1。 数据范围$n(1\\leq n\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路排列是$1\\sim n$的，下标也是$1\\sim n$的，从$p_i=n$开始给寻找匹配的下标(在可选范围内从小到大)，也就是寻找使得$p_i+i$是质数的最小$i$，即比$p_i$大的最小质数。如果该符合要求的质数可以被找到就缩小范围，直到所有的数都可以被确定。(从ac结果看似乎并不存在无法被构造出的排列耶) ","date":"2024-02-21","objectID":"/posts/nc24wd5/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; if (n == 1) { cout \u003c\u003c \"1\\n\"; return; } else if (n == 2) { cout \u003c\u003c \"2 1\\n\"; return; } vector\u003cll\u003eprimes(n * 2 + 1); vector\u003cbool\u003eisprime(n * 2 + 1, true); isprime[0] = isprime[1] = false; for (int i = 2;i \u003c= 2 * n;i++) { if (isprime[i]) { primes.push_back(i); for (int j = i + i;j \u003c= 2 * n;j += i) { isprime[j] = false; } } } ll x = n; ll pos = n; vector\u003cll\u003ea(n + 1); while (pos \u003e= 1) { bool f = false; for (int i = pos + 1;i \u003c= pos * 2;i++) { if (isprime[i]) { f = true; x = i;break; } } // 从ac结果看似乎并不存在-1的情况(好神奇！) // if (!f) { // cout \u003c\u003c -1 \u003c\u003c '\\n';return; // } // if (x \u003e pos * 2) { // cout \u003c\u003c -1 \u003c\u003c '\\n';return; // } // ai+i=x for (int i = pos;i \u003e= x - pos;i--) { a[i] = x - i; } pos = x - pos - 1; } for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c a[i] \u003c\u003c ' '; }cout \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" I-rikki的最短路","date":"2024-02-21","objectID":"/posts/nc24wd5/:5:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#i-rikki的最短路"},{"categories":["在学算法的日子里"],"content":" 题意给出一位轴上的3个坐标，$rikki$需要把$A$带到$T$的坐标，初始$rikki$在原点，且只知道$T$的坐标，到达$T$之后可以知道$A$的坐标。 $rikki$有一个范围为$k$的视野，在$[u-k,u+k]$视野内的$A$可以被发现。 数据范围$t,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意给出一位轴上的3个坐标，$rikki$需要把$A$带到$T$的坐标，初始$rikki$在原点，且只知道$T$的坐标，到达$T$之后可以知道$A$的坐标。 $rikki$有一个范围为$k$的视野，在$[u-k,u+k]$视野内的$A$可以被发现。 数据范围$t,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路签到模拟(怎么会有人签到交7发才过啊(小声)) 视野只有在出发点的时候看A有用，其他情况按规则来qwq ","date":"2024-02-21","objectID":"/posts/nc24wd5/:5:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll t, a, k;cin \u003e\u003e t \u003e\u003e a \u003e\u003e k; if (a \u003e= -k \u0026\u0026 a \u003c= k) { if (a * t \u003e 0) { cout \u003c\u003c t \u003c\u003c '\\n';return; } else { cout \u003c\u003c abs(2 * a - t) \u003c\u003c '\\n';return; } } else if (a * t \u003e 0) { if (abs(a) \u003c abs(t)) { cout \u003c\u003c abs(t) \u003c\u003c '\\n';return; } else { cout \u003c\u003c abs(a) + abs(a - t) \u003c\u003c '\\n';return; } } else { cout \u003c\u003c 3 * abs(t) + 2 * abs(a) \u003c\u003c '\\n';return; } } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:5:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" J-rikki的数组陡峭值","date":"2024-02-21","objectID":"/posts/nc24wd5/:6:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#j-rikki的数组陡峭值"},{"categories":["在学算法的日子里"],"content":" 题意数组的陡峭值：数组相邻元素之差的绝对值之和。 给出数组$a$中每个元素$a_i$的范围$[l_i,r_i]$，求最小的陡峭值。 数据范围$n(1\\leq n\\leq 10^5)$ $l_i,r_i(1\\leq l_i,r_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意数组的陡峭值：数组相邻元素之差的绝对值之和。 给出数组$a$中每个元素$a_i$的范围$[l_i,r_i]$，求最小的陡峭值。 数据范围$n(1\\leq n\\leq 10^5)$ $l_i,r_i(1\\leq l_i,r_i\\leq 10^9)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路贪心，从前往后遍历，如果$a_i$和$a_{i+1}$的范围有重合，则直接将$a_i$和$a_{i+1}$的值取成同一个数，陡峭值不增加，更新$a_{i+1}$的范围为两数重合的范围。如果范围不重合，两数分别取靠近的两个端点，并将$a_{i+1}$的范围缩成1个点。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:6:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003el(n + 1), r(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e l[i] \u003e\u003e r[i]; } // 這題該不會能貪吧(破防 ll ans = 0; for (int i = 1;i \u003c n;i++) { ll x = max(l[i], l[i + 1]); ll y = min(r[i], r[i + 1]); if (x \u003c= y) { // 貪貪貪 l[i + 1] = x;r[i + 1] = y; } else { ans += abs(x - y); if (r[i + 1] \u003c l[i]) l[i + 1] = r[i + 1]; else r[i + 1] = l[i + 1]; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:6:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" K-soyorin的通知","date":"2024-02-21","objectID":"/posts/nc24wd5/:7:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#k-soyorin的通知"},{"categories":["在学算法的日子里"],"content":" 题意$soyorin$要把消息传递给$n$个人，每个知道消息的可以将消息传递给其他人。 第$i$个人可以花费$a_i$将消息通知给最多$b_i$个人，前提是第$i$个人已知消息，消息源通知一个人花费为$p$。求最小花费。 数据范围$n(1\\leq n\\leq 1000)$ $p(1\\leq p\\leq 10^6)$ $a_i,b_i(1\\leq a_i,b_i\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:7:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意$soyorin$要把消息传递给$n$个人，每个知道消息的可以将消息传递给其他人。 第$i$个人可以花费$a_i$将消息通知给最多$b_i$个人，前提是第$i$个人已知消息，消息源通知一个人花费为$p$。求最小花费。 数据范围$n(1\\leq n\\leq 1000)$ $p(1\\leq p\\leq 10^6)$ $a_i,b_i(1\\leq a_i,b_i\\leq 10^6)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:7:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路dp，更新通知$i$个人的最小花费。每当第$i$个人知道消息时更新使得$j$人知道消息的花费。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:7:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, p;cin \u003e\u003e n \u003e\u003e p; vector\u003cll\u003ea(n + 1), b(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } // dp：通知i個人的最小花費j,dp[i]=j vector\u003cll\u003edp(n + 1); for (int i = 1;i \u003c= n;i++) dp[i] = p * i; for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { // 第i個人已經被通知的情況下，通知j個人，花費a[i] if (j - b[i] \u003e 0) dp[j] = min(dp[j], dp[j - b[i]] + a[i]); else dp[j] = min(dp[j], dp[1] + a[i]); } } cout \u003c\u003c dp[n] \u003c\u003c '\\n'; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:7:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" L-anon的星星","date":"2024-02-21","objectID":"/posts/nc24wd5/:8:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#l-anon的星星"},{"categories":["在学算法的日子里"],"content":" 题意赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。 已知一共玩了$n$局，共获得了$x$颗星星，求胜利了几局失败了几局。 如果无法知道胜利的局数和失败的局数输出-1。 数据范围$n(1\\leq n\\leq 1000)$ $x(-n\\leq x\\leq n)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:8:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。 已知一共玩了$n$局，共获得了$x$颗星星，求胜利了几局失败了几局。 如果无法知道胜利的局数和失败的局数输出-1。 数据范围$n(1\\leq n\\leq 1000)$ $x(-n\\leq x\\leq n)$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:8:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路赢$k$局就是失败$n-k$局，星星数是$k-(n-k)$。如果$k$有合法值就是合法的。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:8:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, x;cin \u003e\u003e n \u003e\u003e x; if ((n + x) \u0026 1) { cout \u003c\u003c -1 \u003c\u003c '\\n'; } else { ll k = (n + x) / 2; cout \u003c\u003c k \u003c\u003c ' ' \u003c\u003c n - k \u003c\u003c '\\n'; } } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:8:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" M-mutsumi的排列连通","date":"2024-02-21","objectID":"/posts/nc24wd5/:9:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#m-mutsumi的排列连通"},{"categories":["在学算法的日子里"],"content":" 题意有两个长度为$n$的排列上下组成$2\\times n$的矩形。 有操作：选择数字$x$，将矩形中的$x$删去。 询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。 如果无法实现，输出-1。 数据范围$T(1\\leq T\\leq 10^5)$ $n(1\\leq n\\leq 10^5)$ 排列$a(1\\leq a_i\\leq n)$ 排列$b(1\\leq b_i\\leq n)$ $n$总和不超过$10_5$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:9:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意有两个长度为$n$的排列上下组成$2\\times n$的矩形。 有操作：选择数字$x$，将矩形中的$x$删去。 询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。 如果无法实现，输出-1。 数据范围$T(1\\leq T\\leq 10^5)$ $n(1\\leq n\\leq 10^5)$ 排列$a(1\\leq a_i\\leq n)$ 排列$b(1\\leq b_i\\leq n)$ $n$总和不超过$10_5$ ","date":"2024-02-21","objectID":"/posts/nc24wd5/:9:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路特判$n=1,2$。 $n\\ge 3$的最多删2个即可实现需求。 遍历寻找是否存在$a_i=b_i$或者$a_i=b_{i+1}$或者$a_i=b_{i-1}$的情况，注意边界判断。 ","date":"2024-02-21","objectID":"/posts/nc24wd5/:9:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#思路-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n + 1), b(n + 1); for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e b[i]; } if (n == 1) { cout \u003c\u003c \"-1\\n\";return; } if (n == 2) { if (a[1] == b[1]) { cout \u003c\u003c \"-1\\n\"; } else { cout \u003c\u003c \"1\\n\"; } return; } for (int i = 1;i \u003c= n;i++) { if ((i != 1 \u0026\u0026 i != n \u0026\u0026 a[i] == b[i]) || (i \u003e 1 \u0026\u0026 a[i] == b[i - 1]) || (i \u003c n \u0026\u0026 a[i] == b[i + 1])) { cout \u003c\u003c \"1\\n\";return; } } cout \u003c\u003c \"2\\n\";return; } ","date":"2024-02-21","objectID":"/posts/nc24wd5/:9:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营5||补题","uri":"/posts/nc24wd5/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" A-智乃与瞩目狸猫、幸运水母、月宫龙虾","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#a-智乃与瞩目狸猫幸运水母月宫龙虾"},{"categories":["在学算法的日子里"],"content":" 题意在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代号。 数据范围$T(1\\leq T \\leq 10^5)$ $S,T(1\\leq |S|,|T|\\leq 50)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意"},{"categories":["在学算法的日子里"],"content":" 题意在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代号。 数据范围$T(1\\leq T \\leq 10^5)$ $S,T(1\\leq |S|,|T|\\leq 50)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路按题意判断即可 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; if (s[0] == t[0] || abs(s[0] - t[0]) == abs('a' - 'A')) { cout \u003c\u003c \"Yes\\n\"; } else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-智乃的数字手串","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#b-智乃的数字手串"},{"categories":["在学算法的日子里"],"content":" 题意一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。 数据范围$T(1\\leq T \\leq 10^4)$ $N(1\\leq N\\leq 26)$ $a_i(0\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。 数据范围$T(1\\leq T \\leq 10^4)$ $N(1\\leq N\\leq 26)$ $a_i(0\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路只有1个数时直接取走，先手赢。 2个数时：奇偶/奇奇/偶偶，都是后手赢。 3个数时：奇偶奇/偶奇偶/奇奇奇/偶偶偶，都是先手赢。 … 结束时候的状态是奇偶奇偶...奇偶，如果数量是奇数个，一定存在奇奇/偶偶，操作后可能直接结束游戏或继续，如果数量是偶数个且可操作，则转移为奇数时的状态且此时下一位操作者一定可以再操作。双方的操作不会改变他面对该数字串时数字的个数的奇偶性。也就是说，只有一直面对奇数个数的一方才能赢。 故判断原始长度，看先手是否在奇数位。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } if (n \u0026 1)cout \u003c\u003c \"qcjj\\n\"; else cout \u003c\u003c \"zn\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" D-chino’s bubble sort and maximum subarray sum(easy version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#d-chinos-bubble-sort-and-maximum-subarray-sumeasy-version"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组内的元素进行恰好$K$次相邻元素交换后，求整个数组的最大子段和。 数据范围$N,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)$ $a_i(-10^9\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意对一个数组内的元素进行恰好$K$次相邻元素交换后，求整个数组的最大子段和。 数据范围$N,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)$ $a_i(-10^9\\leq a_i \\leq 10^9)$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路easy版本的K只有两种取值（0和1），N的范围不大，分类处理，进行dp即可。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 ll maxsum(vector\u003cll\u003ea) { int n = a.size(); ll sum = a[0]; ll b = 0; for (int i = 0;i \u003c n;i++) { if (b \u003e 0)b += a[i]; else b = a[i]; if (b \u003e sum)sum = b; } return sum; } void solve() { int n, k;cin \u003e\u003e n \u003e\u003e k; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; ll ans; if (k == 0) { ans = maxsum(a); } else { for (int i = 0;i \u003c n - 1;i++) { a[i] = a[i] ^ a[i + 1]; a[i + 1] = a[i] ^ a[i + 1]; a[i] = a[i] ^ a[i + 1]; if (i != 0) ans = max(ans, maxsum(a)); else ans = maxsum(a); a[i] = a[i] ^ a[i + 1]; a[i + 1] = a[i] ^ a[i + 1]; a[i] = a[i] ^ a[i + 1]; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" G-智乃的比较函数(easy version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#g-智乃的比较函数easy-version"},{"categories":["在学算法的日子里"],"content":" 题意给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。 cmp的排序规则是这样的： $cmp(x,y)=1$表示规定$x\u003ey$，即$x$的顺序严格先于$y$ 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 2)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。 cmp的排序规则是这样的： $cmp(x,y)=1$表示规定$x\u003ey$，即$x$的顺序严格先于$y$ 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 2)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路只有3个数、两个约束关系时，不能构成$a_x\u003ca_y$且$a_y\u003ca_z$且$a_x\u003ea_z$，只需判断最多存在2中约束关系时的逻辑是否合法。 对于两个数$x$、$y$，不合法的约束关系只有：$cmp(x,y)=1$且$cmp(y,x)=1$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003erules(4, vector\u003cint\u003e(4, -1)); bool f = true; for (int i = 0;i \u003c n;i++) { int x, y, z;cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; if (!f)continue; if (x == y \u0026\u0026 z == 1)f = false; if (z == 1 \u0026\u0026 rules[y][x] == 1) { f = false; } if (rules[x][y] == -1) { rules[x][y] = z; if (z == 1) rules[y][x] = 0; } else if (rules[x][y] != z) f = false; } if (f)cout \u003c\u003c \"Yes\\n\"; else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" H-智乃的比较函数(normal version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:5:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#h-智乃的比较函数normal-version"},{"categories":["在学算法的日子里"],"content":" 题意同G 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 50)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意同G 数据范围$T(1\\leq T\\leq 2\\times 10^4)$ $N(1\\leq N\\leq 50)$ $x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路和G相比，N的范围大于2，不合法的情况增加了，但是依然只是3个数据之间判断合法性。 新增的三个关系不合法的情况有： $x\u003cy,x\u003cz,z\u003cx$ $x\\leq y,y\\leq z,z\u003cx$ 分别特判即可。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:5:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cvector\u003cint\u003e\u003erules(4, vector\u003cint\u003e(4, -1)); bool f = true; for (int i = 0;i \u003c n;i++) { int x, y, z;cin \u003e\u003e x \u003e\u003e y \u003e\u003e z; if (!f)continue; if (x == y \u0026\u0026 z == 1)f = false; if (z == 1 \u0026\u0026 rules[y][x] == 1) { f = false; } if (rules[x][y] == -1) { rules[x][y] = z; if (z == 1) rules[y][x] = 0; } else if (rules[x][y] != z) f = false; } if (rules[1][2] == 1 \u0026\u0026 rules[2][3] == 1 \u0026\u0026 rules[3][1] == 1) f = false; if (rules[1][3] == 1 \u0026\u0026 rules[3][2] == 1 \u0026\u0026 rules[2][1] == 1) f = false; for (int x = 1;x \u003c= 3;x++) { for (int y = 1;y \u003c= 3;y++) { if (y == x)continue; int z = 6 - x - y; if (rules[x][y] == 0 \u0026\u0026 rules[y][z] == 0 \u0026\u0026 rules[x][z] == 1) f = false; } } if (f)cout \u003c\u003c \"Yes\\n\"; else cout \u003c\u003c \"No\\n\"; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:5:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" L\u0026M-智乃的36倍数(easy/hard version)","date":"2024-02-13","objectID":"/posts/nc24wd3/:6:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#lm-智乃的36倍数easyhard-version"},{"categories":["在学算法的日子里"],"content":" 题意定义一种运算$f$，可以将正整数按照字面值从左到右拼接，如：$f(123,569)=1234569$。 一个正整数数组，其中有多少对有序对$i,j(i≠j)$满足$f(a_i,a_j)$是36的倍数。 数据范围easy: $N(1\\leq N\\leq 1000)$ $a_i(1\\leq a_i \\leq 10)$ hard： $N(1\\leq N\\leq 10^5)$ $a_i(1\\leq a_i \\leq 10^{18})$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意定义一种运算$f$，可以将正整数按照字面值从左到右拼接，如：$f(123,569)=1234569$。 一个正整数数组，其中有多少对有序对$i,j(i≠j)$满足$f(a_i,a_j)$是36的倍数。 数据范围easy: $N(1\\leq N\\leq 1000)$ $a_i(1\\leq a_i \\leq 10)$ hard： $N(1\\leq N\\leq 10^5)$ $a_i(1\\leq a_i \\leq 10^{18})$ ","date":"2024-02-13","objectID":"/posts/nc24wd3/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路easy版本的数据较小，直接双层循环暴力即可。 hard版本可以考虑同余，k是y的位数。 $$ f(x,y)=x\\times 10^{k}+y $$ $$ f(x,y)% 36=0 $$ $$ (x\\times 10^{k}+y)%36=0 $$ $$ (x%36\\times 10^{k}%36+y%36)%36=0 $$ 对数组预处理后，枚举以$y$结尾。 ","date":"2024-02-13","objectID":"/posts/nc24wd3/:6:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 // 暴力easy version void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } int cnt = 0; for (int i = 0;i \u003c n;i++) { for (int j = i + 1;j \u003c n;j++) { int n1 = a[i] * 10 + a[j]; int n2 = a[j] * 10 + a[i]; if (n1 % 36 == 0)cnt++; if (n2 % 36 == 0)cnt++; } } cout \u003c\u003c cnt \u003c\u003c '\\n'; } // hard version void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); map\u003cint, int\u003ecnt; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; cnt[a[i] % 36]++; } ll k = 1; vector\u003cint\u003edk(19); for (int i = 1;i \u003c 19;i++) { k *= 10; dk[i] = k % 36; } auto getlen = [](ll x) { int i = 0; while (x) { i++;x /= 10; } return i; }; ll ans = 0; for (int i = 0;i \u003c n;i++) { int x = a[i] % 36; int z = getlen(a[i]); for (int j = 0;j \u003c 36;j++) { if ((j * dk[z] + x) % 36 == 0) { ans += cnt[j]; if (j == x)ans -= 1; } } } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-13","objectID":"/posts/nc24wd3/:6:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营3||补题","uri":"/posts/nc24wd3/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" A-Tokitsukaze and Bracelet","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#a-tokitsukaze-and-bracelet"},{"categories":["在学算法的日子里"],"content":" 题意根据手环的三个属性值判断手环的等级。 对攻击百分比来说，+0为100%，+1为150%，+2为200% 对体力和精神来说，+0在${29,30,31,32}$里选择，+1在${34,36,38,40}$里选择，+2固定为45 数据范围$n(1≤n≤100)$ $a_i,b_i,c_i(a_i∈{100,150,200};b_i,ci∈{29,30,31,32,34,36,38,40,45})$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意"},{"categories":["在学算法的日子里"],"content":" 题意根据手环的三个属性值判断手环的等级。 对攻击百分比来说，+0为100%，+1为150%，+2为200% 对体力和精神来说，+0在${29,30,31,32}$里选择，+1在${34,36,38,40}$里选择，+2固定为45 数据范围$n(1≤n≤100)$ $a_i,b_i,c_i(a_i∈{100,150,200};b_i,ci∈{29,30,31,32,34,36,38,40,45})$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路模拟即可 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int lv1[3] = { 100,150,200 }; int lv2[9] = { 29,30,31,32,34,36,38,40,45 }; int a, b, c;cin \u003e\u003e a \u003e\u003e b \u003e\u003e c; int ans = 0; for (int i = 0;i \u003c 3;i++) { if (a == lv1[i]) { ans += i; break; } } for (int i = 0;i \u003c 9;i++) { if (b == lv2[i]) { if (i \u003c 4)ans += 0; else if (i \u003c 8)ans += 1; else ans += 2; break; } } for (int i = 0;i \u003c 9;i++) { if (c == lv2[i]) { if (i \u003c 4)ans += 0; else if (i \u003c 8)ans += 1; else ans += 2; break; } } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-Tokitsukaze and Cats","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#b-tokitsukaze-and-cats"},{"categories":["在学算法的日子里"],"content":" 题意关猫，每个猫被限制在一个单元格内就算被关住了，如图： 给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。 数据范围$n, m, k (1≤n,m≤300;1≤k≤n⋅m)$ $x_i, y_i (1≤xi≤n; 1≤yi≤m)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意关猫，每个猫被限制在一个单元格内就算被关住了，如图： 给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。 数据范围$n, m, k (1≤n,m≤300;1≤k≤n⋅m)$ $x_i, y_i (1≤xi≤n; 1≤yi≤m)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路遍历坐标点判断它上下左右是否有隔板，如果没有则补充。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n, m, k;cin \u003e\u003e n \u003e\u003e m \u003e\u003e k; map\u003cpair\u003cint, int\u003e, bool\u003ecats; int ans = 0; while (k--) { int x, y;cin \u003e\u003e x \u003e\u003e y; cats[{ x, y }] = true; pair\u003cint, int\u003epu = { x - 1,y }, pd = { x + 1,y }, pl = { x,y - 1 }, pr = { x,y + 1 }; int cnt = 4; if (cats.count(pu) != 0)cnt -= 1; if (cats.count(pd) != 0)cnt -= 1; if (cats.count(pl) != 0)cnt -= 1; if (cats.count(pr) != 0)cnt -= 1; ans += cnt; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" E\u0026F-Tokitsukaze and Eliminate","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#ef-tokitsukaze-and-eliminate"},{"categories":["在学算法的日子里"],"content":" 题意有一排n个宝石，第i个的颜色是$col_i$，可以进行如下的操作： 选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。 数据范围$T(1\\leq T\\leq 2 * 10^5)$ $n(1\\leq n\\leq 2 * 10^5)$ easy：$1\\leq col_i\\leq min(n,2)$ hard：$1\\leq col_i\\leq n$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有一排n个宝石，第i个的颜色是$col_i$，可以进行如下的操作： 选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。 数据范围$T(1\\leq T\\leq 2 * 10^5)$ $n(1\\leq n\\leq 2 * 10^5)$ easy：$1\\leq col_i\\leq min(n,2)$ hard：$1\\leq col_i\\leq n$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路贪心，从右边枚举，当找到最后一种达到两次出现的颜色后，进行一次对该颜色的操作，直到所有宝石都被消除。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cint\u003ecol(n + 1); set\u003cint\u003ecls; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e col[i]; cls.insert(col[i]); } int tn = cls.size(); // 颜色种数 map\u003cint, int\u003eclrs; map\u003cint, int\u003ecolors; int ans = 0; int cnt = 0; int pi = n; while (tn != 0) { for (int i = n;i \u003e 0;i--) { colors[col[i]]++; if (colors[col[i]] == 1) { cnt++; // 达到两次及以上的颜色数 if (cnt == tn) { ans++; cnt = 0; colors = clrs; pi = i - 1; } } } tn = colors.size(); colors = clrs; n = pi;cnt = 0; } cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" I-Tokitsukaze and Short Path (plus)","date":"2024-02-09","objectID":"/posts/nc24wd2/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#i-tokitsukaze-and-short-path-plus"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|+|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|+|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路$$ |a_i+a_j|+|a_i-a_j|= \\begin{cases} \u0026a_i+a_j+a_i-a_j\u0026=2\\times a_i\u0026\\quad a_i\\ge a_j \\\\ \u0026a_i+a_j+a_j-a_i\u0026=2\\times a_j\u0026\\quad a_i\\lt a_j \\end{cases} $$ 对$a$进行排序，计算每个数对总和的贡献，也就是比某数小的数的个数。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; } sort(a.begin(), a.end()); ll ans = 0; for (int i = 0;i \u003c n;i++) { ans += a[i] * i; } cout \u003c\u003c 4 * ans \u003c\u003c '\\n'; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" J-Tokitsukaze and Short Path (minus)","date":"2024-02-09","objectID":"/posts/nc24wd2/:5:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#j-tokitsukaze-and-short-path-minus"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|-|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}= \\begin{cases} 0\u0026 \\text{u=v}\\\\ |a_u+a_v|-|a_u-a_v|\u0026 \\text{u ≠ v} \\end{cases} $$ $dist(i,j)$定义为以$i$为起点到$j$的最短路。 求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$ 数据范围$T(1\\leq T\\leq 2\\times 10^5)$ $n(1\\leq n\\leq 2\\times 10^5)$ $a_i(1\\leq a_i\\leq 2\\times 10^5)$ ","date":"2024-02-09","objectID":"/posts/nc24wd2/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路$$ |a_i+a_j|-|a_i-a_j|= \\begin{cases} \u0026a_i+a_j-a_i+a_j\u0026=2\\times a_j\u0026\\quad a_i\\ge a_j \\\\ \u0026a_i+a_j-a_j+a_i\u0026=2\\times a_i\u0026\\quad a_i\\lt a_j \\end{cases} $$ 如果$u$到$v$的直接路径的长度大于$dist(u,w)+dist(v,w)$，则取后者，假设$dist(u,v)=2\\times a_v$，则有$dist(u,w)+dist(v,w)=2\\times a_v+2\\times a_v=4\\times a_v$，则只有当$2\\times a_w$的值小于$a_v$时取后者找到数组中的最小值。 对$a$​进行排序，计算每个数对总和的贡献次数，也就是比某数或2×最小$a_i$大的数的个数。 ","date":"2024-02-09","objectID":"/posts/nc24wd2/:5:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; vector\u003cll\u003ea(n); ll mn = 1e18; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; mn = min(mn, a[i]); } sort(a.begin(), a.end()); ll ans = 0; for (int i = 0;i \u003c n;i++) { ans += min(mn * 2, a[i]) * (n - i - 1); } cout \u003c\u003c 4 * ans \u003c\u003c '\\n'; } ","date":"2024-02-09","objectID":"/posts/nc24wd2/:5:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营2||补题","uri":"/posts/nc24wd2/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" A-DFS搜索","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#a-dfs搜索"},{"categories":["在学算法的日子里"],"content":" 题意给一个字符串，判断其中是否包含dfs子序列和DFS子序列。 数据范围$T(1≤T≤100)$ $n(1≤n≤50)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意"},{"categories":["在学算法的日子里"],"content":" 题意给一个字符串，判断其中是否包含dfs子序列和DFS子序列。 数据范围$T(1≤T≤100)$ $n(1≤n≤50)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围"},{"categories":["在学算法的日子里"],"content":" 思路直接搜。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; string s;cin \u003e\u003e s; int f1 = 1, f2 = 1; int p = s.find('D'); if (p != -1) { p = s.find('F', p); if (p != -1) { p = s.find('S', p); if (p == -1) { f1 = 0; } } else { f1 = 0; } } else { f1 = 0; } p = s.find('d'); if (p != -1) { p = s.find('f', p); if (p != -1) { p = s.find('s', p); if (p == -1) { f2 = 0; } } else { f2 = 0; } } else { f2 = 0; } cout \u003c\u003c f1 \u003c\u003c \" \" \u003c\u003c f2 \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:1:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码"},{"categories":["在学算法的日子里"],"content":" B-关鸡","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#b-关鸡"},{"categories":["在学算法的日子里"],"content":" 题意 从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。 数据范围$T(1≤T≤1e4)$ $0≤n≤1e5$ $r,c(1≤r≤2,−1e9≤c≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-1"},{"categories":["在学算法的日子里"],"content":" 题意 从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。 数据范围$T(1≤T≤1e4)$ $0≤n≤1e5$ $r,c(1≤r≤2,−1e9≤c≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-1"},{"categories":["在学算法的日子里"],"content":" 思路分别堵住两端的管道即可，堵住有三种情况： x 1 2 3 1 2 3 或者 x ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; map\u003cpair\u003cll, ll\u003e, bool\u003efires; // 记录是否有某个点 int fl = 2, fr = 2, fn = 0; // 空白，左2右2 for (int i = 0;i \u003c n;i++) { ll r, c;cin \u003e\u003e r \u003e\u003e c; fires[{c, r}] = true; if ((c == -1 \u0026\u0026 r == 1) || (c == 0 \u0026\u0026 r == 2) || (c == 1 \u0026\u0026 r == 1))fn++; // 环绕 if (c \u003c= 0)fl = 1; if (c \u003e= 0)fr = 1; } for (auto i = fires.begin(); i != fires.end();i++) { auto pr = i-\u003efirst;bool hs = i-\u003esecond; ll c = pr.first, r = pr.second; for (int j = -1;j \u003c 2;j++) { if (fires.find({ c + j, (3 - r) }) != fires.end()) { if (c \u003c 0) { fl = 0; } // 左边不用再加 if (c \u003e 0) { fr = 0; } // 右边不用再加 } } } int ans = 3 - fn; cout \u003c\u003c min(ans, fl + fr) \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:2:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C-按闹分配","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#c-按闹分配"},{"categories":["在学算法的日子里"],"content":" 题意有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度$S_{min}=\\sum_{i=1}^{n}D_i$最小，记为$S_{min}$。 然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度$S_{c}$与$S_{min}$的差值，则会允许急急鸡插队。 有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。 数据范围$n,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)$ $t_i(1≤t_i≤1e6)$ $M(0≤M≤1e18)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-2"},{"categories":["在学算法的日子里"],"content":" 题意有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度$S_{min}=\\sum_{i=1}^{n}D_i$最小，记为$S_{min}$。 然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度$S_{c}$与$S_{min}$的差值，则会允许急急鸡插队。 有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。 数据范围$n,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)$ $t_i(1≤t_i≤1e6)$ $M(0≤M≤1e18)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-2"},{"categories":["在学算法的日子里"],"content":" 思路初始从小到大排，求每个客户的不满意度Di（做前缀和） ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, q, tc;cin \u003e\u003e n \u003e\u003e q \u003e\u003e tc; vector\u003cll\u003et(n+1); for (int i = 0;i \u003c n;i++) { cin \u003e\u003e t[i]; } t[n] = 0; sort(t.begin(), t.end()); ll tn = 0ll; vector\u003cll\u003ed(n+1); for (int i = 0;i \u003c= n;i++) { d[i] = tn + t[i]; // 第i个人的不满意度 tn += t[i]; // 时间线 } while (q--) { ll m;cin \u003e\u003e m; ll l = 0, r = n; while (l \u003c r) { ll x = (l + r) \u003e\u003e 1; // 插在x号客户前面 if ((n - x) * tc \u003c= m) { // 可以 r = x; } else { l = x + 1; } } // 最早：插在l的前面 cout \u003c\u003c d[l] + tc \u003c\u003c endl; } } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:3:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D-本题又主要考察了贪心","date":"2024-02-02","objectID":"/posts/nc24wd1/:4:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#d-本题又主要考察了贪心"},{"categories":["在学算法的日子里"],"content":" 题意大骗子！ n个人的比赛，还剩m局，每局的结果有： 胜方加3分，败方不得分 平局各加一分 求一号选手最好的名次（并列的取并列的排名） 数据范围$T(1≤T≤100)$ $n,m(2≤n≤10,1\\leq m\\leq 10)$ $0\\leq a_i\\leq 100$ $u_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-3"},{"categories":["在学算法的日子里"],"content":" 题意大骗子！ n个人的比赛，还剩m局，每局的结果有： 胜方加3分，败方不得分 平局各加一分 求一号选手最好的名次（并列的取并列的排名） 数据范围$T(1≤T≤100)$ $n,m(2≤n≤10,1\\leq m\\leq 10)$ $0\\leq a_i\\leq 100$ $u_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:4:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-3"},{"categories":["在学算法的日子里"],"content":" 思路不会贪，数据范围小可以直接dfs暴力每种情况取最优，$O(3^m)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:4:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 int dfs(vector\u003cint\u003ea, vector\u003cpair\u003cint, int\u003e\u003etb, int now) { if (now == tb.size()) { // 最后一局 int rk = 1; for (int i = 1;i \u003c a.size();i++) { if (a[i] \u003e a[1])rk++; } return rk; } int ret = a.size() - 1; int u = tb[now].first, v = tb[now].second; // u赢 a[u] += 3; ret = min(ret, dfs(a, tb, now + 1)); a[u] -= 3; // v赢 a[v] += 3; ret = min(ret, dfs(a, tb, now + 1)); a[v] -= 3; // 平局 a[v] += 1;a[u] += 1; ret = min(ret, dfs(a, tb, now + 1)); a[v] -= 1;a[u] -= 1; return ret; } void solve() { int n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cint\u003ea(n + 1); for (int i = 1;i \u003c= n;i++)cin \u003e\u003e a[i]; vector\u003cpair\u003cint, int\u003e\u003etb; for (int i = 0;i \u003c m;i++) { int u, v;cin \u003e\u003e u \u003e\u003e v; tb.push_back({ u,v }); } int ans = dfs(a, tb, 0); cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:4:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" F-鸡数题","date":"2024-02-02","objectID":"/posts/nc24wd1/:5:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#f-鸡数题"},{"categories":["在学算法的日子里"],"content":" 题意求有多少个长为m的数组a同时满足以下条件： 对任意i，都有$a_i\u003e0$ 数组a严格递增 $a_1|a_2|…|a_{m-1}|a_m=2^n-1$（其中|为按位或操作） 对任意$i≠j$有$a_i\u0026a_j=0$（其中\u0026为按位与操作） 答案要对$10^9+7$取模 数据范围$1\\leq n,m\\leq 10^5$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-4"},{"categories":["在学算法的日子里"],"content":" 题意求有多少个长为m的数组a同时满足以下条件： 对任意i，都有$a_i\u003e0$ 数组a严格递增 $a_1|a_2|…|a_{m-1}|a_m=2^n-1$（其中|为按位或操作） 对任意$i≠j$有$a_i\u0026a_j=0$（其中\u0026为按位与操作） 答案要对$10^9+7$取模 数据范围$1\\leq n,m\\leq 10^5$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:5:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-4"},{"categories":["在学算法的日子里"],"content":" 思路条件3说明，在2进制下的$2^n-1$（也就是数$(\\overbrace{11\\dots111}^n)_2$）每一位1都至少在$a_1~a_m$中出现一次，数组a的大小为m，联合条件4说明每个数位上的1最多只能出现1次，所以问题转化为，将n个不同位置上1分配给m个数，且每个数至少有1个1。可知$n\\geq m$。 也就是一个第二类斯特林数$n\\brace m$。 递推式： $$ {n\\brace k}={n-1\\brace k-1}+k{n-1\\brace k} $$ 边界是：${n\\brace m}=[n=0]$。 通项： $$ {n\\brace m}=\\sum_{i=0}^m \\frac{(-1)^{m-i}\\times i^n}{i!\\times (m-i)!} $$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:5:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; if (n \u003c m) { cout \u003c\u003c \"0\\n\"; return; } // 阶乘 vector\u003cll\u003efac; fac.push_back(1);fac.push_back(1); for (ll i = 2;i \u003c= n;i++) { ll faci = (fac.back() * i) % mod; fac.push_back(faci); } vector\u003cll\u003efinv(n + 1); // 阶乘的逆元 finv[n] = powerMod(fac[n], mod - 2, mod); for (int i = n - 1;i \u003e= 0;i--) { finv[i] = finv[i + 1] * (i + 1) % mod; } ll ans = 0ll; for (ll i = 0;i \u003c= m;i++) { ll ansi = 1ll; if ((m - i) \u0026 1)ansi = -1; ansi *= powerMod(i, n, mod); ansi *= finv[i] * finv[m - i] % mod; ans = (ans + ansi) % mod + mod; // 加一个mod取正数 ans %= mod; } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:5:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" G-why买外卖","date":"2024-02-02","objectID":"/posts/nc24wd1/:6:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#g-why买外卖"},{"categories":["在学算法的日子里"],"content":" 题意一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。 数据范围$T(1≤T≤1e4)$ $n,m(1≤n≤1e5,1≤m≤1e9)$ $a_i,b_i(1≤a_i,b_i≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-5"},{"categories":["在学算法的日子里"],"content":" 题意一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。 数据范围$T(1≤T≤1e4)$ $n,m(1≤n≤1e5,1≤m≤1e9)$ $a_i,b_i(1≤a_i,b_i≤1e9)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:6:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-5"},{"categories":["在学算法的日子里"],"content":" 思路前缀和，按照ai升序排列，能用ai的券的食物一定也能使用原价小于等于ai的所有的券，最后枚举原价即可。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:6:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; map\u003cll, ll\u003ediscnt; for (int i = 0;i \u003c n;i++) { ll a, b;cin \u003e\u003e a \u003e\u003e b; discnt[a] += b; // 一次前缀和，合并相同ai的券 } for (auto i = discnt.begin(); i != discnt.end();i++) { ll price = i-\u003efirst, discount = i-\u003esecond; auto j = i;j++; if (j != discnt.end()) { (j-\u003esecond) += discount; // 第二次前缀和，合并小于等于ai的券 } } ll x = m; for (auto i = discnt.begin();i != discnt.end();i++) { ll price = i-\u003efirst, discount = i-\u003esecond; if (m + discount \u003e= price)x = m + discount; // 枚举，取最大原价 } cout \u003c\u003c x \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:6:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" I-It’s bertrand paradox. Again!","date":"2024-02-02","objectID":"/posts/nc24wd1/:7:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#i-its-bertrand-paradox-again"},{"categories":["在学算法的日子里"],"content":" 题意有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。 bit-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$。 随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤2重新生成$r$，若满足，则将该圆加入到结果中。 buaa-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$，随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤1重新生成$x,y,r$，若满足，则将该圆加入到结果中。 数据范围$n=10^5$ $0\u003c x_i,y_i\u003c 100,0\u003c r_i\\leq100$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:7:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-6"},{"categories":["在学算法的日子里"],"content":" 题意有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。 bit-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$。 随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤2重新生成$r$，若满足，则将该圆加入到结果中。 buaa-noob的方法： 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$，随机等概率地从闭区间$[1,100]$中生成一个$r$。 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤1重新生成$x,y,r$，若满足，则将该圆加入到结果中。 数据范围$n=10^5$ $0\u003c x_i,y_i\u003c 100,0\u003c r_i\\leq100$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:7:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-6"},{"categories":["在学算法的日子里"],"content":" 思路两种方法中，第一种的x和y的取值更容易受到r的限制，在r均匀分布在$[1,100]$的情况下，bit-noob的方法相对于buaa-noob的方法，x,y会更偏向集中在原点附近。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:7:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { int n;cin \u003e\u003e n; int cnt = 0; for (int i = 0;i \u003c n;i++) { int x, y, r;cin \u003e\u003e x \u003e\u003e y \u003e\u003e r; if (abs(x) \u003c= 50 \u0026\u0026 abs(y) \u003c= 50)cnt++; } if (cnt \u003c n - cnt)cout \u003c\u003c \"bit-noob\\n\"; else cout \u003c\u003c \"buaa-noob\\n\"; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:7:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" H-01背包，但是bit","date":"2024-02-02","objectID":"/posts/nc24wd1/:8:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#h-01背包但是bit"},{"categories":["在学算法的日子里"],"content":" 题意$n$个物品，每个物品有价值$v_i$和重量$w_i$，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过$m$的最大价值和 数据范围$T(1≤T≤10^4)$ $n,m(1≤n≤10^5,0\\leq m\\leq 10^8)$ $v_i,w_i(0\\leq v_i,w_i\\leq 10^8)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:8:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-7"},{"categories":["在学算法的日子里"],"content":" 题意$n$个物品，每个物品有价值$v_i$和重量$w_i$，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过$m$的最大价值和 数据范围$T(1≤T≤10^4)$ $n,m(1≤n≤10^5,0\\leq m\\leq 10^8)$ $v_i,w_i(0\\leq v_i,w_i\\leq 10^8)$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:8:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-7"},{"categories":["在学算法的日子里"],"content":" 思路枚举m右移位后的数字，能被这个位数低于m、数位上全是1的新m覆盖的都能拿 状态转换：拿新筛出来的可选与原来的比较，取价值较大的那个 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:8:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n, m;cin \u003e\u003e n \u003e\u003e m; vector\u003cll\u003ev(n), w(n); ll ans = 0; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e v[i] \u003e\u003e w[i]; if ((w[i] | m) == m)ans += v[i]; } for (ll i = m;i \u003e 0;i -= i \u0026 -i) { // i每次抹去最后一位1，再重新取全1 ll xi = i - 1; ll ansi = 0; for (int j = 0;j \u003c n;j++) { if ((w[j] | xi) == xi) ansi += v[j]; } ans = max(ans, ansi); } cout \u003c\u003c ans \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:8:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" L-要有光","date":"2024-02-02","objectID":"/posts/nc24wd1/:9:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#l-要有光"},{"categories":["在学算法的日子里"],"content":" 题意 如图，有一点光源在轨迹L($x=c,y=0,0\\leq z\\leq d$)上移动，存在一宽为$2w$，高为$h$的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。 数据范围$1\\leq T\\leq 10^4$ $1\\leq c,d,h,w\\leq 10^4$ 输出浮点数误差小于$10^{-4}$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:9:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-8"},{"categories":["在学算法的日子里"],"content":" 题意 如图，有一点光源在轨迹L($x=c,y=0,0\\leq z\\leq d$)上移动，存在一宽为$2w$，高为$h$的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。 数据范围$1\\leq T\\leq 10^4$ $1\\leq c,d,h,w\\leq 10^4$ 输出浮点数误差小于$10^{-4}$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:9:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-8"},{"categories":["在学算法的日子里"],"content":" 思路当点光源放在地面上时投影最大(z=0时)，这个投影是一个等腰梯形（大三角形截去一个小三角形）。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:9:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { double c, d, h, w;cin \u003e\u003e c \u003e\u003e d \u003e\u003e h \u003e\u003e w; double ans = 3.0 * c * w; cout \u003c\u003c ans \u003c\u003c endl; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:9:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" M-牛客老粉才知道的秘密","date":"2024-02-02","objectID":"/posts/nc24wd1/:10:0","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#m-牛客老粉才知道的秘密"},{"categories":["在学算法的日子里"],"content":" 题意 就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。 数据范围$1\\leq T\\leq 10^5$ $6\\leq n\\leq 10^9$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:10:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#题意-9"},{"categories":["在学算法的日子里"],"content":" 题意 就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。 数据范围$1\\leq T\\leq 10^5$ $6\\leq n\\leq 10^9$ ","date":"2024-02-02","objectID":"/posts/nc24wd1/:10:1","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#数据范围-9"},{"categories":["在学算法的日子里"],"content":" 思路判断n是否是6的倍数即可，如果正好是6的倍数，那么返回时并不产生新的位置。 ","date":"2024-02-02","objectID":"/posts/nc24wd1/:10:2","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#思路-9"},{"categories":["在学算法的日子里"],"content":" 参考代码 void solve() { ll n;cin \u003e\u003e n; if (n % 6)cout \u003c\u003c n / 6 + n / 6 \u003c\u003c '\\n'; else cout \u003c\u003c n / 6 \u003c\u003c '\\n'; } ","date":"2024-02-02","objectID":"/posts/nc24wd1/:10:3","series":["题解记录"],"tags":["2024寒假训练","算法","牛客"],"title":"2024牛客寒假营1||补题","uri":"/posts/nc24wd1/#参考代码-9"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#线段树segment-tree"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#模板线段树"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#线段树的建立"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#如何更新数据"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#懒标记延迟标记"},{"categories":["在学算法的日子里"],"content":" 线段树(segment tree)线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。 还是一样，为了方便测试，我们引入一个例题中的数据来演示。 【模板】线段树题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)) ==题目描述== 如题，已知一个数列，你需要进行下面两种操作： 将某区间每一个数加上 $k$。 求出某区间每一个数的和。 ==输入格式== 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下： 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。 2 x y：输出区间 $[x, y]$ 内每个数的和。 ==输出格式== 输出包含若干行整数，即为所有操作 2 的结果。 ==样例 #1== 样例输入 #1 5 5 1 5 4 2 3 2 2 4 1 2 3 2 2 3 4 1 1 5 1 2 1 4 样例输出 #1 11 8 20 ==提示== 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。 【样例解释】 线段树的建立线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。 我们如此设置节点（简单概念）： 每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。 草履虫都会的递归建图： // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else { ll mid = (l + r) / 2; // 先创造左节点p*2 buildtree(l, mid, p * 2); // 再创造右节点p*2+1 buildtree(mid + 1, r, p * 2 + 1); // 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值 tree[p] = tree[p * 2] + tree[p * 2 + 1]; } } 如何更新数据？朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入==懒标记法==进行线段树的区间修改。 懒标记（延迟标记）这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。 相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。 还是看代码来理解吧： void update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) { // 从目标的区间(要更新的范围)[l, r]开始 // 当前操作的区间是[curl, curr](对应curpos) // 要做的操作是加一个数addnum(显然同理也可以是其他操作) if (curl \u003e r || curr \u003c l) // 当前要操作的区间和大区间没有交集，剪枝 return; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) { // 当前区间完全包含在大区间里 tree[curpos] += (curr - curl + 1) * addnum; if (curl != curr) // 不是叶子节点，则标记它 mark[curpos] += addnum; // 这里就很懒标记了qwq } else { // 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update // 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化 // 将标记点向下传递 mark[curpos * 2] += mark[curpos]; mark[curpos * 2 + 1] += mark[curpos]; // 接下来往下更新一层 ll mid = (curl + curr) / 2; tree[curpos * 2] += mark[curpos] * (mid - curl + 1); tree[curpos * 2 + 1] += mark[curpos] * (curr - mid); // 清除当前的区间点的标记（因为已经下达了） mark[curpos] = 0; // 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似 // 将懒标记递归下去 update(l, r, curl, mid, addnum, curpos * 2); // 左 update(l, r, mid + 1, curr, addnum, curpos * 2 + 1); // 右 // 传递结束之后更新当前节点的值(变化到这) tree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1]; } } 整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。 那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。 // 将mark[]里要落实到底的指令落实下去 void impleMarks(ll pos, ll len) { // 实现目标：把mark[pos]里的指令向下传递一层 // 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可 mark[pos * 2] += mark[pos]; // 左 mark[pos * 2 + 1] += mark[pos]; // 右 tree[pos * 2] += mark[pos] * (len - len / 2); tree[pos * 2 + 1] += mark[pos] * (len / 2); // 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大 mark[pos] = 0; } 接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。 查询区间上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改 简单的写一个模板函数： // 查询区间里的数据（也就是查询节点里的数据） ll ask(ll l, ll r, ll pos, ll curl, ll curr) { // 目标区间和已经在查的区间，以及对应在线段树里的坐标 if (curl \u003e r || curr \u003c l) // 现在在查的不在大区间里 return 0; else if (curl \u003e= l \u0026\u0026 curr \u003c= r) // 当前查的区间就在待查区间里，返回值 return tree[pos]; else { // 进行二分 ll mid = (curl + curr) / 2; // 把当前节点的更新信息往下传递一层 impleMarks(pos, curr - curl + 1); // 返回左右查询信息的和 return ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr); } } 最后给上例题的参考代码： #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50, maxm = 1e5 + 50; ll a[maxn]; ll tree[maxn * 4]; // 一般线段树的大小开到原数组范围的4倍应该差不多了 // 简单的建树过程 void buildtree(ll l, ll r, ll p) { if (l == r) // 二分到终点了，给线段树的叶子节点赋值为a[l] tree[p] = a[l]; else ","date":"2024-01-06","objectID":"/posts/seg_tree/:0:1","series":["算法模板笔记"],"tags":["算法","线段树","数据结构","算法模板"],"title":"线段树模板","uri":"/posts/seg_tree/#查询区间"},{"categories":["在学算法的日子里"],"content":" 1.1图的定义上课讲过一大堆这里不再赘述，直接学习代码实现。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:1","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#11图的定义"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w\u003cb.w; if(a.from==b.from) return a.to\u003cb.to; return a.from\u003cb.from; } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct NODE { int from, to, w; }edge[maxm]; int head[maxn]; bool cmp(NODE a, NODE b) { if (a.from == b.from \u0026\u0026 a.to == b.to) return a.w \u003c b.w; if (a.from == b.from) return a.to \u003c b.to; return a.from \u003c b.from; } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 读入数据 for (int i = 0;i \u003c m;i++) cin \u003e\u003e edge[i].from \u003e\u003e edge[i].to \u003e\u003e edge[i].w; // 排序 sort(edge, edge + m, cmp); // 初始化head memset(head, -1, sizeof(head)); // 制成点位数组 head[edge[0].from] = 0; // 初始化 // edge数组中起点为点i的在数组里的第一条边在下标head[i]处 for (int i = 1;i \u003c m;i++) if (edge[i].from != edge[i - 1].from) // 表明是新的起始点 head[edge[i].from] = i; // 遍历输出各边信息（按点位输出） for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c \"以点v\" \u003c\u003c i \u003c\u003c \"为起点的边：\" \u003c\u003c endl; for (int j = head[i];j \u003c m \u0026\u0026 edge[j].from == i;j++) { cout \u003c\u003c \"v\" \u003c\u003c edge[j].from \u003c\u003c \"--\u003ev\" \u003c\u003c edge[j].to \u003c\u003c \" 权值为：\" \u003c\u003c edge[j].w \u003c\u003c \" 该边在数组edge中的序号为\" \u003c\u003c j \u003c\u003c endl; } cout \u003c\u003c endl; } return 0; } // Output： /* 以点v1为起点的边： v1--\u003ev2 权值为：4 该边在数组edge中的序号为0 v1--\u003ev6 权值为：9 该边在数组edge中的序号为1 以点v2为起点的边： 以点v3为起点的边： v3--\u003ev1 权值为：22 该边在数组edge中的序号为2 v3--\u003ev2 权值为：19 该边在数组edge中的序号为3 以点v4为起点的边： v4--\u003ev3 权值为：17 该边在数组edge中的序号为4 以点v5为起点的边： v5--\u003ev8 权值为：29 该边在数组edge中的序号为5 以点v6为起点的边： v6--\u003ev1 权值为：12 该边在数组edge中的序号为6 v6--\u003ev5 权值为：9 该边在数组edge中的序号为7 v6--\u003ev7 权值为：4 该边在数组edge中的序号为8 以点v7为起点的边： v7--\u003ev4 权值为：25 该边在数组edge中的序号为9 以点v8为起点的边： v8--\u003ev3 权值为：11 该边在数组edge中的序号为10 v8--\u003ev7 权值为：7 该边在数组edge中的序号为11 */ 邻接表图的一种链式存储结构，把图G中所有邻接于vi的顶点链接成为一个vi的单链表。 三种实现方法： 1. 动态建表动态建表的时间效率是O(m)，空间效率是O(m)，主要的时间损耗在于不断地申请新空间，且判断任意两个点之间是否有边相连的效率也低（需要搜索各个点的单链表）(感觉还好？)。 数据结构： struct EdgeNode { int to; // 终点 int w; // 权值 EdgeNode* next; // 下一边的指针 }; struct VNode { int from; // 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点） EdgeNode* first; // 邻接表的头指针 }; 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 EdgeNode* next; // 下一边的指针 }; struct VNode { int from; // 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点） EdgeNode* first; // 邻接表的头指针 }; VNode Adjlist[maxn]; // 全图 int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; // 创建一个新的边结构数据 EdgeNode* p = new EdgeNode(); // 给该数据传值 p-\u003eto = ti; p-\u003ew = wi; // 该新边的next指针指向上一个链接到起点为fi的单链表中的起点 /* （相当于在前面插入，这点可以观察遍历输出部分发现，比如先读入的v1--\u003ev2后读入的v1--\u003ev6，但在储存时我们将后来的v1--\u003ev6插入在了v1--\u003ev2前面） */ p-\u003enext = Adjlist[fi].first; // 将起点为fi的单链表的指针更新为这个新传入边的地址 Adjlist[fi].first = p; } // 遍历 for (int i = 1;i \u003c= n;i++) { cout \u003c\u003c \"点v\" \u003c\u003c i \u003c\u003c \"为起点的边：\" \u003c\u003c endl; int ind = 0; for (EdgeNode* k = Adjlist[i].first;k != NULL;k = k-\u003enext) { // 指针遍历该链表至结束 cout \u003c\u003c \"v\" \u003c\u003c i \u003c\u003c \" --\u003ev\" \u003c\u003c k-\u003eto \u003c\u003c \" 权值为：\" \u003c\u003c k-\u003ew \u003c\u003c \" 该边记录在点v\" \u003c\u003c i \u003c\u003c \"的单链表的第\" \u003c\u003c ind++ \u003c\u003c \"个\" \u003c\u003c endl; } cout \u003c\u003c \"点v\" \u003c\u003c i \u003c\u003c \"为的度数为：\" \u003c\u003c ind \u003c\u003c endl; cout \u003c\u003c endl; } return 0; } // Output: /* 点v1为起点的边： v1 --\u003ev6 权值为：9 该边记录在点v1的单链表的第0个 v1 --\u003ev2 权值为：4 该边记录在点v1的单链表的第1个 点v1为的度数为：2 点v2为起点的边： 点v2为的度数为：0 点v3为起点的边： v3 --\u003ev2 权值为：19 该边记录在点v3的单链表的第0个 v3 --\u003ev1 权值为：22 该边记录在点v3的单链表的第1个 点v3为的度数为：2 点v4为起","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#12图的存储"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#邻接矩阵"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#前向星"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#邻接表"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#1-动态建表"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#2-vector模拟链表实现"},{"categories":["在学算法的日子里"],"content":" 1.2图的存储例图展示： graph LR v1((v1))--4--\u003ev2((v2)) v1((v1))--9--\u003ev6((v6)) v3((v3))--19--\u003ev2((v2)) v3((v3))--22--\u003ev1((v1)) v4((v4))--17--\u003ev3((v3)) v5((v5))--29--\u003ev8((v8)) v6((v6))--12--\u003ev1((v1)) v6((v6))--9--\u003ev5((v5)) v6((v6))--4--\u003ev7((v7)) v7((v7))--25--\u003ev4((v4)) v8((v8))--7--\u003ev7((v7)) v8((v8))--11--\u003ev3((v3)) 设n个点，m条边 上图的数据（按照 起点-终点-权值）： 8 12 5 8 29 6 1 12 8 3 11 1 2 4 3 1 22 4 3 17 7 4 25 6 5 9 8 7 7 1 6 9 3 2 19 6 7 4 邻接矩阵 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2) 对于稀疏图来说大部分是INF，空间利用效率也不高 前向星前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n) 优点：在点特别多时可以存储重边 缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。 需要的数据结构如下： int head[maxn]; struct NODE{ int from; // 起点 int to; // 终点 int w; // 权值 }; NODE edge[maxm]; NODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。 排序方式： bool cmp(NODE a, NODE b){ if(a.from==b.from\u0026\u0026a.to==b.to) return a.w","date":"2024-01-06","objectID":"/posts/graph_basic/:0:2","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#3-静态建表链式前向星"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v0出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v0的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#13图的遍历"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v0出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v0的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#深度优先遍历"},{"categories":["在学算法的日子里"],"content":" 1.3图的遍历从v0出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。 深度优先遍历从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。 深度优先样例代码： // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void dfs(int x) { // 传入节点名x s[x] = true; // 标记被访问 cout \u003c\u003c x \u003c\u003c \" \"; // 输出被标记的点（观察顺序） for (int i = head[x];i != -1;i = Edge[i].next) { // 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问 if (!s[Edge[i].to]) // 如果当前边的终点未被访问，我们就去访问它 dfs(Edge[i].to); // 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } // 深度优先访问，从顶点1开始（没有点0啦） dfs(1); // Output: /* 1 6 7 4 3 2 5 8 */ // 可以结合图去观察这个顺序，便于理解深度优先搜索 return 0; } 注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。 广度优先遍历广度优先就是先访问顶点v0的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索） 广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。 广度优先样例代码： （啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ） // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } 完整代码： #include using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; // 用一个布尔型数组来标记是否被遍历到 bool s[maxn] = { 0 }; void bfs(int x) { int queue[maxn]; int iq = 0; // 遍历以x为顶点的起始状态时，队列是空的 queue[iq++] = x; // 给当前队列添加被访问的这个顶点x for (int i = 0;i \u003c iq;i++) { // 这个队列按序输出可以反应搜索顺序 cout \u003c\u003c queue[i] \u003c\u003c \" \"; // 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { // 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++ if (!s[Edge[k].to]) { s[Edge[k].to] = true; queue[iq++] = Edge[k].to; } } } } int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; } bfs(1); // Output: /* 1 6 2 7 5 1 4 8 3 */ // 结合图去观察该顺序，便于理解广度优先搜索 return 0; } 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。 ","date":"2024-01-06","objectID":"/posts/graph_basic/:0:3","series":["算法模板笔记"],"tags":["图论","算法","算法模板"],"title":"图论基础||存储图||DFS、BFS(图论)","uri":"/posts/graph_basic/#广度优先遍历"},{"categories":["在学算法的日子里"],"content":" 拓扑排序前提：拓扑排序是对有向无环图来说的，无向图、有环图都不存在拓扑排序。 拓扑排序是将图G中的所有顶点排成一个线性序列，使得对于任意一堆有边顶点\u003cu, v\u003e，在线性序列中，u都出现在v之前。 拓扑排序可以反应某种方案是否是切实可行的。 一般一个图是否是有向图我们分析题意要求就能知道，但是究竟有没有环存在，就不是瞄一眼就能发现的了，所以，虽然拓扑排序是针对有向无环图而言的一种性质，但是反过来，一个有向图是否有拓扑排序，也可以反过来解决该图是否存在环、以及存在多少环等等问题，也就是某种方案可不可行。 接下来我们通过代码学习如何获得一个有向图的拓扑排序： ","date":"2024-01-05","objectID":"/posts/topo/:1:0","series":["算法模板笔记"],"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#拓扑排序"},{"categories":["在学算法的日子里"],"content":" 算法思路拓扑排序一定是从入度为0的顶点开始的（假如入度不为0不就是有点要排在它的前面了嘛qwq），所以，我们通过删除点(及由该点出发的所有边)的方法可以不断更新制作拓扑排序时当前图的状态，这样的步骤不断执行，直到图中能删的点(入度为0的点)都删光了，我们的程序就执行到了终点。 ","date":"2024-01-05","objectID":"/posts/topo/:1:1","series":["算法模板笔记"],"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#算法思路"},{"categories":["在学算法的日子里"],"content":" 程序实现我们还是用链式前向星来存储图 使用队列来记录我们的拓扑序列（说是队列不过其实还是个每次只读末尾的数组啦，也没用到queue容器qwq） 寻找拓扑序列样例代码： // 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录 int queue[maxn]; int iq = 0; // 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法) // 先将图里入度为0的顶点加入队列 // 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq) for (int i = 1;i \u003c= n;i++) if (indegree[i] == 0) queue[iq++] = i; // 删点，对队列做更新 for (int i = 0;i \u003c iq;i++) { // 按队列顺序删点删边(终点的入度--就算删掉这条边了) for (int k = head[queue[i]];k != 0;k = Edge[k].next) { indegree[Edge[k].to]--; if (indegree[Edge[k].to] == 0) queue[iq++] = Edge[k].to; } } 这时候我们得到了一个序列，其实这个序列无论如何都能得到（空序列也是序列！），所以接下来需要判断一下是否是拓扑序列，同时也就判断出当前的图是不是有向无环图啦。 判断样例代码： cout \u003c\u003c \"iq=\" \u003c\u003c iq \u003c\u003c \" n=\" \u003c\u003c n \u003c\u003c endl; if (iq == n) { cout \u003c\u003c \"有拓扑序列：\" \u003c\u003c endl; // 输出拓扑排序序列 for (int i = 0;i \u003c iq;i++) cout \u003c\u003c queue[i] \u003c\u003c \" \"; cout \u003c\u003c endl; } else { cout \u003c\u003c \"没有拓扑序列\" \u003c\u003c endl; } 前面的输入样例是个有向有环图，这里添加一组有向无环图的样例用于学习： graph LR v1((v1))--5--\u003ev2((v2)) v1((v1))--6--\u003ev3((v3)) v2((v2))--9--\u003ev4((v4)) v3((v3))--10--\u003ev5((v5)) v3((v3))--4--\u003ev6((v6)) v4((v4))--12--\u003ev6((v6)) v5((v5))--6--\u003ev7((v7)) v6((v6))--9--\u003ev7((v7)) v7((v7))--24--\u003ev8((v8)) v6((v6))--3--\u003ev8((v8)) 8 10 1 2 5 1 3 6 2 4 9 3 5 10 3 6 4 4 6 12 5 7 6 6 7 9 6 8 3 7 8 24 完整代码： #include\u003cbits/stdc++.h\u003e using namespace std; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int indegree[maxn]; int main() { int n, m; cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 初始化为0应该也冇问题，反正只是方便我们判断终点啦，想用向量也行qwq // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].next = head[fi]; head[fi] = i; // 记录各个顶点的入度(当该点是终点的时候++qwq) indegree[ti]++; } // 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录 int queue[maxn]; int iq = 0; // 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法) // 先将图里入度为0的顶点加入队列 // 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq) for (int i = 1;i \u003c= n;i++) if (indegree[i] == 0) queue[iq++] = i; // 删点，对队列做更新 for (int i = 0;i \u003c iq;i++) { // 按队列顺序删点删边(终点的入度--就算删掉这条边了) for (int k = head[queue[i]];k != -1;k = Edge[k].next) { indegree[Edge[k].to]--; if (indegree[Edge[k].to] == 0) queue[iq++] = Edge[k].to; } } // 这里可以判断是否有环啦，假如此时iq的值小于顶点的数量n，不就是说明接下来没法删边了嘛，也就是说最后剩下了环。 cout \u003c\u003c \"iq=\" \u003c\u003c iq \u003c\u003c \" n=\" \u003c\u003c n \u003c\u003c endl; if (iq == n) { cout \u003c\u003c \"有拓扑序列：\" \u003c\u003c endl; // 输出拓扑排序序列 for (int i = 0;i \u003c iq;i++) cout \u003c\u003c queue[i] \u003c\u003c \" \"; cout \u003c\u003c endl; } else { cout \u003c\u003c \"没有拓扑序列\" \u003c\u003c endl; } return 0; } 该算法在O(m)的时间内对indegree数组进行初始化，在O(n)时间内对queue进行初始化，后面的部分虽然看起来是两层循环，但实际上是m条边各遍历一次，所以时间复杂度只有O(m)而已，所以一共也就O(m+n)的复杂度。还是很友好滴。 ","date":"2024-01-05","objectID":"/posts/topo/:1:2","series":["算法模板笔记"],"tags":["图论","拓扑排序"],"title":"拓扑排序","uri":"/posts/topo/#程序实现"},{"categories":["在学算法的日子里"],"content":" 字符串匹配算法","date":"2024-01-05","objectID":"/posts/string_match/:1:0","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#字符串匹配算法"},{"categories":["在学算法的日子里"],"content":" 暴力做法(BF)简称BF(Brute Force)算法。 没什么好说的，就是看到描述直接能想到的朴素做法。 vector\u003cint\u003e BF_match(string s, string p) { // s是主串，p是模式串 int n = s.size(), m = p.size(); vector\u003cint\u003e res; for (int i = 0; i \u003c= n - m; i++) { int j = 0; for (; j \u003c m; j++) { if (s[i + j] != p[j]) break; } if (j == m) res.push_back(i); } return res; } BF算法的时间复杂度不稳定。匹配成功时，最好为O(n)，最差为O(mn)；匹配失败时，最好为最好为O(n)，最差为O(mn)。平均时间复杂度为O(n)。 ","date":"2024-01-05","objectID":"/posts/string_match/:1:1","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#暴力做法bf"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector\u003cll\u003e prefix(string s) { vector\u003cll\u003epi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector\u003cll\u003e prefix(string s) { vector\u003cll\u003epi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector\u003cll\u003e prefix(string s) { int n = s.size(); vector\u003cll\u003epi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#前缀函数"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#定义"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#计算"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#考虑优化"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#复杂度"},{"categories":["在学算法的日子里"],"content":" 前缀函数 定义定义字符串$S$的前缀函数：$\\pi [i]$为其子串$s[0…i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。 计算朴素算法枚举子串的长度（其中$\\pi [0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)$​。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = i;j \u003e= 0;j--) { string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 考虑优化容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' = t[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。 其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。 加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。 vector prefix(string s) { vectorpi(s.size()); for (int i = 0;i \u003c s.size();i++) { for (int j = pi[i - 1] + 1;j \u003e= 0;j--) { // 注意j的最大值被限制在pi[i-1]+1 string t = s.substr(0, j); string tmp = s.substr(i - j + 1, j); if (t == tmp) { pi[i] = j; break; } } } return pi; } 复杂度考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[n-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=…=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$ 再次优化上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq s[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。 失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$​的状态进行继承。 当$s[j]\\neq s[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0…k-1]=s[i-k+1…i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性质： $$ s[0…k-1]=s[i-k+1…i]=s[\\pi[i]-k…\\pi[i]-1]=s[0…\\pi[i]-1] $$ $s[0…\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0…\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]-1]$。 利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } ","date":"2024-01-05","objectID":"/posts/string_match/:1:2","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#再次优化"},{"categories":["在学算法的日子里"],"content":" KMP算法观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。 前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出现，减去前面$s$和分隔符的长度即为在$t$中的位置）。 vector\u003cll\u003e prefix(string s) { int n = s.size(); vector\u003cll\u003epi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } vector\u003cint\u003ekmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vector\u003cll\u003ev; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } KMP模板题题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e7 + 50; ll pi[maxn]; void prefix(string s) { ll n = s.size() - 1; ll j = 0; for (ll i = 1;i \u003c= n;i++) { while (j \u003e 0 \u0026\u0026 s[j] != s[i])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } } vector\u003cll\u003ekmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vector\u003cll\u003ev; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vector\u003cll\u003ev = kmp(s1, s2); for (auto i : v) cout \u003c\u003c i + 1 \u003c\u003c \"\\n\"; prefix(s2); for (ll i = 0;i \u003c s2.size();i++) cout \u003c\u003c pi[i] \u003c\u003c \" \"; return 0; } 另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll n = t.size(); t = \" \" + t; ll j = 0; // 前一步匹配的长度 for (ll i = 2;i \u003c= n;i++) { while(j \u0026\u0026 t[j + 1] != t[i])j = pi[j]; if (t[j + 1] == t[i])j++; pi[i] = j; } ll m = s.size(); s = \" \" + s; ll ans[m + 5]; ll p = 0;j = 0; for (ll i = 1;i \u003c= m;i++) { while(j \u0026\u0026 s[i] != t[j + 1])j = pi[j]; if (s[i] == t[j + 1])j++; fi[i] = j; ans[++p] = i; if (j == n) { p -= n; j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度 } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } cout \u003c\u003c endl; } 自动机在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s + '#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + '#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。 ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } void cmp_auto(string s, vector\u003cvector\u003cll\u003e\u003e\u0026 aut) { s = s + \"#\"; prefix(s); ll n = s.size(); aut.assign(n, vector\u003cll\u003e(26)); s = \" \" + s; for (ll i = 1;i \u003c= n;i++) { for (ll c = 0;c \u003c 26;c++) { if (i \u003e 1 \u0026\u0026 'a' + c != s[i]) aut[i][c] = aut[pi[i - 1] + 1][c]; else aut[i][c] = i + ('a' + c == s[i]); } } } 数组aut[i][c]表示在前$i$个字符匹配上的情况下，第$i+1$的字符是c时要跳转的状态，这样的跳转是$O(1)$​的。 试手例题：Problem - 808G - Codeforces 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e6 + 50; const ll inf = 0x3f3f3f3f; ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } ll aut[maxn][26]; ll dp[2][maxn]; void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; t = t + \"#\"; ll n = t.size(); ll m = s.size(); prefix(t); // aut:前i-1位已经匹配,根据t[i]与c是否相同,更新接下来与c之后的长度 s = \" \" + s;t = \" \" + t; for (ll i = 1;i \u003c= n;i++) { for (ll c = 0;c \u003c 26;c++) { if (i \u003e 1 \u0026\u0026 'a' + c != t[i]) aut[i][c] = aut[pi[i - 1] + 1][c]; else aut[i][c] = i + ('a' + c == t[i]); } } // 在t+'#'的状态机上在s上继续转移 memset(dp, -inf, sizeof(dp)); dp[0][1] = 0; // 表示到s的i位,与t匹配长度为j的次数 for (ll i = 1;i \u003c= m;i++) { if (s[i] == '?') { for (ll j = 1;j \u003c= n;j++) { for (ll c = 0;c \u003c 26;c++) { dp[i \u0026 1ll][aut[j][c]] = max( dp[i \u0026 1ll][aut[j][c]], dp[(i + 1ll) \u0026 1][j] + (aut[j][c] == n) ); } } } else { for (ll j = 1;j \u003c= n;j++) { ll c = s[i] - 'a'; dp[i \u0026 1ll][aut[j][c]] = max( dp[i \u0026","date":"2024-01-05","objectID":"/posts/string_match/:1:3","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#kmp算法"},{"categories":["在学算法的日子里"],"content":" KMP算法观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。 前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出现，减去前面$s$和分隔符的长度即为在$t$中的位置）。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } KMP模板题题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 #include using namespace std; typedef long long ll; const int maxn = 1e7 + 50; ll pi[maxn]; void prefix(string s) { ll n = s.size() - 1; ll j = 0; for (ll i = 1;i \u003c= n;i++) { while (j \u003e 0 \u0026\u0026 s[j] != s[i])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vectorv = kmp(s1, s2); for (auto i : v) cout \u003c\u003c i + 1 \u003c\u003c \"\\n\"; prefix(s2); for (ll i = 0;i \u003c s2.size();i++) cout \u003c\u003c pi[i] \u003c\u003c \" \"; return 0; } 另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll n = t.size(); t = \" \" + t; ll j = 0; // 前一步匹配的长度 for (ll i = 2;i \u003c= n;i++) { while(j \u0026\u0026 t[j + 1] != t[i])j = pi[j]; if (t[j + 1] == t[i])j++; pi[i] = j; } ll m = s.size(); s = \" \" + s; ll ans[m + 5]; ll p = 0;j = 0; for (ll i = 1;i \u003c= m;i++) { while(j \u0026\u0026 s[i] != t[j + 1])j = pi[j]; if (s[i] == t[j + 1])j++; fi[i] = j; ans[++p] = i; if (j == n) { p -= n; j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度 } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } cout \u003c\u003c endl; } 自动机在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s + '#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + '#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。 ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } void cmp_auto(string s, vector","date":"2024-01-05","objectID":"/posts/string_match/:1:3","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#kmp模板题"},{"categories":["在学算法的日子里"],"content":" KMP算法观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。 前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出现，减去前面$s$和分隔符的长度即为在$t$中的位置）。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } KMP模板题题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 #include using namespace std; typedef long long ll; const int maxn = 1e7 + 50; ll pi[maxn]; void prefix(string s) { ll n = s.size() - 1; ll j = 0; for (ll i = 1;i \u003c= n;i++) { while (j \u003e 0 \u0026\u0026 s[j] != s[i])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vectorv = kmp(s1, s2); for (auto i : v) cout \u003c\u003c i + 1 \u003c\u003c \"\\n\"; prefix(s2); for (ll i = 0;i \u003c s2.size();i++) cout \u003c\u003c pi[i] \u003c\u003c \" \"; return 0; } 另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll n = t.size(); t = \" \" + t; ll j = 0; // 前一步匹配的长度 for (ll i = 2;i \u003c= n;i++) { while(j \u0026\u0026 t[j + 1] != t[i])j = pi[j]; if (t[j + 1] == t[i])j++; pi[i] = j; } ll m = s.size(); s = \" \" + s; ll ans[m + 5]; ll p = 0;j = 0; for (ll i = 1;i \u003c= m;i++) { while(j \u0026\u0026 s[i] != t[j + 1])j = pi[j]; if (s[i] == t[j + 1])j++; fi[i] = j; ans[++p] = i; if (j == n) { p -= n; j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度 } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } cout \u003c\u003c endl; } 自动机在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s + '#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + '#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。 ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } void cmp_auto(string s, vector","date":"2024-01-05","objectID":"/posts/string_match/:1:3","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#代码"},{"categories":["在学算法的日子里"],"content":" KMP算法观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。 前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出现，减去前面$s$和分隔符的长度即为在$t$中的位置）。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } KMP模板题题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 #include using namespace std; typedef long long ll; const int maxn = 1e7 + 50; ll pi[maxn]; void prefix(string s) { ll n = s.size() - 1; ll j = 0; for (ll i = 1;i \u003c= n;i++) { while (j \u003e 0 \u0026\u0026 s[j] != s[i])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vectorv = kmp(s1, s2); for (auto i : v) cout \u003c\u003c i + 1 \u003c\u003c \"\\n\"; prefix(s2); for (ll i = 0;i \u003c s2.size();i++) cout \u003c\u003c pi[i] \u003c\u003c \" \"; return 0; } 另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll n = t.size(); t = \" \" + t; ll j = 0; // 前一步匹配的长度 for (ll i = 2;i \u003c= n;i++) { while(j \u0026\u0026 t[j + 1] != t[i])j = pi[j]; if (t[j + 1] == t[i])j++; pi[i] = j; } ll m = s.size(); s = \" \" + s; ll ans[m + 5]; ll p = 0;j = 0; for (ll i = 1;i \u003c= m;i++) { while(j \u0026\u0026 s[i] != t[j + 1])j = pi[j]; if (s[i] == t[j + 1])j++; fi[i] = j; ans[++p] = i; if (j == n) { p -= n; j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度 } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } cout \u003c\u003c endl; } 自动机在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s + '#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + '#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。 ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } void cmp_auto(string s, vector","date":"2024-01-05","objectID":"/posts/string_match/:1:3","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#代码-1"},{"categories":["在学算法的日子里"],"content":" KMP算法观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。 前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出现，减去前面$s$和分隔符的长度即为在$t$中的位置）。 vector prefix(string s) { int n = s.size(); vectorpi(n); int j = 0; for (int i = 1;i \u003c n;i++) { while (j \u003e 0 \u0026\u0026 s[i] != s[j])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } return pi; } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } KMP模板题题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 #include using namespace std; typedef long long ll; const int maxn = 1e7 + 50; ll pi[maxn]; void prefix(string s) { ll n = s.size() - 1; ll j = 0; for (ll i = 1;i \u003c= n;i++) { while (j \u003e 0 \u0026\u0026 s[j] != s[i])j = pi[j - 1]; if (s[i] == s[j])j++; pi[i] = j; } } vectorkmp(string s, string t) { ll n = s.size(), m = t.size(); string cur = t + \"#\" + s; // 找s中t的位置 prefix(cur); vectorv; for (ll i = m + 1;i \u003c= n + m + 1;i++) { if (pi[i] == m) v.push_back(i - (m + 1) - (m - 1)); } return v; } int main() { string s1, s2; cin \u003e\u003e s1 \u003e\u003e s2; vectorv = kmp(s1, s2); for (auto i : v) cout \u003c\u003c i + 1 \u003c\u003c \"\\n\"; prefix(s2); for (ll i = 0;i \u003c s2.size();i++) cout \u003c\u003c pi[i] \u003c\u003c \" \"; return 0; } 另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 代码 void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll n = t.size(); t = \" \" + t; ll j = 0; // 前一步匹配的长度 for (ll i = 2;i \u003c= n;i++) { while(j \u0026\u0026 t[j + 1] != t[i])j = pi[j]; if (t[j + 1] == t[i])j++; pi[i] = j; } ll m = s.size(); s = \" \" + s; ll ans[m + 5]; ll p = 0;j = 0; for (ll i = 1;i \u003c= m;i++) { while(j \u0026\u0026 s[i] != t[j + 1])j = pi[j]; if (s[i] == t[j + 1])j++; fi[i] = j; ans[++p] = i; if (j == n) { p -= n; j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度 } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } cout \u003c\u003c endl; } 自动机在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s + '#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + '#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。 ll pi[maxn]; void prefix(string s) { ll n = s.size(); s = \" \" + s; ll j = 0; for (ll i = 2;i \u003c= n;i++) { while (j \u0026\u0026 s[j + 1] != s[i])j = pi[j]; if (s[i] == s[j + 1])j++; pi[i] = j; } } void cmp_auto(string s, vector","date":"2024-01-05","objectID":"/posts/string_match/:1:3","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#自动机"},{"categories":["在学算法的日子里"],"content":" 统计所有前缀次数统计待匹配串$s$的所有前缀在$t$中出现的次数。 考虑$\\pi[i]$的生成，依然是参照这里的推导思路，对于位置$i$的前缀函数值$\\pi[i]$，可知长度小于$\\pi[i]$的最长的以$s[i]$结尾的前缀长度是$\\pi[\\pi[i]-1]$，之后是$\\pi[\\pi[\\pi[i]-1]-1]$……，直到长度为$0$，因此$s[0…i]$的每个前缀在$t$中出现的次数可以统计这样的传递的次数。 vector\u003cint\u003ecnt(n + 1); // 长度为i的前缀出现次数是cnt[i] for (int i = 0;i \u003c n;i++)cnt[pi[i]]++; for (int i = n - 1;i \u003e 0;i--)cnt[pi[i - 1]] += cnt[i]; // 长度为i的前缀出现了cnt[i]次，则长度为pi[i-1]的前缀要加上cnt[i]次，因为pi[i]是在长度为pi[i-1]的前缀基础上+1而来的 for (int i = 0;i \u003c= n;i++)cnt[i]++; ","date":"2024-01-05","objectID":"/posts/string_match/:1:4","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#统计所有前缀次数"},{"categories":["在学算法的日子里"],"content":" 不同本质子串计数给长度为$n$的字符串$s$后添加一个新字符$c$，给原来的$s$的所有不同子串后加$c$后，会出现一些以这个字符$c$结尾的之前没出现过的子串，我们的目的是计数每次在末尾添加新字符之后的字符串的不同本质子串数目。 举例，原串$S$是aba，原来的子串集合是：$[S]=\\{a,b,ab,ba\\}$，添加字符x之后的新串是abax，由于添加x后没有再之前的子串集合里的任何两个子串$s_1,s_2$中出现$s_1+x=s_2$的情况，那么新出现的子串数目就是原集合$[S]$的元素数目。假如添加的字符是b，新串是abab，那么就会发现，在原子串集合添加含有新加的b出现的新增加的元素集合$[S’]=\\{b,ab,bab\\}$​​中$\\{b,ab\\}$与原有元素出现了重复。 思路考虑原串cbbcb添加了新字符后是cbbcbx，考虑x加入后cbx是否与cbb相同，我们可以将字符串cbbcbx翻转为xbcbbc，对翻转后的字符串计算前缀函数，记该字符串前缀函数的最大值是$\\pi_{max}$，假设$\\pi_{max}=3$，则该最大值对应的前缀是xbc，也就是说xbc=bbc，这是包含x的最长的匹配长度，显然，xbc的子串x、xb、xbc在bbc中对应b、bb、bbc，复原为没有翻转前，正好就是添加新字符之后的包含新字符的元素集合中，与未加新字符前的字符串的子串集合中重复的元素。于是在添加新字符之后，新出现的子串数目即为$(|s_{原}|+1)-\\pi_{max}$​。 ","date":"2024-01-05","objectID":"/posts/string_match/:1:5","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#不同本质子串计数"},{"categories":["在学算法的日子里"],"content":" 不同本质子串计数给长度为$n$的字符串$s$后添加一个新字符$c$，给原来的$s$的所有不同子串后加$c$后，会出现一些以这个字符$c$结尾的之前没出现过的子串，我们的目的是计数每次在末尾添加新字符之后的字符串的不同本质子串数目。 举例，原串$S$是aba，原来的子串集合是：$[S]=\\{a,b,ab,ba\\}$，添加字符x之后的新串是abax，由于添加x后没有再之前的子串集合里的任何两个子串$s_1,s_2$中出现$s_1+x=s_2$的情况，那么新出现的子串数目就是原集合$[S]$的元素数目。假如添加的字符是b，新串是abab，那么就会发现，在原子串集合添加含有新加的b出现的新增加的元素集合$[S’]=\\{b,ab,bab\\}$​​中$\\{b,ab\\}$与原有元素出现了重复。 思路考虑原串cbbcb添加了新字符后是cbbcbx，考虑x加入后cbx是否与cbb相同，我们可以将字符串cbbcbx翻转为xbcbbc，对翻转后的字符串计算前缀函数，记该字符串前缀函数的最大值是$\\pi_{max}$，假设$\\pi_{max}=3$，则该最大值对应的前缀是xbc，也就是说xbc=bbc，这是包含x的最长的匹配长度，显然，xbc的子串x、xb、xbc在bbc中对应b、bb、bbc，复原为没有翻转前，正好就是添加新字符之后的包含新字符的元素集合中，与未加新字符前的字符串的子串集合中重复的元素。于是在添加新字符之后，新出现的子串数目即为$(|s_{原}|+1)-\\pi_{max}$​。 ","date":"2024-01-05","objectID":"/posts/string_match/:1:5","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#思路"},{"categories":["在学算法的日子里"],"content":" 字符串压缩字符串压缩指的是找到最短的长度$k$使得所有$s[0…k-1]=s[k…2*k-1]=…=s[n-k…n-1]$成立（$n\\bmod k=0$​）。 举例字符串abcabc可以被压缩为abc、abababab可以被压缩为ab。显然，假设字符串$s$可以被压缩至长度$k$，则该字符串的前缀函数的最后一个值$\\pi[n]$一定是$n-k$，（注意前后缀是真子串），$\\pi[n]$与$n$相差的长度应当正好是一个最短压缩串的长度。因此，由$n-\\pi[n]$得到$k$，若$n\\bmod k=0$成立，则$k$即为压缩后的长度。 ","date":"2024-01-05","objectID":"/posts/string_match/:1:6","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#字符串压缩"},{"categories":["在学算法的日子里"],"content":" 字符串Hash字符串哈希的主要难点是构造哈希函数。 哈希的性质： Hash函数值不一样的时候，两个字符串一定不一样。 Hash函数值一样的时候，两个字符串大概率一样。 第二条主要是哈希碰撞引起的，可以尝试用双哈希降低哈希碰撞的概率。 构造哈希函数通常是多项式哈希，对于一个长度为$l$的字符串$s$，可以定义它的多项式哈希函数为这样： $$ f(s)=\\sum_{i=1}^ls[i]\\times b^{l-i}(\\bmod M) $$ 比如字符串$xyz$，它的哈希函数值就是$xb^2+yb+z$，就像一个$b$进制的数一样。当然也可以反过来，将哈希函数定义为： $$ f(s)=\\sum_{i=1}^l s[i]\\times b^{i-1}(\\bmod M) $$ 相应的，$xyz$的哈希函数值就是$x+yb+cb^2$​。实际使用的时候不要混淆。 哈希碰撞不想算了我要咕咕咕。 参考代码（及其朴素）： ll Hash(string s) { ll ret = 0; ll b = 1, n = s.size(); for (ll i = n - 1;i \u003e= 0;i--) { ret += b * (ll)s[i]; b *= bas1; ret %= mo; } return ret; } 考虑到更多时候需要配合字符串子串的哈希值，所以我们需要预处理出每个前缀的哈希值，这样就能快速求得子串的哈希值了。 for (ll i = 0;i \u003c ls;i++) { h[i + 1] = h[i] * bas1 + s[i] - 'a'; } // 获得子串s[p - len +1...p]的哈希值 f(s[p - len + 1...p]) = h[p] - h[p - len] * pow(bas1, len); 还是这个题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 利用哈希解决： 代码 ll h[maxn]; void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll ls = s.size(), lt = t.size(); ll hb = 0ll, b = 1ll; for (ll i = 0;i \u003c lt;i++) { hb = hb * bas1 + t[i] - 'a'; b *= bas1; } ll p = 0; ll ans[ls + 5]; for (ll i = 0;i \u003c ls;i++) { p++; h[p] = h[p - 1] * bas1 + s[i] - 'a'; ans[p] = i; if (p - lt \u003e= 0 \u0026\u0026 h[p] - h[p - lt] * b == hb) { p -= lt; } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } } ","date":"2024-01-05","objectID":"/posts/string_match/:1:7","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#字符串hash"},{"categories":["在学算法的日子里"],"content":" 字符串Hash字符串哈希的主要难点是构造哈希函数。 哈希的性质： Hash函数值不一样的时候，两个字符串一定不一样。 Hash函数值一样的时候，两个字符串大概率一样。 第二条主要是哈希碰撞引起的，可以尝试用双哈希降低哈希碰撞的概率。 构造哈希函数通常是多项式哈希，对于一个长度为$l$的字符串$s$，可以定义它的多项式哈希函数为这样： $$ f(s)=\\sum_{i=1}^ls[i]\\times b^{l-i}(\\bmod M) $$ 比如字符串$xyz$，它的哈希函数值就是$xb^2+yb+z$，就像一个$b$进制的数一样。当然也可以反过来，将哈希函数定义为： $$ f(s)=\\sum_{i=1}^l s[i]\\times b^{i-1}(\\bmod M) $$ 相应的，$xyz$的哈希函数值就是$x+yb+cb^2$​。实际使用的时候不要混淆。 哈希碰撞不想算了我要咕咕咕。 参考代码（及其朴素）： ll Hash(string s) { ll ret = 0; ll b = 1, n = s.size(); for (ll i = n - 1;i \u003e= 0;i--) { ret += b * (ll)s[i]; b *= bas1; ret %= mo; } return ret; } 考虑到更多时候需要配合字符串子串的哈希值，所以我们需要预处理出每个前缀的哈希值，这样就能快速求得子串的哈希值了。 for (ll i = 0;i \u003c ls;i++) { h[i + 1] = h[i] * bas1 + s[i] - 'a'; } // 获得子串s[p - len +1...p]的哈希值 f(s[p - len + 1...p]) = h[p] - h[p - len] * pow(bas1, len); 还是这个题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 利用哈希解决： 代码 ll h[maxn]; void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll ls = s.size(), lt = t.size(); ll hb = 0ll, b = 1ll; for (ll i = 0;i \u003c lt;i++) { hb = hb * bas1 + t[i] - 'a'; b *= bas1; } ll p = 0; ll ans[ls + 5]; for (ll i = 0;i \u003c ls;i++) { p++; h[p] = h[p - 1] * bas1 + s[i] - 'a'; ans[p] = i; if (p - lt \u003e= 0 \u0026\u0026 h[p] - h[p - lt] * b == hb) { p -= lt; } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } } ","date":"2024-01-05","objectID":"/posts/string_match/:1:7","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#构造哈希函数"},{"categories":["在学算法的日子里"],"content":" 字符串Hash字符串哈希的主要难点是构造哈希函数。 哈希的性质： Hash函数值不一样的时候，两个字符串一定不一样。 Hash函数值一样的时候，两个字符串大概率一样。 第二条主要是哈希碰撞引起的，可以尝试用双哈希降低哈希碰撞的概率。 构造哈希函数通常是多项式哈希，对于一个长度为$l$的字符串$s$，可以定义它的多项式哈希函数为这样： $$ f(s)=\\sum_{i=1}^ls[i]\\times b^{l-i}(\\bmod M) $$ 比如字符串$xyz$，它的哈希函数值就是$xb^2+yb+z$，就像一个$b$进制的数一样。当然也可以反过来，将哈希函数定义为： $$ f(s)=\\sum_{i=1}^l s[i]\\times b^{i-1}(\\bmod M) $$ 相应的，$xyz$的哈希函数值就是$x+yb+cb^2$​。实际使用的时候不要混淆。 哈希碰撞不想算了我要咕咕咕。 参考代码（及其朴素）： ll Hash(string s) { ll ret = 0; ll b = 1, n = s.size(); for (ll i = n - 1;i \u003e= 0;i--) { ret += b * (ll)s[i]; b *= bas1; ret %= mo; } return ret; } 考虑到更多时候需要配合字符串子串的哈希值，所以我们需要预处理出每个前缀的哈希值，这样就能快速求得子串的哈希值了。 for (ll i = 0;i \u003c ls;i++) { h[i + 1] = h[i] * bas1 + s[i] - 'a'; } // 获得子串s[p - len +1...p]的哈希值 f(s[p - len + 1...p]) = h[p] - h[p - len] * pow(bas1, len); 还是这个题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) 利用哈希解决： 代码 ll h[maxn]; void solve() { string s, t;cin \u003e\u003e s \u003e\u003e t; ll ls = s.size(), lt = t.size(); ll hb = 0ll, b = 1ll; for (ll i = 0;i \u003c lt;i++) { hb = hb * bas1 + t[i] - 'a'; b *= bas1; } ll p = 0; ll ans[ls + 5]; for (ll i = 0;i \u003c ls;i++) { p++; h[p] = h[p - 1] * bas1 + s[i] - 'a'; ans[p] = i; if (p - lt \u003e= 0 \u0026\u0026 h[p] - h[p - lt] * b == hb) { p -= lt; } } for (ll i = 1;i \u003c= p;i++) { cout \u003c\u003c s[ans[i]]; } } ","date":"2024-01-05","objectID":"/posts/string_match/:1:7","series":["算法模板笔记","字符串笔记"],"tags":["KMP","字符串","算法","哈希"],"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","uri":"/posts/string_match/#代码-2"},{"categories":["在学算法的日子里"],"content":" 思维先行我们要找某点到某点的最短路径(记为点u到点v)，这样的路径只能从两种路径中选择—— u和v之间有边连接时，存在边(u, v)，不存在的话可以视作这两点的距离无限大 u和v可以通过某些点中转相连，这个(最短的)中转路径 很明显，我们选最短路径肯定是在这两种路径当中选最短的来作为u和v的最短距离，而路径选择2又可以不断拆分，比如我们有u -\u003e P -\u003e v我们再去寻找这条路径的最短时，可以分为u -\u003e P最短+P -\u003e v最短，再去寻找中转点…而且每次取最小值最小的+最小的肯定得最小的（有一点贪心的感觉）。 那么思维布置到这，我们来看看这个寻找最短路径的几种算法： ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:1","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#思维先行"},{"categories":["在学算法的日子里"],"content":" Floyd算法\u0026Bellman-Ford算法 ==Floyd算法== 这个算法就是刚刚思维里的算法的朴素实现了，动态规划思维，不断去尝试增加节点来找最小值。伪代码如下： #define INF 0x3f3f3f3f dist[maxn][maxn]; // dist[u][v]记录从点u到点v的距离 // 初始化时dist[n][n]=0, 两点有边则记录为w\u003cu, v\u003e，其他的就是INF void Floyd(int n){ // 一共有n个点，我们遍历填充dist[][]数组来计算所有的距离 for(int p=1 ;p \u003c= n;p++){ // 点p是中转点 for(int u=1;u\u003c=n;u++){ for(int v=1;v\u003c=n;v++){ dist[u][v] = min(dist[u][v], dist[u][p]+dist[p][v]); } } } } 很明显，这个算法有O(n^3)的复杂度，并不好，而且开的dist[maxn][maxn]数组空间也大，和之前学习存储图时一样，如果图比较稀疏，浪费的空间也大。 如何优化呢？ 先看算法上，我们在选择中间点p的时候，我们很容易想到——并不是所有的点1~点n和u都有边，所以假如我们按边存储成为邻接表(前向星/链式前向星)，我们在搜索边的时候就能直接在已有的\u003cu, p\u003e边上进行选择。 TIP：Floyd算法可以获得所有点之间的最短距离，所以在需要处理多源最短路且数据规模比较小的时候会选择它。 我们更关心单源最短路问题，接下来我们的问题就假定为：找到以点v1为起点的最短路。 由于是确定起点的单源最短路，我们接下来记录距离的数组只用开一维就行。 初始化：dist[1]=0, dist[v]=distance[1][v], 其他的置INF。 在Bellman-Ford算法中，我们假设不存在负权环（有负权环我们就会发现每绕一次dist都在变小，而我们取min（dist[v],weight(p-\u003ev)+dist[v]）肯定会把路径上的这个负权环走超过n遍），那么从v1到任何点的路径上点的个数都不会大于总点数n，所以Bellman-Ford算法就直接暴力搜n次来找最短路,到这里我们先代码实现一下这样的思路： 给出一个图例like this： graph LR v1((v1))-.4.-\u003ev2((v2)) v1((v1))-.3.-\u003ev3((v3)) v1((v1))-.8.-\u003ev4((v4)) v2((v2))-.2.-\u003ev6((v6)) v7((v7))-.5.-\u003ev6((v6)) v7((v7))-.1.-\u003ev4((v4)) v3((v3))-.1.-\u003ev7((v7)) v4((v4))-.5.-\u003ev3((v3)) v4((v4))-.5.-\u003ev5((v5)) 样例： 7 9 1 2 4 1 3 3 1 4 8 2 6 2 3 7 1 4 3 5 4 5 5 7 6 5 7 4 1 参考代码like this： #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; void BellmanFord(int vn) { // 初始化dist[] fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; int turn = n - 1; while (turn--) // 下方的遍历重复n-1遍，保证可以更新全部的dist[] for (int ei = 0;ei \u003c m;ei++) dist[Edge[ei].to] = min(dist[Edge[ei].to], dist[Edge[ei].from] + Edge[ei].w); // 这里为了方便获得查看的边的起点，可以在储存边的起点的时候加一个from的信息(否则就要先去找起点是谁) } int main() { cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } BellmanFord(1); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; // -\u003e0 4 3 5 10 6 4 return 0; } IDEA：我们在这个算法中可以发现，我们选边的时候对于它终点于何处并不关心，相反，我们会关心它的起点的信息（我们要算的源起点到该边的起点的距离），所以直接在存边的时候添加起点(from)的记录会方便我们确定起点。 虽然上文提到我们不考虑负权环的存在，但是我们可以想象，如果存在负权环，该图进入Bellman-Ford算法之后会有神奇的数据产生，我们试试看： 给我们的测试数据添加一个负权边： 7 10 1 2 4 1 3 3 1 4 8 2 6 2 3 7 1 4 3 5 4 5 5 7 7 -9 7 6 5 7 4 1 graph LR v1((v1))-.4.-\u003ev2((v2)) v1((v1))-.3.-\u003ev3((v3)) v1((v1))-.8.-\u003ev4((v4)) v2((v2))-.2.-\u003ev6((v6)) v7((v7))-.5.-\u003ev6((v6)) v7((v7))-.1.-\u003ev4((v4)) v3((v3))-.1.-\u003ev7((v7)) v4((v4))-.5.-\u003ev3((v3)) v4((v4))-.5.-\u003ev5((v5)) v7((v7))-. -9 .-\u003ev7((v7)) 同样的程序跑出来的结果是： 0 4 -35 -49 -35 -45 -50 原来的结果： 0 4 3 5 10 6 4 思考：不管有没有负权环，我们得到的其实都是合理的最短路径，但是存在负权环会使得到某些点的最短距离一定会减少（加上一个负数肯定变小，而我们选择的是较小的那个路径），所以有负权环时，最短路径(假设路径上的点的数量没有限制)其实可以无限短，我们先前用暴力循环所有的点来保证所有的dist数组能够更新到最佳，那么假如有负权环在其中，dist数组没有最佳状态，所以我们简单的多循环一边，假如没有负权环，再多循环一边并不会改变dist数组里的值，如果有负权环，dist数组里一定有值改变。我们试试看： 原来保证得到最佳只需要暴力循环n-1遍，得结果： 0 4 -35 -49 -35 -45 -50 暴力n次的结果： 0 4 -44 -58 -44 -54 -59 符合我们的想法。 不过啊这个算法还是有暴力的成分，我们先前提到的只要遍历那些起点可直接到达的点等等想法还没实现，Bellman-Ford算法的时间复杂度有O(nm)，我们讨论算法的对于这样的复杂度肯定还是不满意的。 我们再回忆一下整个搜索过程：其实我们关系的只是可以拓展的可能当中最小的是哪个，为了找到最小的那个，我们上面用了搜索全部的边、点的方法。那么我们的目的还是还是：有没有一种可以维护数据结构的方式，让我们更容易找到最小的那个可能？ 于是队列优化进入思维 ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:2","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#floyd算法bellman-ford算法"},{"categories":["在学算法的日子里"],"content":" SPFA算法我们找u -\u003e p -\u003e v路径时，p点的选择方法会实际影响我们的复杂度。我们的目的肯定是去更新u可以直接到达的点，而下一次就是p可以直接到达的点… SPFA算法使用一个队列去记录这些可以直接到达的点(也就是答案可能在的路径上)。 SPFA是如何做到“只更新可能更新的点”的？ 只让当前点能到达的点入队 如果一个点已经在队列里，便不重复入队 如果一条边的起点还没被更新，那么它的终点不入队 也就是说：当一个点入队了，代表它还在等待更新，当一个点出队了，那么它一定在当前经过最好的更新了。 会有一个点入队了更新之后再次入队的情况吗？会有这种可能。 来看看代码实现吧： // 因为queue其实没有查找操作，所以简单用个bool型数组记录点p在队列中?inqueue[p]=true:inque[p]=false bool inqueue[maxn]; void SPFA(int vn) { // 寻找vn到各个点的最短路径，记录在dist[]数组中。 // 初始化dist[] fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; queue\u003cint\u003e updates; updates.push(vn); // 将vn点加入待更新队列 while (!updates.empty()) { // 获得队首点，并把它移除待更新队列 int firstp = updates.front(); updates.pop(); inqueue[firstp] = false; // 标记firstp已经不在队列中 for (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) { // 遍历k可以直接到达的点to if (dist[to] \u003e dist[firstp] + Edge[k].w) { dist[to] = dist[firstp] + Edge[k].w; if (!inqueue[to]) { updates.push(to); inqueue[to] = true; } } } } } SPFA算法的时间复杂度并不稳定，可以预想，在极端的情况下，SPFA算法的复杂度可以和Bellman-Ford算法一样是O(nm)（不过随机数据模拟的算法复杂度大概是O(m + nlogn)） SPFA算法也可以判断负权环的存在：若一个点入队次数超过n次，接下来无论怎么更新队列都不会为空，可以据此判断是否有负权环。 emmm优化了一点的BellmanFord算法？(思考) 接下来介绍复杂度稳定的贪心算法：==Dijstra算法== ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:3","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#spfa算法"},{"categories":["在学算法的日子里"],"content":" ☆☆☆Dijstra算法Dij假设没有负边 因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。 思路：起点u可以直接到达的点中，最近的点p对应的e\u003cu, p\u003e一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; int path[maxm]; // 储存路径(存边) struct Polar { // 注意每个dist其实是一对一的绑定了它的索引的，直接写什么return dist[a]\u003edist[b]会破坏堆的结构，可能会让dist[a]和dist[b]的索引变化。 int id, dist; Polar(int dist, int id) :dist(dist), id(id) {} // 对结构体中传数据，和下面这种写法作用一样： // Polar(int d, int d_id) { // dist = d; // id = d_id; // } // 重载运算符\u003c bool operator\u003c(const Polar\u0026 P)const { return dist \u003c P.dist; } }; struct cmp { // // 重写仿函数法： bool operator ()(Polar a, Polar b) { // 重载()运算符，使其成为一个仿函数 return a.dist \u003e b.dist; } }; // priority_queue\u003cPolar, vector\u003cPolar\u003e, cmp\u003e q; priority_queue\u003cPolar\u003e q; bool visited[maxn]; void Dij(int vn) { fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; q.push(Polar(0, vn)); while (!q.empty()) { int pid = q.top().id; q.pop(); if (visited[pid]) // 若已经在队列中 continue; visited[pid] = true; for (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) { if (dist[pid] + Edge[ei].w \u003c dist[to]){ dist[to] = dist[pid] + Edge[ei].w; path[to] = Edge[ei].from; // 记录路径的 if (!visited[to]) q.push(Polar(dist[to], to)); } } } } int main() { cin \u003e\u003e n \u003e\u003e m; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } int s = 1, t = 5; Dij(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; // -\u003e0 4 3 5 10 6 4 while (t != s) { cout \u003c\u003c t \u003c\u003c \"\u003c-\"; t = path[t]; } cout \u003c\u003c t; // -\u003e5\u003c-4\u003c-7\u003c-3\u003c-1 return 0; } 当然了用pair也行，反正只有id和dist两个数据，多个其实也没关系你也可以pair套pair (另外两种简单的写法在STL.md里面写了，这里不写了) -如何记录路径？把在更新点更新path数组就行。也就是dist[pos]\u003edist[u]+w(u-\u003epos)的时候把这个更新的来源放在path数组里就行（记录到达某点的最好的路径的上一个来源点）。像这样： if (dist[pid] + Edge[ei].w \u003c dist[to]){ dist[to] = dist[pid] + Edge[ei].w; path[to] = Edge[ei].from; } ","date":"2023-12-23","objectID":"/posts/shortest_path/:0:4","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#dijstra算法"},{"categories":["在学算法的日子里"],"content":" ☆☆☆Dijstra算法Dij假设没有负边 因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。 思路：起点u可以直接到达的点中，最近的点p对应的e一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。 #include using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; int path[maxm]; // 储存路径(存边) struct Polar { // 注意每个dist其实是一对一的绑定了它的索引的，直接写什么return dist[a]\u003edist[b]会破坏堆的结构，可能会让dist[a]和dist[b]的索引变化。 int id, dist; Polar(int dist, int id) :dist(dist), id(id) {} // 对结构体中传数据，和下面这种写法作用一样： // Polar(int d, int d_id) { // dist = d; // id = d_id; // } // 重载运算符\u003c bool operator\u003c(const Polar\u0026 P)const { return dist \u003c P.dist; } }; struct cmp { // // 重写仿函数法： bool operator ()(Polar a, Polar b) { // 重载()运算符，使其成为一个仿函数 return a.dist \u003e b.dist; } }; // priority_queue","date":"2023-12-23","objectID":"/posts/shortest_path/:0:4","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#-如何记录路径"},{"categories":["在学算法的日子里"],"content":" 模板题 模板题指路： P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) P3371【模板】单源最短路径（弱化版） ==题目背景== 本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 P4779。 题目描述 如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。 ==输入格式== 第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。 接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \\to v$ 的，长度为 $w$ 的边。 ==输出格式== 输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。 ==样例== 样例输入 #1 4 6 1 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 样例输出 #1 0 2 4 3 ==提示== 【数据范围】 对于 $20%$ 的数据：$1\\le n \\le 5$，$1\\le m \\le 15$； 对于 $40%$ 的数据：$1\\le n \\le 100$，$1\\le m \\le 10^4$； 对于 $70%$ 的数据：$1\\le n \\le 1000$，$1\\le m \\le 10^5$； 对于 $100%$ 的数据：$1 \\le n \\le 10^4$，$1\\le m \\le 5\\times 10^5$，$1\\le u,v\\le n$，$w\\ge 0$，$\\sum w\u003c 2^{31}$，保证数据随机。 Update 2022/07/29：两个点之间可能有多条边，敬请注意。 对于真正 $100%$ 的数据，请移步 P4779。请注意，该题与本题数据范围略有不同。 样例说明： 图片1到3和1到4的文字位置调换 AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f const long long maxn = 1e5 + 50, maxm = 1e7 + 50; typedef long long ll; struct EdgeNode { int from; int to; // 终点 ll w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; ll dist[maxm]; ll n, m; bool inqueue[maxn]; void SPFA(int vn) { fill(dist + 1, dist + n + 1, INF); dist[vn] = 0; queue\u003cint\u003e updates; updates.push(vn); while (!updates.empty()) { int firstp = updates.front(); updates.pop(); inqueue[firstp] = false; for (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) { // 遍历k可以直接到达的点to if (dist[to] \u003e dist[firstp] + Edge[k].w) { dist[to] = dist[firstp] + Edge[k].w; if (!inqueue[to]) { updates.push(to); inqueue[to] = true; } } } } } int main() { int s; cin \u003e\u003e n \u003e\u003e m \u003e\u003e s; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { ll fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } SPFA(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; return 0; } 这个…没有卡SPFA。看另一个卡SPFA的题： P4779【模板】单源最短路径（标准版） ==题目背景== 2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。 然后呢？ $100 \\rightarrow 60$； $\\text{Ag} \\rightarrow \\text{Cu}$； 最终，他因此没能与理想的大学达成契约。 小 F 衷心祝愿大家不再重蹈覆辙。 ==题目描述== 给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。 数据保证你能从 $s$ 出发到任意点。 ==输入格式== 第一行为三个正整数 $n, m, s$。 第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。 ==输出格式== 输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。 ==样例== 样例输入 #1 4 6 1 1 2 2 2 3 2 2 4 1 1 3 5 3 4 3 1 4 4 样例输出 #1 0 2 4 3 ==提示== 样例解释请参考 数据随机的模板题。 $1 \\leq n \\leq 10^5$； $1 \\leq m \\leq 2\\times 10^5$； $s = 1$； $1 \\leq u_i, v_i\\leq n$； $0 \\leq w_i \\leq 10 ^ 9$, $0 \\leq \\sum w_i \\leq 10 ^ 9$。 本题数据可能会持续更新，但不会重测，望周知。 2018.09.04 数据更新 from @zzq AC代码 #include\u003cbits/stdc++.h\u003e using namespace std; #define INF 0x3f3f3f3f typedef long long ll; const long long maxn = 1e5 + 50, maxm = 1e7 + 50; struct EdgeNode { int from; int to; // 终点 int w; // 权值 int next; // 下一位置 }; EdgeNode Edge[maxm]; int head[maxn]; int dist[maxm]; int n, m; // priority_queue\u003cpair\u003cll, int\u003e\u003e q; priority_queue\u003cpair\u003cll, int\u003e, vector\u003cpair\u003cll, int\u003e\u003e, greater\u003cpair\u003cll, int\u003e\u003e\u003e q; bool visited[maxn]; // 记录已经获得最短路的点 void Dij(int vn) { dist[vn] = 0; // 初始化 q.push(make_pair(dist[vn], vn)); while (!q.empty()) { // 取队首元素(最小的)将它移出队列并标记移出 int pid = q.top().second; q.pop(); if (visited[pid]) continue; visited[pid] = true; for (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) { // 找和pid(被移出的已最佳点)相连的边，更新dist if (dist[to] \u003e dist[pid] + Edge[ei].w) { dist[to] = dist[pid] + Edge[ei].w; if (!visited[to]) q.push(make_pair(dist[to], to)); } } } } int main() { int s; cin \u003e\u003e n \u003e\u003e m \u003e\u003e s; // 初始化head memset(head, -1, sizeof(head)); // 读入数据 for (int i = 0;i \u003c m;i++) { int fi, ti, wi; cin \u003e\u003e fi \u003e\u003e ti \u003e\u003e wi; Edge[i].to = ti; Edge[i].w = wi; Edge[i].from = fi; Edge[i].next = head[fi]; head[fi] = i; } fill(dist + 1, dist + n + 1, INF); Dij(s); for (int i = 1;i \u003c= n;i++) cout \u003c\u003c dist[i] \u003c\u003c \" \"; cout \u003c\u003c endl; return 0; } 啊总算绕完最短路这几个算法了，时候想通了感觉还挺明白的，不过由于某人的码力好差，老是达不到想要的效果[可恶]，还得多写代","date":"2023-12-23","objectID":"/posts/shortest_path/:0:5","series":["算法模板笔记"],"tags":["图论","最短路"],"title":"最短路问题（Dijkstra + SPFA + Floyd）","uri":"/posts/shortest_path/#模板题"},{"categories":["在学算法的日子里"],"content":"有的题还没写完）咕咕咕）） ","date":"2023-12-19","objectID":"/posts/nenuoj/:0:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#"},{"categories":["在学算法的日子里"],"content":" NENU OJ算法2例题这学期写算法2的思路并不都很详细，不过如果有想交流的也可以评论区或者私信，学校oj的题大多比较简单，这里的所有代码或许只保证通过学校的弱测试数据，因为其他地方OJ我还没有试过。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:0:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#nenu-oj算法2例题"},{"categories":["在学算法的日子里"],"content":" 算法2递归A","date":"2023-12-19","objectID":"/posts/nenuoj/:1:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2递归a"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 输入 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 输出 输出猴子第一天摘的桃子数，每组数据占一行。 样例输入 2 2 2 3 0 样例输出 6 6 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1241-a001-猴子吃桃"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 输入 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 输出 输出猴子第一天摘的桃子数，每组数据占一行。 样例输入 2 2 2 3 0 样例输出 6 6 参考代码 #include using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述"},{"categories":["在学算法的日子里"],"content":" 1241: A001 猴子吃桃 题目描述猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。 输入 输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m\u003e1)天后剩余的桃子数k(k\u003e=0)。 输出 输出猴子第一天摘的桃子数，每组数据占一行。 样例输入 2 2 2 3 0 样例输出 6 6 参考代码 #include using namespace std; int main() { int n;cin \u003e\u003e n; while (n--) { int m, k;cin \u003e\u003e m \u003e\u003e k; int sum = k; for (int i = 0;i \u003c m - 1;i++) { sum++; sum *= 2; } cout \u003c\u003c sum \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 输出 n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 样例输入 2 48 32 15 5 样例输出 16 5 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1242-a002-最大公约数"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 输出 n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 样例输入 2 48 32 15 5 样例输出 16 5 参考代码 #include using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 1242: A002 最大公约数 题目描述输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）： （1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步； （3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。 输出 n行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。 样例输入 2 48 32 15 5 样例输出 16 5 参考代码 #include using namespace std; int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; int yu = m % n; while (yu) { m = n;n = yu; yu = m % n; } cout \u003c\u003c n \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 输入 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 输出 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 样例输入 3 1 样例输出 A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1243-a003-经典的hanoi汉诺塔问题"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 输入 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 输出 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 样例输入 3 1 样例输出 A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC 参考代码 #include using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 1243: A003 经典的Hanoi(汉诺塔)问题 题目描述有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。 输入 输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。 输出 对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。 样例输入 3 1 样例输出 A--\u003eC A--\u003eB C--\u003eB A--\u003eC B--\u003eA B--\u003eC A--\u003eC A--\u003eC 参考代码 #include using namespace std; void hanoi(int n, int from, int to) { if (n == 0) return; // 全部移完，终止递归 // 把from位置上的上面的n-1个移到不是from也不是to的位置 hanoi(n - 1, from, (3 - from - to)); // 移动最底下的最大的那个，并输出记录 cout \u003c\u003c char(from + 'A') \u003c\u003c \"--\u003e\" \u003c\u003c char(to + 'A') \u003c\u003c endl; // 把之前移走的n-1个移到to位置 hanoi(n - 1, (3 - from - to), to); } int main() { int n; while (cin \u003e\u003e n) { hanoi(n, 0, 2); cout \u003c\u003c \"\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 输出 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 样例输入 4 5 2 19 1 样例输出 5 1 4181 1 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1244-a004-菲波那契数列"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 输出 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 样例输入 4 5 2 19 1 样例输出 5 1 4181 1 参考代码 #include using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 1244: A004 菲波那契数列 题目描述菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 \u003c= a \u003c= 20)。 输出 输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。 样例输入 4 5 2 19 1 样例输出 5 1 4181 1 参考代码 #include using namespace std; int fib(int n) { if (n == 1 || n == 2)return 1; return fib(n - 1) + fib(n - 2); } int main() { int t;cin \u003e\u003e t; while (t--) { int a;cin \u003e\u003e a; cout \u003c\u003c fib(a) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 输入 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 输出 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 样例输入 0 1 2 3 样例输出 no no yes no 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1245-a005-另一个fibonacci数列"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 输入 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 输出 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 样例输入 0 1 2 3 样例输出 no no yes no 参考代码 #include using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 1245: A005 另一个Fibonacci数列 题目描述定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。 输入 输入文件中包含多行，每行为一个整数n，n\u003c1000000。 输出 对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。 样例输入 0 1 2 3 样例输出 no no yes no 参考代码 #include using namespace std; int main() { long long na; while (cin \u003e\u003e na) { if (na % 8 == 2 || na % 8 == 6)cout \u003c\u003c \"yes\\n\"; else cout \u003c\u003c \"no\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 输入 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 输出 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 样例输入 2 3 -1 样例输出 X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1246-a006-分形fractal"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 输入 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 输出 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 样例输入 2 3 -1 样例输出 X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X 参考代码 #include using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 1246: A006 分形（Fractal） 题目描述分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X 度数为2的分形为： X X X X X 如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为： B(n-1) B(n-1) B(n-1) B(n-1) B(n-1) 你的任务是输出度数为n的盒形分形。 输入 输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。 输出 对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。 样例输入 2 3 -1 样例输出 X X X X X - X X X X X X X X X X X X X X X X X X X X X X X X X 参考代码 #include using namespace std; const int maxlen = pow(3, 8); // string mp[maxlen]; char mp[maxlen][maxlen]; int xpos[maxlen]; void tocpyRec(int deg, int tox, int toy,int fillblank) { int len = pow(3, deg - 1); // 左上角标记 for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c len;j++) { // cout \u003c\u003c mp[i][j] \u003c\u003c \":\" \u003c\u003c i \u003c\u003c \"-\" \u003c\u003c j \u003c\u003c endl; if (fillblank) mp[tox * len + i][toy * len + j] = ' '; else mp[tox * len + i][toy * len + j] = mp[i][j]; } } } void fw(int deg) { if (deg \u003e 1) { fw(deg - 1); } for (int i = 0;i \u003c 3;i++) { for (int j = 0;j \u003c 3;j++) { if ((i + j) % 2 == 0 \u0026\u0026 (i || j)) { // 有内容的块坐标 tocpyRec(deg - 1, i, j, 0); } else if (i || j) { tocpyRec(deg - 1, i, j, 1); } } } } int main() { mp[0][0] = 'X'; int n; int flag = 0; while (cin \u003e\u003e n \u0026\u0026 n != -1) { if (flag)cout \u003c\u003c \"-\\n\"; flag = 1; fw(n); int len = pow(3, n - 1); for (int i = 0;i \u003c len;i++) for (int j = 0;j \u003c len;j++) if (mp[i][j] == 'X') xpos[i] = j; for (int i = 0;i \u003c len;i++) { for (int j = 0;j \u003c= xpos[i];j++) { cout \u003c\u003c mp[i][j]; } cout \u003c\u003c endl; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 输入 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 输出 每行输出只有一个正整数xi。 样例输入 10 4 样例输出 2 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1247-a007-二叉树"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 输入 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 输出 每行输出只有一个正整数xi。 样例输入 10 4 样例输出 2 参考代码 #include using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-6"},{"categories":["在学算法的日子里"],"content":" 1247: A007 二叉树 题目描述如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。 输入 输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。 输出 每行输出只有一个正整数xi。 样例输入 10 4 样例输出 2 参考代码 #include using namespace std; const int N = 12; int ax[N], ay[N]; int main() { int x, y; // 找重合的路径 while (cin \u003e\u003e x \u003e\u003e y) { int kx = 0; while (x) { ax[kx++] = x % 2; x /= 2; } int ky = 0; while (y) { ay[ky++] = y % 2; y /= 2; } int kmii = kx \u003e ky ? ky : kx; int ans = 0; for (int i = 1;i \u003c= kmii;i++) { if (ax[kx - i] == ay[ky - i]) { ans \u003c\u003c= 1; ans += ax[kx - i]; } else break; } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 输入 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出n行，每行表达式的值，保留3位小数输出。 样例输入 1 * + 11.0 12.0 + 24.0 35.0 样例输出 1357.000 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1248-a008-波兰表达式"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 输入 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出n行，每行表达式的值，保留3位小数输出。 样例输入 1 * + 11.0 12.0 + 24.0 35.0 样例输出 1357.000 参考代码 #include using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-7"},{"categories":["在学算法的日子里"],"content":" 1248: A008 波兰表达式 题目描述波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。 输入 输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。 输出 输出n行，每行表达式的值，保留3位小数输出。 样例输入 1 * + 11.0 12.0 + 24.0 35.0 样例输出 1357.000 参考代码 #include using namespace std; double dox() { string st;cin \u003e\u003e st; switch (st[0]) { case '+': return dox() + dox(); case '-': return dox() - dox(); case '/': return dox() / dox(); case '*': return dox() * dox(); default:break; } return atof(st.c_str()); } int main() { int t;cin \u003e\u003e t; while (t--) { cout \u003c\u003c fixed \u003c\u003c setprecision(3) \u003c\u003c dox() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 输入 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 输出 对输入的每组数据M和N，用一行输出相应的K。 样例输入 1 7 3 样例输出 8 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1249-a009-放苹果"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 输入 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 输出 对输入的每组数据M和N，用一行输出相应的K。 样例输入 1 7 3 样例输出 8 参考代码 #include using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-8"},{"categories":["在学算法的日子里"],"content":" 1249: A009 放苹果 题目描述把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。 输入 第一行是测试数据的数目t（0 \u003c= t \u003c= 20）。以下每行均包含二个整数M和N，以空格分开。1 \u003c= M，N \u003c= 10。 输出 对输入的每组数据M和N，用一行输出相应的K。 样例输入 1 7 3 样例输出 8 参考代码 #include using namespace std; const int N = 15; int dp[N][N]; int divx(int apl, int pla) { if (apl == 0 || pla == 1) return dp[apl][pla] = 1; if (pla \u003e apl) return dp[apl][pla] = divx(apl, apl); return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla); } int main() { int t;cin \u003e\u003e t; int m, n; while (t--) { cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c divx(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ 输入 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 输出 输出第m个人的岁数，每个一行。 样例输入 5 2 10 样例输出 18 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1250-a010-递归练习1"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ 输入 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 输出 输出第m个人的岁数，每个一行。 样例输入 5 2 10 样例输出 18 参考代码 #include using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-9"},{"categories":["在学算法的日子里"],"content":" 1250: A010 递归练习1 题目描述有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？ 输入 输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。 输出 输出第m个人的岁数，每个一行。 样例输入 5 2 10 样例输出 18 参考代码 #include using namespace std; int m, n, k; int age(int ind) { if (ind == 1)return k; return age(ind - 1) + n; } int main() { while (cin \u003e\u003e m \u003e\u003e n \u003e\u003e k) { cout \u003c\u003c age(m) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:10","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-9"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 输出 输出组合数C(m,n)。 样例输入 2 1 100 100 1 样例输出 0 100 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1251-a011-递归练习2"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 输出 输出组合数C(m,n)。 样例输入 2 1 100 100 1 样例输出 0 100 参考代码 #include using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-10"},{"categories":["在学算法的日子里"],"content":" 1251: A011 递归练习2 题目描述根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m \u003c 0或n \u003c 0或m \u003c n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。 输出 输出组合数C(m,n)。 样例输入 2 1 100 100 1 样例输出 0 100 参考代码 #include using namespace std; int C(int m, int n) { if (n == 1)return m; if (m \u003c 0 || n \u003c 0 || m \u003c n)return 0; if (m == n)return 1; return C(m - 1, n) + C(m - 1, n - 1); } int main() { int t;cin \u003e\u003e t; while (t--) { int m, n;cin \u003e\u003e m \u003e\u003e n; cout \u003c\u003c C(m, n) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:11","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-10"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 输入 输入有多个整数t，每个一行。 输出 输出t时刻反应堆里分别有多少个α粒子和β粒子。 样例输入 6 样例输出 183 546 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; pair\u003cint, int\u003e qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1252-a012-递归练习3"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 输入 输入有多个整数t，每个一行。 输出 输出t时刻反应堆里分别有多少个α粒子和β粒子。 样例输入 6 样例输出 183 546 参考代码 #include using namespace std; pair qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-11"},{"categories":["在学算法的日子里"],"content":" 1252: A012 递归练习3 题目描述核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。 输入 输入有多个整数t，每个一行。 输出 输出t时刻反应堆里分别有多少个α粒子和β粒子。 样例输入 6 样例输出 183 546 参考代码 #include using namespace std; pair qut(int n) { if (n == 0)return make_pair(1, 0); int tempa = qut(n - 1).first, tempb = qut(n - 1).second; int a = tempb, b = 3 * tempa + 2 * tempb; return make_pair(a, b); } int main() { int t; while (cin \u003e\u003e t) { cout \u003c\u003c qut(t).first \u003c\u003c \" \" \u003c\u003c qut(t).second \u003c\u003c endl; } return 0; } 插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。 ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:12","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-11"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 输入 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 输出 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 样例输出 45 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx\u003ch \u0026\u0026 ny\u003e-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1253-a013-红与黑"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 输入 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 输出 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 样例输出 45 参考代码 #include using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-12"},{"categories":["在学算法的日子里"],"content":" 1253: A013 红与黑 题目描述有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。 输入 包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。 当在一行中读入的是两个零时，表示输入结束。 输出 对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 0 0 样例输出 45 参考代码 #include using namespace std; const int maxh = 25; string mp[maxh]; int dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 }; int w, h; int move(int x, int y, int allstep) { for (int i = 0;i \u003c 4;i++) { int nx = x + dx[i], ny = y + dy[i]; if (nx \u003e -1 \u0026\u0026 nx-1 \u0026\u0026 ny \u003c w \u0026\u0026 mp[nx][ny] == '.'){ mp[nx][ny] = '#'; allstep = move(nx, ny, allstep + 1); } } return allstep; } int main() { while (cin \u003e\u003e w \u003e\u003e h \u0026\u0026 w != 0 \u0026\u0026 h != 0) { int si, se; for (int i = 0;i \u003c h;i++) { cin \u003e\u003e mp[i]; if (mp[i].find(\"@\") != string::npos) { si = i;se = mp[i].find(\"@\"); } } int steps = move(si, se, 1); cout \u003c\u003c steps \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:13","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-12"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 输入 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 输出 城堡的房间数、城堡中最大房间所包括的方块数。 样例输入 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 样例输出 5 9 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1254-a014-城堡问题"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 输入 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 输出 城堡的房间数、城堡中最大房间所包括的方块数。 样例输入 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 样例输出 5 9 参考代码 #include using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-13"},{"categories":["在学算法的日子里"],"content":" 1254: A014 城堡问题 题目描述1 2 3 4 5 6 7 ############################# 1 # | # | # | | # #####—#####—#—#####—# 2 # # | # # # # # #—#####—#####—#####—# 3 # | | # # # # # #—#########—#####—#—# 4 # # | | | | # # ############################# (图 1) ‘#’ = Wall ‘|’ = No wall ‘-’ = No wall 图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。 输入 程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。 输出 城堡的房间数、城堡中最大房间所包括的方块数。 样例输入 4 7 11 6 11 6 3 10 6 7 9 6 13 5 15 5 1 10 12 7 13 7 5 13 11 10 8 10 12 13 样例输出 5 9 参考代码 #include using namespace std; const int N = 60; int wall[N][N], fw[N][N]; int roomnum = 0, sizea = 0; void dfs(int x, int y) { // 查找点(x,y)的信息 if (fw[x][y]) return; sizea++; fw[x][y] = roomnum; if ((wall[x][y] \u0026 1) == 0)dfs(x, y - 1); if ((wall[x][y] \u0026 2) == 0)dfs(x - 1, y); if ((wall[x][y] \u0026 4) == 0)dfs(x, y + 1); if ((wall[x][y] \u0026 8) == 0)dfs(x + 1, y); } int main() { int h, w;cin \u003e\u003e h \u003e\u003e w; for (int i = 1;i \u003c= h;i++){ for (int j = 1;j \u003c= w;j++){ cin \u003e\u003e wall[i][j]; } } int maxroom = 0; for (int i = 1;i \u003c= h;i++) { for (int j = 1;j \u003c= w;j++) { if (!fw[i][j]) { // (i,j)没被找过(新的area) roomnum++; dfs(i, j); maxroom = max(maxroom, sizea); sizea = 0; } } } cout \u003c\u003c roomnum \u003c\u003c endl \u003c\u003c maxroom \u003c\u003c endl; return 0; } /* 2 1 4 8 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:14","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-13"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 输出 n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 样例输入 2 2 20 样例输出 1 4 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1255-a015-分解因式"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 输出 n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 样例输入 2 2 20 样例输出 1 4 参考代码 #include using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-14"},{"categories":["在学算法的日子里"],"content":" 1255: A015 分解因式 题目描述给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 \u003c a1 \u003c= a2 \u003c= a3 \u003c= … \u003c= an，问这样的分解的种数有多少。注意到a = a也是一种分解。 输入 第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 \u003c a \u003c 32768)。 输出 n行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。 样例输入 2 2 20 样例输出 1 4 参考代码 #include using namespace std; int ans = 0; void dfs(int tar, int now) { if (tar != 1) { for (int i = now;i \u003c= tar;i++) if (tar % i == 0) dfs(tar / i, i); } else { ans++;return; } } int main() { int t;cin \u003e\u003e t; while (t--) { ans = 0; int n;cin \u003e\u003e n; if (n == 2) { cout \u003c\u003c 1 \u003c\u003c endl; continue; } dfs(n, 2); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:15","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-14"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 输入 一个正整数n。 输出 一个正整数，表示具有该性质数的个数。 样例输入 6 样例输出 6 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1256-a016-数字拼凑"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 输入 一个正整数n。 输出 一个正整数，表示具有该性质数的个数。 样例输入 6 样例输出 6 参考代码 #include using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-15"},{"categories":["在学算法的日子里"],"content":" 1256: A016 数字拼凑 题目描述现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n \u003c= 500)，然后对此正整数按照如下方法进行处理： 不作任何处理； 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半； 加上数后，继续按此规则进行处理，直到不能再加正整数为止。 输入 一个正整数n。 输出 一个正整数，表示具有该性质数的个数。 样例输入 6 样例输出 6 参考代码 #include using namespace std; int fx[1010]; int f(int n) { if (n == 1)return 1; if (fx[n])return fx[n]; int cnt = 0; for (int i = 1;i \u003c= n / 2;i++) cnt += f(i); return fx[n] = cnt + 1; } int main() { int n; cin \u003e\u003e n; cout \u003c\u003c f(n) \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:1:16","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-15"},{"categories":["在学算法的日子里"],"content":" 算法2排序B","date":"2023-12-19","objectID":"/posts/nenuoj/:2:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2排序b"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 输入 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 输出 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 样例输入 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 样例输出 9 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector\u003cnode\u003e a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1257-b001-快乐的蠕虫"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 输入 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 输出 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 样例输入 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 样例输出 9 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-16"},{"categories":["在学算法的日子里"],"content":" 1257: B001 快乐的蠕虫 题目描述有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。 本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。 输入 输入文件的第1行是一个整数t，1\u003c=t\u003c=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0\u003c=m,n,k\u003c=200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。 输出 对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。 样例输入 1 5 5 6 1 5 2 3 2 4 4 2 4 3 5 1 样例输出 9 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n, m, k; struct node { int x, y; node(int x, int y) : x(x), y(y) {} }; bool cmp1(node a, node b) { if (a.x == b.x) return a.y \u003c b.y; return a.x \u003c b.x; } bool cmp2(node a, node b) { if (a.y == b.y) return a.x \u003c b.x; return a.y \u003c b.y; } vector a; int ans = 0; void search(bool f) { for (int i = 1;i \u003c a.size();i++) { int nx = a[i].x, ny = a[i].y; int px = a[i - 1].x, py = a[i - 1].y; if (f) { if (nx != px)continue; if (ny - py \u003e 2)ans++; } else { if (ny != py)continue; if (nx - px \u003e 2)ans++; } } } void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e k; ans = 0; a.clear(); for (int i = 0;i \u003c k;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; a.push_back(node(x, y)); } for (int i = 0;i \u003c m + 2;i++) { a.push_back(node(i, 0)); a.push_back(node(i, n + 1)); } for (int i = 0;i \u003c n + 2;i++) { a.push_back(node(0, i)); a.push_back(node(m + 1, i)); } sort(a.begin(), a.end(), cmp1); search(true); sort(a.begin(), a.end(), cmp2); search(false); cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-16"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 输入 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 输出 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 样例输入 tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX 样例输出 score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1258-b002-单词重组"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 输入 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 输出 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 样例输入 tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX 样例输出 score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-17"},{"categories":["在学算法的日子里"],"content":" 1258: B002 单词重组 题目描述在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。 输入 输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行； （2） 字典后是一行字符串“XXXXXX”，表示字典结束； （3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序； （4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。 所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。 输出 对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。 样例输入 tarp given score refund only trap work earn course pepper part XXXXXX resco nfudre aptr sett oresuc XXXXXX 样例输出 score ****** refund ****** part tarp trap ****** NOT A VALID WORD ****** course ****** 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:2:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-17"},{"categories":["在学算法的日子里"],"content":" 算法2查找C","date":"2023-12-19","objectID":"/posts/nenuoj/:3:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2查找c"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 输入 先给定一个N，N≤100000，接着输入N个字符串。 输出 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 样例输入 5 BBA BBA BEA DEC CCF 样例输出 1 3 2 1 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; map\u003cstring, int\u003ests; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map\u003cstring, int\u003e::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map\u003cstring, int\u003e::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1264-c001-字符串计数"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 输入 先给定一个N，N≤100000，接着输入N个字符串。 输出 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 样例输入 5 BBA BBA BEA DEC CCF 样例输出 1 3 2 1 参考代码 #include using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; mapsts; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-18"},{"categories":["在学算法的日子里"],"content":" 1264: C001 字符串计数 题目描述给出m个字符串，要求输出重复n次的字符串有几个。 输入 先给定一个N，N≤100000，接着输入N个字符串。 输出 对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。 样例输入 5 BBA BBA BEA DEC CCF 样例输出 1 3 2 1 参考代码 #include using namespace std; const int N = 1e5 + 50; int nx[N]; int main() { int n;cin \u003e\u003e n; mapsts; string st; while (n--) { cin \u003e\u003e st; if (sts.find(st) != sts.end()) { map::const_iterator it = sts.find(st); int cnt = (*it).second; sts[st] = ++cnt; } else sts.insert(make_pair(st, 1)); } map::const_iterator it = sts.begin(); for (;it != sts.end();it++) { nx[(*it).second]++; } for (int i = 1;i \u003c= sts.size();i++) { if (nx[i]) cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c nx[i] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-18"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 输入 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 输出 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 样例输入 5 2 3 5 7 12 5 2 16 64 256 1024 0 样例输出 12 no solution 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1265-c002-赌徒"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 输入 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 输出 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 样例输入 5 2 3 5 7 12 5 2 16 64 256 1024 0 样例输出 12 no solution 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-19"},{"categories":["在学算法的日子里"],"content":" 1265: C002 赌徒 题目描述N个赌徒一起决定玩一个游戏： 游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。 最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。 例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。 输入 输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1\u003c=n\u003c=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。 输出 对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。 样例输入 5 2 3 5 7 12 5 2 16 64 256 1024 0 样例输出 12 no solution 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1050; int n; int gbr[maxn]; void solve() { for (int i = 0;i \u003c n;i++) { cin \u003e\u003e gbr[i]; } sort(gbr, gbr + n); for (int pi = n - 1;pi \u003e= 3;pi--) { for (int i = pi - 1;i \u003e= 2;i--) { for (int j = i - 1;j \u003e= 1;j--) { for (int k = j - 1;k \u003e= 0;k--) { int sum = gbr[i] + gbr[j] + gbr[k]; if (sum == gbr[pi]) { cout \u003c\u003c gbr[pi] \u003c\u003c \"\\n\"; return; } } } } } cout \u003c\u003c \"no solution\\n\"; } int main() { // int t;cin \u003e\u003e t; // while (t--) while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-19"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 输入 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 输出 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 样例输入 3 4 6 12 样例输出 NO YES YES NO 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vector\u003cint\u003eprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1266-c003-半素数"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 输入 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 输出 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 样例输入 3 4 6 12 样例输出 NO YES YES NO 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vectorprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-20"},{"categories":["在学算法的日子里"],"content":" 1266: C003 半素数 题目描述素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。 半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。 输入 输入文件中有多个测试数据，每个测试数据包含一个整数N，2\u003c=N\u003c=1,000,000。 输出 对每个测试数据，如果N是半素数，则输出YES，否则输出NO。 样例输入 3 4 6 12 样例输出 NO YES YES NO 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e6 + 100; bool isnp[maxn]; vectorprimes; void Prime(int n) { for (int i = 2;i \u003c= n;i++) { if (!isnp[i]) primes.push_back(i); for (int p : primes) { if (p * i \u003e n)break; isnp[p * i] = true; if (i % p == 0) break; } } } int main() { Prime(maxn - 50); int n; while (cin \u003e\u003e n) { bool f = false; for (int i = 2;i * i \u003c= n;i++) { if (n % i == 0 \u0026\u0026 !isnp[i] \u0026\u0026 !isnp[n / i]){ f = true;break; } } f ? cout \u003c\u003c \"YES\\n\" : cout \u003c\u003c \"NO\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-20"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 输入 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 输出 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 样例输入 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 样例输出 61.329 225.020 0.000 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1267-c004-棍子的膨胀"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 输入 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 输出 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 样例输入 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 样例输出 61.329 225.020 0.000 参考代码 #include using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-21"},{"categories":["在学算法的日子里"],"content":" 1267: C004 棍子的膨胀 题目描述当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。 当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。 ![1699328671418](D:\\Tencent\u0026\u0026\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png) 图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。 输入 输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。 输出 对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。 样例输入 1000 100 0.0001 15000 10 0.00006 10 0 0.001 -1 -1 -1 样例输出 61.329 225.020 0.000 参考代码 #include using namespace std; typedef long long ll; const double eps = 1e-12; const double pi = 3.1415926535; int main() { double l, t, c; while (cin \u003e\u003e l \u003e\u003e t \u003e\u003e c) { if (l \u003c 0 \u0026\u0026 t \u003c 0 \u0026\u0026 c \u003c 0)break; double nl = (1.0 + t * c) * l; double dr = pi, dl = 0.0; while (1) { double mid = (dr + dl) / 2; double r = l / (sin(mid / 2) * 2); if (dr - dl \u003c eps) { double ans = r - r * cos(mid / 2.0); printf(\"%.3lf\\n\", ans); break; } double bar = mid * r; if (bar \u003e nl)dr = mid; else dl = mid; } } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-21"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 输入 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 输出 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 样例输入 4 11 8.02 7.43 4.57 5.39 样例输出 2.00 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1268-c005-电缆主"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 输入 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 输出 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 样例输入 4 11 8.02 7.43 4.57 5.39 样例输出 2.00 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-22"},{"categories":["在学算法的日子里"],"content":" 1268: C005 电缆主 题目描述奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。 裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。 这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。 你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。 输入 第一行是两个整数N和K，N（1\u003c=N\u003c=10000）是仓库里的电缆数，K（1\u003c=K\u003c=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。 输出 所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。 样例输入 4 11 8.02 7.43 4.57 5.39 样例输出 2.00 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10050; int len[maxn]; int n, k; int cnt(int l) { int ret = 0; for (int i = 0;i \u003c n;i++) { ret += len[i] / l; } return ret; } int main() { cin \u003e\u003e n \u003e\u003e k; int left = 1, right = 0; for (int i = 0;i \u003c n;i++) { double ni;cin \u003e\u003e ni; ni *= 100; right = max(right, (int)ni); len[i] = (int)ni; } if (cnt(1) \u003c k) { cout \u003c\u003c \"0.00\\n\"; return 0; } int ans = 0; while (left \u003c= right) { int mid = (left + right) / 2; if (cnt(mid) \u003c k)right = mid - 1; else { ans = mid; left = mid + 1; } } printf(\"%.2lf\", 1.0 * ans / 100); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-22"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 输入 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 输出 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 样例输入 dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay 样例输出 cat eh loops 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10050; map\u003cstring, string\u003emp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1269-c006-宝贝鱼"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 输入 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 输出 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 样例输入 dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay 样例输出 cat eh loops 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10050; mapmp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-23"},{"categories":["在学算法的日子里"],"content":" 1269: C006 宝贝鱼 题目描述你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。 输入 输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。 输出 将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。 样例输入 dog ogday cat atcay pig igpay froot ootfray loops oopslay atcay ittenkay oopslay 样例输出 cat eh loops 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10050; mapmp; int main() { string s1, s2; while (1) { char t = getchar(); if (t == '\\n')break; cin \u003e\u003e s1 \u003e\u003e s2; s1.insert(s1.begin(), t); mp.insert(make_pair(s2, s1)); cin.get(); } string word; while (cin \u003e\u003e word) { auto pos = mp.find(word); if (pos != mp.end()) { cout \u003c\u003c pos-\u003esecond \u003c\u003c endl; } else cout \u003c\u003c \"eh\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-23"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ 输入 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 输出 对于每组数据输出形成正方形的个数。 样例输入 4 1 0 0 1 1 1 0 0 0 样例输出 1 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1270-c007-星空"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ 输入 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 输出 对于每组数据输出形成正方形的个数。 样例输入 4 1 0 0 1 1 1 0 0 0 样例输出 1 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-24"},{"categories":["在学算法的日子里"],"content":" 1270: C007 星空 题目描述将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？ 输入 多组输入。对于每组数据，第一行是n（1\u003c=n\u003c=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。 输出 对于每组数据输出形成正方形的个数。 样例输入 4 1 0 0 1 1 1 0 0 0 样例输出 1 参考代码 ","date":"2023-12-19","objectID":"/posts/nenuoj/:3:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-24"},{"categories":["在学算法的日子里"],"content":" 算法2动态规划D","date":"2023-12-19","objectID":"/posts/nenuoj/:4:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2动态规划d"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 输入 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 输出 输出最大的和。 样例输入 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 样例输出 30 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1272-d001-数字三角形"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 输入 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 输出 输出最大的和。 样例输入 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 样例输出 30 参考代码 #include using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-25"},{"categories":["在学算法的日子里"],"content":" 1272: D001 数字三角形 题目描述7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。 注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。 输入 输入的第一行是一个整数N (1 \u003c N \u003c= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。 输出 输出最大的和。 样例输入 5 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 样例输出 30 参考代码 #include using namespace std; typedef long long ll; const int maxn = 120; ll number[maxn][maxn]; ll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和 int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++) for (int j = 1;j \u003c= i;j++) cin \u003e\u003e number[i][j]; for (int i = 1;i \u003c n;i++) dp[n][i] = number[n][i]; for (int i = n;i \u003e 1;i--) { for (int j = 1;j \u003c= i;j++) { dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j]; } } cout \u003c\u003c dp[1][1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-25"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … \u003ciK \u003c= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8)。 你的任务，就是对于给定的序列，求出最长上升子序列的长度。 输入 输入有很多组，每组输入的第一行是序列的长度N (1 \u003c= N \u003c= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。 输出 输出每组的最长上升子序列的长度。 样例输入 7 1 7 3 5 9 4 8 6 2 3 4 1 6 5 样例输出 4 4 参考代码 #include\u003ciostream\u003e #include\u003cvector\u003e using namespace std; typedef long long ll; const int maxn = 1010; int a[maxn]; // int dp[maxn]; int main() { int n; while (cin \u003e\u003e n) { for (int i = 1;i \u003c= n;i++)cin \u003e\u003e a[i]; vector\u003cint\u003e lmax; lmax.push_back(a[1]); for (int i = 2;i \u003c= n;i++) { if (a[i] \u003e lmax.back()) { lmax.push_back(a[i]); } else if (a[i] \u003c lmax.back()) { int l = 0, r = lmax.size() - 1; while (l \u003c r) { int md = (l + r) / 2; if (lmax[md] \u003c= a[i])l = md + 1; else r = md; } lmax[l] = a[i]; } // for (int j = 0;j \u003c lmax.size();j++) // cout \u003c\u003c lmax[j] \u003c\u003c \" \"; // cout \u003c\u003c endl; } cout \u003c\u003c lmax.size() \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1273-d002-最长上升子序列"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-26"},{"categories":["在学算法的日子里"],"content":" 1273: D002 最长上升子序列 题目描述一个数的序列bi，当b1 \u003c b2 \u003c … \u003c bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 \u003c= i1 \u003c i2 \u003c … ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-26"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 输入 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 输出 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 样例输入 1 3 8 17 20 0 10 8 0 10 13 4 14 3 样例输出 23 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1274-d003-help-jimmy"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 输入 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 输出 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 样例输入 1 3 8 17 20 0 10 8 0 10 13 4 14 3 样例输出 23 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-27"},{"categories":["在学算法的日子里"],"content":" 1274: D003 Help Jimmy 题目描述“Help Jimmy” 是在下图所示的场景上完成的游戏： 场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。 Jimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。 设计一个程序，计算Jimmy到地面时可能的最早时间。 输入 第一行是测试数据的组数t（0 \u003c= t \u003c= 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1\u003c= N \u003c= 1000，-20000 \u003c= X, X1[i], X2[i] \u003c= 20000，0 \u003c H[i] \u003c Y \u003c= 20000（i = 1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。 输出 对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。 样例输入 1 3 8 17 20 0 10 8 0 10 13 4 14 3 样例输出 23 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2e4 + 20; struct PT { int x1, x2, h; bool operator\u003c(const PT\u0026 P)const { return h \u003e P.h; } }pt[maxn]; int n, x, y, mx; int findnext(int id, int x) { // 寻找x下的第一块板 for (int i = id + 1;i \u003c= n + 1;i++) { if (pt[i].x1 \u003c= x \u0026\u0026 pt[i].x2 \u003e= x) { return i; } } return -1; } int fun[maxn]; int dfs(int id, int p, int from) { // cout \u003c\u003c id \u003c\u003c \" \" \u003c\u003c p \u003c\u003c \" \" \u003c\u003c from \u003c\u003c endl; int lp = pt[id].x1, rp = pt[id].x2; // 当前是否到达终点 if (id == n + 1) return 0; int lenl = -1, lenr = -1; // 左走 int lpid = findnext(id, lp); if (lpid != -1 \u0026\u0026 pt[id].h - pt[lpid].h \u003c= mx) { // 可走 lenl= dfs(lpid, lp, id); } // 右走 int rpid = findnext(id, rp); if (rpid != -1 \u0026\u0026 pt[id].h - pt[rpid].h \u003c= mx) { // 可走 lenr= dfs(rpid, rp, id); } if (lenl != -1 \u0026\u0026 lenr != -1) return fun[id] = min(lenl + p - lp, lenr + rp - p); else if (lenl == -1) return fun[id] = lenr + rp - p; else if (lenr == -1) return fun[id] = lenl + p - lp; else return 0; } int main() { int t;cin \u003e\u003e t; while (t--) { cin \u003e\u003e n \u003e\u003e x \u003e\u003e y \u003e\u003e mx; pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e pt[i].x1 \u003e\u003e pt[i].x2 \u003e\u003e pt[i].h; } pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn; sort(pt, pt + n + 1); // 从高到低排列 dfs(0, x, -1); cout \u003c\u003c y + fun[0] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-27"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 输入 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 输出 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 样例输入 abcfbc abfcab programming contest abcd mnp 样例输出 4 2 0 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1275-d004-最长公共子序列"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 输入 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 输出 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 样例输入 abcfbc abfcab programming contest abcd mnp 样例输出 4 2 0 参考代码 #include using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-28"},{"categories":["在学算法的日子里"],"content":" 1275: D004 最长公共子序列 题目描述我们称序列Z = \u003c z1, z2, …, zk \u003e是序列X = \u003c x1, x2, …, xm \u003e的子序列当且仅当存在严格上升的序列\u003c i1, i2, …, ik \u003e，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = \u003c a, b, f, c \u003e 是X = \u003c a, b,c, f, b, c \u003e的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。 输入 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 输出 输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。 样例输入 abcfbc abfcab programming contest abcd mnp 样例输出 4 2 0 参考代码 #include using namespace std; const int maxn = 220; int dp[maxn][maxn]; int main() { ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); string s, t; while (cin \u003e\u003e s \u003e\u003e t) { s = \" \" + s;t = \" \" + t; memset(dp, 0, sizeof(dp)); for (int i = 1;i \u003c s.size();i++) { for (int j = 1;j \u003c t.size();j++) { if (s[i] == t[j]) dp[i][j] = dp[i - 1][j - 1] + 1; else dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); } } cout \u003c\u003c dp[s.size() - 1][t.size() - 1] \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-28"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 输入 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 输出 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 样例输入 4 2 1 2 2 3 4 1 6 2 0 0 样例输出 Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector\u003cint\u003e mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1276-d005-陪审团的人选"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 输入 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 输出 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 样例输入 4 2 1 2 2 3 4 1 6 2 0 0 样例输出 Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 参考代码 #include using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-29"},{"categories":["在学算法的日子里"],"content":" 1276: D005 陪审团的人选 题目描述在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是： 控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。 输入 输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1\u003c=n\u003c=200, 1\u003c=m\u003c=20而且m\u003c=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。 输出 对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。 样例输入 4 2 1 2 2 3 4 1 6 2 0 0 样例输出 Jury #1 Best jury has value 6 for prosecution and value 4 for defence: 2 3 参考代码 #include using namespace std; const int N = 205; const int inf = 0x3f; int dp[N][25][4 * N], a[N], b[N]; vector mark; int main() { int n, m, T = 1; while (cin \u003e\u003e n \u003e\u003e m \u0026\u0026 n) { mark.clear(); memset(dp, -inf, sizeof(dp)); dp[0][0][400] = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i] \u003e\u003e b[i]; } for (int i = 1;i \u003c= n;i++) { for (int j = 0;j \u003c= m;j++) { for (int k = 0;k \u003c= 800;k++) { dp[i][j][k] = dp[i - 1][j][k]; int tt = k - a[i] + b[i]; if (tt \u003c 0 || tt \u003e= 800) continue; if (j == 0) continue; dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]); } } } int t = 0; while (dp[n][m][t + 400] \u003c 0 \u0026\u0026 dp[n][m][-t + 400] \u003c 0) t++; if (dp[n][m][t + 400] \u003e dp[n][m][-t + 400]) t += 400; else t = 400 - t; int nn = n, mm = m, cnt = 0; while (mm) { if (dp[nn][mm][t] == dp[nn - 1][mm][t]) { nn--; } else { mark.push_back(nn); t -= a[nn] - b[nn]; nn--;mm--; cnt++; } } int sum1 = 0, sum2 = 0; for (int i = 0;i \u003c cnt;i++) { sum1 += a[mark[i]]; sum2 += b[mark[i]]; } cout \u003c\u003c \"Jury #\" \u003c\u003c T++ \u003c\u003c \"\\nBest jury has value \" \u003c\u003c sum1 \u003c\u003c \" for prosecution and value \" \u003c\u003c sum2 \u003c\u003c \" for defence:\\n\"; for (int i = cnt - 1;i \u003e= 0;i--) cout \u003c\u003c mark[i] \u003c\u003c ' '; cout \u003c\u003c \"\\n\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-29"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); 输入 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 输出 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 样例输入 1 10 1 -1 2 2 3 -3 4 -4 5 -5 样例输出 13 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1277-d006-最大和"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); 输入 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 输出 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 样例输入 1 10 1 -1 2 2 3 -3 4 -4 5 -5 样例输出 13 参考代码 #include using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-30"},{"categories":["在学算法的日子里"],"content":" 1277: D006 最大和 题目描述给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix} \\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$ 你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。 输入量大，建议使用scanf(); 输入 输入包含 T(\u003c=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2\u003c=n\u003c=50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| \u003c= 10000)。 输出 对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。 样例输入 1 10 1 -1 2 2 3 -3 4 -4 5 -5 样例输出 13 参考代码 #include using namespace std; const int maxn = 2200; int a[maxn]; int leftt[maxn], rightt[maxn]; int lmax[maxn], rmax[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) cin \u003e\u003e a[i]; leftt[1] = a[1];rightt[n] = a[n]; lmax[1] = a[1];rmax[n] = a[n]; for (int i = 2;i \u003c= n;i++) { leftt[i] = max(leftt[i - 1] + a[i], a[i]); lmax[i] = max(lmax[i - 1], leftt[i]); } for (int i = n - 1;i \u003e 0;i--){ rightt[i] = max(rightt[i + 1] + a[i], a[i]); rmax[i] = max(rmax[i + 1], rightt[i]); } int ans = a[1]; for (int i = 2;i \u003c= n;i++) ans = max(ans, lmax[i - 1] + rmax[i]); cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-30"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 输入 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 输出 输出最大矩阵的和。 样例输入 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 15 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1278-d007-最大子矩阵"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 输入 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 输出 输出最大矩阵的和。 样例输入 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 15 参考代码 #include using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-31"},{"categories":["在学算法的日子里"],"content":" 1278: D007 最大子矩阵 题目描述给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8 和值是15。 输入 输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。 输出 输出最大矩阵的和。 样例输入 4 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 样例输出 15 参考代码 #include using namespace std; const int maxn = 120; int rec[maxn][maxn]; int pre[maxn][maxn]; int dp[maxn][maxn]; int main() { int n;cin \u003e\u003e n; pre[0][0] = 0; // 二维前缀和 for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= n;j++) { cin \u003e\u003e rec[i][j]; pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j]; } } // for (int i = 1;i \u003c= n;i++) { // for (int j = 1;j \u003c= n;j++) { // cout \u003c\u003c pre[i][j] \u003c\u003c \" \"; // } // cout \u003c\u003c endl; // } int ans = -200; for (int xi = 1;xi \u003c= n;xi++) { for (int yi = 1;yi \u003c= n;yi++) { for (int xj = xi;xj \u003c= n;xj++) { for (int yj = yi;yj \u003c= n;yj++) { int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1]; ans = max(ans, sum); } } } } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:4:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-31"},{"categories":["在学算法的日子里"],"content":" 算法2搜索E","date":"2023-12-19","objectID":"/posts/nenuoj/:5:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2搜索e"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 输入 每组数据由一行上的2个整数n，k构成（6\u003cn≤200,2≤k≤6）。 输出 对每组测试数据，输出不同的分法整数。 样例输入 7 3 样例输出 4 参考代码 #include\u003cbits/stdc++.h\u003e #define AUTHOR \"DODOLA\" using namespace std; typedef long long ll; const int maxn = 220; ll dp[maxn][maxn]; // i个小球放入j个盒子没有空盒的方法数 int main() { int n, k; cin \u003e\u003e n \u003e\u003e k; for (int i = 1;i \u003c= n;i++) { dp[i][1] = 1;dp[i][0] = 1; } for (int i = 2;i \u003c= n;i++) { for (int j = 2;j \u003c= k;j++) { if (i \u003e j) dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j]; else dp[i][j] = dp[i - 1][j - 1]; } } cout \u003c\u003c dp[n][k] \u003c\u003c endl; return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1281-e001-数的划分"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 输入 每组数据由一行上的2个整数n，k构成（6","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-32"},{"categories":["在学算法的日子里"],"content":" 1281: E001 数的划分 题目描述将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1； 问有多少种不同的分法。 输入 每组数据由一行上的2个整数n，k构成（6","date":"2023-12-19","objectID":"/posts/nenuoj/:5:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-32"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 输入 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 输出 对每组测试数据，输出有最大湖泊的单元的数目。 样例输入 3 4 5 3 2 2 2 3 1 2 3 1 1 样例输出 4 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1282-e002-闪避湖泊"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 输入 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 输出 对每组测试数据，输出有最大湖泊的单元的数目。 样例输入 3 4 5 3 2 2 2 3 1 2 3 1 1 样例输出 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-33"},{"categories":["在学算法的日子里"],"content":" 1282: E002 闪避湖泊 题目描述农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。 农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。 输入 有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。 输出 对每组测试数据，输出有最大湖泊的单元的数目。 样例输入 3 4 5 3 2 2 2 3 1 2 3 1 1 样例输出 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 150; int n, m, k; bool fd[maxn][maxn]; int mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} }; int ans; int dfs(int r, int c) { if (r\u003c1 || r\u003en || c\u003c1 || c\u003em || !fd[r][c])return 0; fd[r][c] = false; int ret = 1; for (int i = 0;i \u003c 4;i++) { ret += dfs(r + mv[i][0], c + mv[i][1]); } return ret; } void solve() { fill(fd[0], fd[0] + maxn * maxn, false); ans = 0; for (int ki = 0;ki \u003c k;ki++) { int r, c;cin \u003e\u003e r \u003e\u003e c; fd[r][c] = true; } for (int i = 1;i \u003c= n;i++) { for (int j = 1;j \u003c= m;j++) { if (fd[i][j]) { ans = max(ans, dfs(i, j)); } } } cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { while (cin \u003e\u003e n \u003e\u003e m \u003e\u003e k) solve(); return 0; } /* 0 1 0 0 0 0 0 1 1 0 0 1 1 0 0 */ ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-33"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 输入 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 输出 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 样例输入 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 样例输出 1 channel needed. 3 channels needed. 参考代码 #include\u003ciostream\u003e #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003calgorithm\u003e using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1283-e003-信道分配"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 输入 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 输出 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 样例输入 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 样例输出 1 channel needed. 3 channels needed. 参考代码 #include #include #include #include using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-34"},{"categories":["在学算法的日子里"],"content":" 1283: E003 信道分配 题目描述当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。 输入 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。 输出 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。 样例输入 2 A: B: 4 A:BC B:ACD C:ABD D:BC 0 样例输出 1 channel needed. 3 channels needed. 参考代码 #include #include #include #include using namespace std; typedef long long ll; const int maxn = 120; bool fd[maxn][maxn]; int ind[30], t; bool dfs(int from, int clr) { // 从from着色 for (int i = 0;i \u003c clr;i++) { bool f = true;ind[from] = i; for (int j = 0;j \u003c from;j++) { if (ind[j] == i \u0026\u0026 fd[from][j]) { f = false; break; } } if (f \u0026\u0026 (from == t - 1 || dfs(from + 1, clr))) return true; } return false; } int main() { while (cin \u003e\u003e t) { cin.get(); if (t == 0)break; memset(fd, 0, sizeof(fd)); memset(ind, 0, sizeof(ind)); bool f = true; for (int i = 0;i \u003c t;i++) { string msg;cin \u003e\u003e msg; if (msg.size() == 2) continue; f = false; int pid = msg[0] - 'A'; for (int j = 2;j \u003c msg.size();j++) { fd[pid][msg[j] - 'A'] = true; fd[msg[j] - 'A'][pid] = true; } } if (f) cout \u003c\u003c \"1 channel needed.\\n\"; else if (dfs(1, 2)) cout \u003c\u003c \"2 channels needed.\\n\"; else if (dfs(1, 3)) cout \u003c\u003c \"3 channels needed.\\n\"; else cout \u003c\u003c \"4 channels needed.\\n\"; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-34"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 输出 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 样例输入 e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 样例输出 To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue\u003cpair\u003cint, int\u003e\u003e q; q.push({ x1, y1 }); while (!q.empty()) { queue\u003cpair\u003cint, int\u003e\u003e qs; while (!q.empty()) { auto [x, y] = q.front();q.pop(); for (int i = 0;i \u003c 8;i++) { int nx = x + mv[i][0], ny = y + mv[i][1]; if (nx \u003c 0 || nx \u003e= 8 || ny \u003c 0 || ny \u003e= 8)continue; if (nx == x2 \u0026\u0026 ny == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes \" \u003c\u003c stp + 1 \u003c\u003c \" knight moves.\\n\"; return; } qs.push({ nx, ny }); } } stp++; q = qs; } } void solve() { int x1 = fs[0] - 'a', y1 = fs[1] - '1', x2 = ts[0] - 'a', y2 = ts[1] - '1'; bfs(x1, y1, x2, y2); } int main() { while (cin \u003e\u003e fs \u003e\u003e ts) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1284-e004-移动的骑士"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 输出 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 样例输入 e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 样例输出 To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. 参考代码 #include using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-35"},{"categories":["在学算法的日子里"],"content":" 1284: E004 移动的骑士 题目描述你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。 国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。 输出 对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。 样例输入 e2 e4 a1 b2 b2 c3 a1 h8 a1 h7 h8 a1 b1 c3 f6 f6 样例输出 To get from e2 to e4 takes 2 knight moves. To get from a1 to b2 takes 4 knight moves. To get from b2 to c3 takes 2 knight moves. To get from a1 to h8 takes 6 knight moves. To get from a1 to h7 takes 5 knight moves. To get from h8 to a1 takes 6 knight moves. To get from b1 to c3 takes 1 knight moves. To get from f6 to f6 takes 0 knight moves. 参考代码 #include using namespace std; typedef long long ll; const int maxn = 150; string fs, ts; int mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} }; void bfs(int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { cout \u003c\u003c \"To get from \" \u003c\u003c fs \u003c\u003c \" to \" \u003c\u003c ts \u003c\u003c \" takes 0 knight moves.\\n\"; return; } int stp = 0; queue","date":"2023-12-19","objectID":"/posts/nenuoj/:5:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-35"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 输入 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 输出 对每个网络输出一行，是选中目标的周长。 样例输入 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 样例输出 8 18 40 参考代码 #include\u003cbits/stdc++.h\u003e #define AUTHOR \"DODOLA\" // #include\u003cqueue\u003e // #include\u003ciostream\u003e // #include\u003cstring\u003e using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vector\u003cstring\u003emp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1285-e005-图像周长"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 输入 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 输出 对每个网络输出一行，是选中目标的周长。 样例输入 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 样例输出 8 18 40 参考代码 #include #define AUTHOR \"DODOLA\" // #include // #include // #include using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vectormp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-36"},{"categories":["在学算法的日子里"],"content":" 1285: E005 图像周长 题目描述病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示 方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。 一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。 技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。 一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。 目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。 输入 输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。 输出 对每个网络输出一行，是选中目标的周长。 样例输入 2 2 2 2 XX XX 6 4 2 3 .XXX .XXX .XXX ...X ..X. X... 5 6 1 3 .XXXX. X....X ..XX.X .X...X ..XXX. 0 0 0 0 样例输出 8 18 40 参考代码 #include #define AUTHOR \"DODOLA\" // #include // #include // #include using namespace std; const int maxn = 250; typedef long long ll; int r, c, x, y; vectormp(maxn); int mv[8][2] = { {1,0},{0,1},{-1,0},{0,-1}, {1,1},{1,-1},{-1,-1},{-1,1}, }; int ans; bool ck[maxn][maxn]; void dfs(int px, int py) { // cout \u003c\u003c px \u003c\u003c \" \" \u003c\u003c py \u003c\u003c endl; // cout \u003c\u003c ans \u003c\u003c endl; if (mp[px][py] != 'X' || ck[px][py])return; ck[px][py] = true; for (int j = 0;j \u003c 4;j++) { int xj = px + mv[j][0], yj = py + mv[j][1]; if (mp[xj][yj] != 'X') ans++; } for (int i = 0;i \u003c 8;i++) { int xi = px + mv[i][0]; int yi = py + mv[i][1]; dfs(xi, yi); } } string s0('.', maxn - 1); void solve() { ans = 0; fill(ck[0], ck[0] + sizeof(ck), false); fill(mp.begin(), mp.end(), s0); for (int i = 1;i \u003c= r;i++) { cin \u003e\u003e mp[i]; mp[i] = \" \" + mp[i] + \" \"; } dfs(x, y); cout \u003c\u003c ans \u003c\u003c \"\\n\"; } int main() { mp[0] = s0; while (cin \u003e\u003e r \u003e\u003e c \u003e\u003e x \u003e\u003e y) { if (!r \u0026\u0026 !c \u0026\u0026 !x \u0026\u0026 !y)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-36"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 输出 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 样例输入 1 8 0 0 7 0 样例输出 5 参考代码 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003ccstring\u003e #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue\u003cP\u003e q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1286-e006-移动的骑士"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 输出 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 样例输入 1 8 0 0 7 0 样例输出 5 参考代码 #include #include #include #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-37"},{"categories":["在学算法的日子里"],"content":" 1286: E006 移动的骑士 题目描述Somurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？ 你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图： 输入 首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 \u003c= l \u003c= 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。 输出 对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。 样例输入 1 8 0 0 7 0 样例输出 5 参考代码 #include #include #include #define AUTHOR \"DODOLA\" using namespace std; struct P { int x; int y; int step; }; int mv[8][2] = { {1, 2}, {2, 1}, {-1, 2}, {-2, 1}, {1, -2}, {2, -1}, {-1, -2}, {-2, -1} }; int bfs(int n, int x1, int y1, int x2, int y2) { if (x1 == x2 \u0026\u0026 y1 == y2) { return 0; } bool gnd[n][n]; queue q; memset(gnd, 0, sizeof(gnd)); P start, node; start.x = x1; start.y = y1; start.step = 0; q.push(start); while (!q.empty()) { int x0, y0, step; start = q.front(); q.pop(); x0 = start.x; y0 = start.y; step = start.step; for (int j = 0; j \u003c 8; j++) { int x3 = x0 + mv[j][0]; int y3 = y0 + mv[j][1]; if (x3 == x2 \u0026\u0026 y3 == y2) return step + 1; if (x3 \u003e= 0 \u0026\u0026 x3 \u003c n \u0026\u0026 y3 \u003e= 0 \u0026\u0026 y3 \u003c n \u0026\u0026 !gnd[x3][y3]) { node.x = x3; node.y = y3; node.step = step + 1; q.push(node); gnd[x3][y3] = 1; } } } return 0; } int main() { int t; cin \u003e\u003e t; while (t--) { int x1, y1, x2, y2, n; cin \u003e\u003e n \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2; cout \u003c\u003c bfs(n, x1, y1, x2, y2) \u003c\u003c endl; } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-37"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 输入 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 输出 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 样例输入 2 6 0 样例输出 10 1110 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1287-e007-寻找m"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 输入 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 输出 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 样例输入 2 6 0 样例输出 10 1110 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-38"},{"categories":["在学算法的日子里"],"content":" 1287: E007 寻找M 题目描述给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。 输入 输入包含多组测试数据。每组测试数据只有一个整数n (1 \u003c= n \u003c= 200)。整数0标志输入的结束。 输出 对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。 样例输入 2 6 0 样例输出 10 1110 参考代码 #include using namespace std; typedef long long ll; const int maxn = 10; int n; bool ck(int x) { while (x) { if (x % 10 == 0 || x % 10 == 1) { x /= 10; continue; } else return false; } return true; } void solve() { for (int i = 1;;i++) { int m = i * n; bool f = ck(m); if (f) { cout \u003c\u003c m \u003c\u003c endl; return; } } } int main() { while (cin \u003e\u003e n) { if (n == 0)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-38"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 输入 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 输出 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 样例输出 45 59 参考代码 #include \u003ciostream\u003e #include \u003cqueue\u003e #include \u003ccstring\u003e const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1288-e008-红与黑"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 输入 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 输出 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 样例输出 45 59 参考代码 #include #include #include const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-39"},{"categories":["在学算法的日子里"],"content":" 1288: E008 红与黑 题目描述有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。 输入 输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。 输出 对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。 样例输入 6 9 ....#. .....# ...... ...... ...... ...... ...... #@...# .#..#. 11 9 .#......... .#.#######. .#.#.....#. .#.#.###.#. .#.#..@#.#. .#.#####.#. .#.......#. .#########. ........... 0 0 样例输出 45 59 参考代码 #include #include #include const int maxn = 120; using namespace std; int r, c; char mp[maxn][maxn]; int mv[4][2] = { {0,1},{0,-1},{1,0},{-1,0}, }; int ans; void dfs(int x, int y) { if (x \u003c 0 || x == c || y \u003c 0 || y == r)return; if (mp[x][y] == '#')return; ans++; mp[x][y] = '#'; for (int i = 0;i \u003c 4;i++) { int xi = x + mv[i][0]; int yi = y + mv[i][1]; dfs(xi, yi); } } void solve() { ans = 0; int px, py; for (int i = 0;i \u003c c;i++) { for (int j = 0;j \u003c r;j++) { cin \u003e\u003e mp[i][j]; if (mp[i][j] == '@') { px = i;py = j; } } } dfs(px, py); cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e r \u003e\u003e c) { if (!r \u0026\u0026 !c)break; solve(); } return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-39"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 输入 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 输出 输出一行，即为原始木棒可能的最小长度。 样例输入 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 样例输出 6 5 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1289-e009-小木棒"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 输入 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 输出 输出一行，即为原始木棒可能的最小长度。 样例输入 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 样例输出 6 5 参考代码 #include using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-40"},{"categories":["在学算法的日子里"],"content":" 1289: E009 小木棒 题目描述George有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。 输入 每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。 输出 输出一行，即为原始木棒可能的最小长度。 样例输入 9 5 2 1 5 2 1 5 2 1 4 1 2 3 4 0 样例输出 6 5 参考代码 #include using namespace std; const int maxn = 80; int n, a[maxn], maxv, tot, vis[maxn], k, len; bool cmp(int a, int b) { return a \u003e b; } bool dfs(int i, int rest, int p) { if (i \u003e k) return 1; int fail = 0; for (int x = p + 1;x \u003c= n;x++) { if (!vis[x]) { if (a[x] == a[fail]) continue; if (rest \u003e a[x]) { vis[x] = 1; bool w = dfs(i, rest - a[x], x); vis[x] = 0; if (!w) fail = x; if (w) return 1; } else if (rest == a[x]) { vis[x] = 1; bool w = dfs(i + 1, len, 0); vis[x] = 0; return w; } if (p == 0) return 0; } } return 0; } void solve() { fill(vis, vis + n + 5, 0); maxv = tot = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; maxv = max(maxv, a[i]); tot += a[i]; } sort(a + 1, a + 1 + n, cmp); for (len = maxv;len \u003c= tot;len++) { if (tot % len == 0) { k = tot / len; if (dfs(1, len, 0)) { cout \u003c\u003c len \u003c\u003c endl; break; } } } } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:5:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-40"},{"categories":["在学算法的日子里"],"content":" 算法2贪心F","date":"2023-12-19","objectID":"/posts/nenuoj/:6:0","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#算法2贪心f"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 输入 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 输出 输出是以分钟为单位的最少准备时间，一行一个。 样例输入 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 样例输出 2 1 3 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector\u003cpair\u003cint, int\u003e\u003e len; for (int i = 0; i \u003c n; i++) { int l, w;cin \u003e\u003e l \u003e\u003e w; len.push_back(make_pair(l, w)); } sort(len.begin(), len.end()); int cnt = 0, ans = 0; while (cnt \u003c n) { ans++; int ki = 0; int li = 0, wi = 0; for (int i = 0;i \u003c n;i++) { if (!ck[i]) { ki = i; li = len[i].first, wi = len[i].second; ck[i] = true; cnt++; break; } } // cout \u003c\u003c ki \u003c\u003c \" \" \u003c\u003c li \u003c\u003c \" \" \u003c\u003c wi \u003c\u003c endl; for (int i = 0;i \u003c n;i++) { if (ck[i])continue; if (li \u003c= len[i].first \u0026\u0026 wi \u003c= len[i].second) { ck[i] = true; cnt++; li = len[i].first, wi = len[i].second; } } } cout \u003c\u003c ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1290-f001-木棒加工问题"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 输入 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 输出 输出是以分钟为单位的最少准备时间，一行一个。 样例输入 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 样例输出 2 1 3 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-41"},{"categories":["在学算法的日子里"],"content":" 1290: F001 木棒加工问题 题目描述现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下： （1） 第一根木棒需要1min的准备时间； （2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。 给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。 输入 输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。 输出 输出是以分钟为单位的最少准备时间，一行一个。 样例输入 3 5 4 9 5 2 2 1 3 5 1 4 3 2 2 1 1 2 2 3 1 3 2 2 3 1 样例输出 2 1 3 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int n; bool ck[maxn]; void solve() { cin \u003e\u003e n; fill(ck, ck + 5050, false); vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:1","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-41"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 输入 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 输出 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 样例输入 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 样例输出 2 1 参考代码 // #include\u003cbits/stdc++.h\u003e #include\u003ciostream\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1291-f002-装箱"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 输入 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 输出 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 样例输入 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 样例输出 2 1 参考代码 // #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-42"},{"categories":["在学算法的日子里"],"content":" 1291: F002 装箱 题目描述一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。 输入 输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。 输出 针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。 样例输入 0 0 4 0 0 1 7 5 1 0 0 0 0 0 0 0 0 0 样例输出 2 1 参考代码 // #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; int b1, b2, b3, b4, b5, b6; int l3[4] = { 0,7,6,5 }; int l2[4] = { 0,5,3,1 }; int l1[9] = { 0,32,28,24,20,16,12,8,4 }; void solve() { int ans = b6 + b5 + b4 + (b3 + 3) / 4; int n2 = 5 * b4 + l2[b3 % 4];; if (n2 \u003e= b2) { int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } else { int m2 = b2 - n2; ans += (m2 + 8) / 9; int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9]; if (n1 \u003c b1) ans += (b1 - n1 + 35) / 36; } cout \u003c\u003c ans \u003c\u003c endl; } int main() { while (cin \u003e\u003e b1 \u003e\u003e b2 \u003e\u003e b3 \u003e\u003e b4 \u003e\u003e b5 \u003e\u003e b6 \u0026\u0026 (b1 || b2 || b3 || b4 || b5 || b6)) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:2","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-42"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 输入 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 输出 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 样例输入 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 样例输出 10 20 参考代码 // #include\u003cbits/stdc++.h\u003e #include\u003ciostream\u003e #include\u003calgorithm\u003e #include\u003cvector\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1292-f003-移动桌子"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 输入 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 输出 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 样例输入 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 样例输出 10 20 参考代码 // #include #include #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-43"},{"categories":["在学算法的日子里"],"content":" 1292: F003 移动桌子 题目描述著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。 这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。 每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。 输入 输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。 输出 每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。 样例输入 2 4 10 20 30 40 50 60 70 80 2 1 3 2 200 样例输出 10 20 参考代码 // #include #include #include #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; int n; void solve() { cin \u003e\u003e n; int pass[220] = {}; for (int i = 1;i \u003c= n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; x = (x + 1) / 2; y = (y + 1) / 2; if (x \u003e y) { x = x ^ y;y = x ^ y;x = x ^ y; } for (int j = x;j \u003c= y;j++) { pass[j]++; } } int ans = *max_element(pass + 1, pass + 201); cout \u003c\u003c 10 * ans \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:3","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-43"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 输入 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 输出 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 样例输入 6 340 500 220 470 100 300 880 943 525 556 612 776 0 样例输出 3 1 5 6 4 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vector\u003cnode\u003eans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1293-f004-基因集合"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 输入 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 输出 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 样例输入 6 340 500 220 470 100 300 880 943 525 556 612 776 0 样例输出 3 1 5 6 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vectorans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-44"},{"categories":["在学算法的日子里"],"content":" 1293: F004 基因集合 题目描述随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。 大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。 输入 给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 \u003c n \u003c 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。 输出 对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。 样例输入 6 340 500 220 470 100 300 880 943 525 556 612 776 0 样例输出 3 1 5 6 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2e5 + 50; struct node { int x;int y; int i; bool operator\u003c(const node\u0026 p)const { return x \u003c p.x; } }wxz[maxn]; int n; void solve() { for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e wxz[i].x \u003e\u003e wxz[i].y; wxz[i].i = i; } sort(wxz + 1, wxz + 1 + n); vectorans; ans.push_back(wxz[1]); for (int i = 2;i \u003c= n;i++) { struct node ni = ans.back(); if (ni.y \u003e wxz[i].y) { ans.pop_back();ans.push_back(wxz[i]); } else if (ni.y \u003c wxz[i].x) { ans.push_back(wxz[i]); } } for (int i = 0;i \u003c ans.size();i++) { cout \u003c\u003c ans[i].i \u003c\u003c \" \"; } cout \u003c\u003c '\\n'; } int main() { while (cin \u003e\u003e n \u0026\u0026 n) solve(); } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:4","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-44"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 输入 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 输出 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 样例输入 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 样例输出 Case 1: 74 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vector\u003cJOB\u003etot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1294-f005-主框架"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 输入 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 输出 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 样例输入 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 样例输出 Case 1: 74 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vectortot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-45"},{"categories":["在学算法的日子里"],"content":" 1294: F005 主框架 题目描述多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则： （1）大型计算机有M个CPU和N大小的内存空间可供分配。 （2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。 （3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。 （4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。 （5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。 （6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。 （7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。 （8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。 （9）当多个作业挂起时，采取先来先服务的原则。 使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui\u003eF并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。 他不会程序设计，又不想手工做，现在你帮助他解决这个问题。 输入 有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。 后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。 输出 根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。 注意：对尚未投入运行的、且时限超过F的作业，不必统计。 样例输入 10 4 256 3 1 16 2 3 10 5 6 2 128 2 4 30 10 5 2 128 2 4 20 10 5 0 样例输出 Case 1: 74 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; struct JOB { int a, b, t, u, v, w, x; bool ok; JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {} bool operator\u003c(const JOB\u0026 N)const { if (N.t == t) return v \u003e N.v; return t \u003c N.t; } }; int ind = 1; int f; int m, n, l; int mi, ni; void solve() { cin \u003e\u003e m \u003e\u003e n \u003e\u003e l; vectortot; for (int i = 0;i \u003c l;i++) { int a, b, t, u, v, w, x; cin \u003e\u003e a \u003e\u003e b \u003e\u003e t \u003e\u003e u \u003e\u003e v \u003e\u003e w \u003e\u003e x; tot.push_back(JOB(a, b, t, u, v, w, x)); } sort(tot.begin(), tot.end()); int ans = 0; for (int i = 1;i \u003c= f;i++) { mi = m;ni = n; for (int j = 0;j \u003c l;j++) { if (tot[j].t \u003e= i) break; if (tot[j].ok || mi \u003c tot[j].a || ni \u003c tot[j].b) continue; tot[j].ok = true; mi -= tot[j].a; ni -= tot[j].b; ans += tot[j].v; if (i \u003e tot[j].u) ans -= (i - tot[j].u) * tot[j].x; else if (i \u003c tot[j].u) ans += (tot[j].u - i) * tot[j].w; } } for (int i = 0;i \u003c l;i++) { if (!tot[i].ok \u0026\u0026 tot[i].u \u003c= f) ans -= (f - tot[i].u) * tot[i].x; } printf(\"Case %d: %d\\n\\n\", ind, ans); ind++; } int main() { while (cin \u003e\u003e f \u0026\u0026 f) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:5","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-45"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 输入 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 输出 输出符合条件的集合R中元素的个数。 样例输入 4 3 6 2 4 0 2 4 7 样例输出 4 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector\u003cpair\u003cint, int\u003e\u003e v; for (int i = 0;i \u003c n;i++) { int a, b; cin \u003e\u003e a \u003e\u003e b; v.push_back(make_pair(a, b)); for (int j = a;j \u003c= b;j++) { cnt[j]++; } } int ans = 0; while (true) { int mx = max_element(cnt, cnt + 10005) - cnt; // cout \u003c\u003c mx \u003c\u003c endl; if (cnt[mx] == 0)break; hasi[mx] = true; ans++; fill(cnt, cnt + 10005, 0); for (int i = 0;i \u003c n;i++) { if (ck[i] == 2)continue; if (v[i].first \u003c= mx \u0026\u0026 v[i].second \u003e= mx) { ck[i]++; } if (ck[i] == 2)continue; for (int j = v[i].first;j \u003c= v[i].second;j++) { if (hasi[j]) continue; cnt[j]++; } } } cout \u003c\u003c ans \u003c\u003c endl; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1295-f006-整数区间"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 输入 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 输出 输出符合条件的集合R中元素的个数。 样例输入 4 3 6 2 4 0 2 4 7 样例输出 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-46"},{"categories":["在学算法的日子里"],"content":" 1295: F006 整数区间 题目描述一个整数区间[a,b] (a \u003c b)，是一个从a到b连续整数的集合。 现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。 输入 输入有多组数据，每组第一行包含整数n(1 \u003c= n \u003c= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 \u003c= a \u003c b \u003c= 10000, a \u003c b)。 输出 输出符合条件的集合R中元素的个数。 样例输入 4 3 6 2 4 0 2 4 7 样例输出 4 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 50; int cnt[maxn]; int n; int ck[maxn]; bool hasi[maxn]; void solve() { while (cin \u003e\u003e n) { fill(hasi, hasi + 10005, false); fill(ck, ck + n + 5, 0); fill(cnt, cnt + 10005, 0); if (!n)return; vector","date":"2023-12-19","objectID":"/posts/nenuoj/:6:6","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-46"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 输入 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 输出 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 样例输入 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 样例输出 Case 1: 2 Case 2: 1 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector\u003cnode\u003e q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1296-f007-安装雷达"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 输入 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 输出 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 样例输入 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 样例输出 Case 1: 2 Case 2: 1 参考代码 #include using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-47"},{"categories":["在学算法的日子里"],"content":" 1296: F007 安装雷达 题目描述我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。 这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。 如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。 输入 输入包含多组测试样例。每组测试第一行包含两个整数n(1\u003c=n\u003c=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。 输出 对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。 样例输入 3 2 1 2 -3 1 2 1 1 2 0 2 0 0 样例输出 Case 1: 2 Case 2: 1 参考代码 #include using namespace std; typedef long long ll; struct node { double x, y; node(double x, double y) :x(x), y(y) {} bool operator \u003c (const node\u0026 a) const { return y \u003c a.y; } }; int n; int d; int ind; void solve() { ind = 1; while (cin \u003e\u003e n \u003e\u003e d) { if (n == 0 \u0026\u0026 d == 0)return; bool f = true; vector q; for (int i = 0;i \u003c n;i++) { int x, y;cin \u003e\u003e x \u003e\u003e y; if (d \u003c y) f = false; if (!f)continue; double ei = sqrt(1.0 * d * d - 1.0 * y * y); q.push_back(node{ x - ei,x + ei }); } if (!f) { printf(\"Case %d: -1\\n\", ind); ind++; continue; } sort(q.begin(), q.end()); int ans = 1; double yi = q[0].y; for (int i = 1;i \u003c q.size();i++) { if (q[i].x \u003c= yi) { continue; } else { ans++; yi = q[i].y; } } printf(\"Case %d: %d\\n\", ind, ans); ind++; } } int main() { // int t;cin \u003e\u003e t; // while (t--) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:7","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-47"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? 输入 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 输出 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 样例输入 10 56 12 1 99 1000 234 33 55 99 812 样例输出 532.00 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1297-f008-排队买饭"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? 输入 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 输出 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 样例输入 10 56 12 1 99 1000 234 33 55 99 812 样例输出 532.00 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-48"},{"categories":["在学算法的日子里"],"content":" 1297: F008 排队买饭 题目描述周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗? 输入 输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。 输出 每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。 样例输入 10 56 12 1 99 1000 234 33 55 99 812 样例输出 532.00 参考代码 #include using namespace std; typedef long long ll; const int maxn = 1e5 + 20; int a[maxn]; int n; void solve() { for (int i = 0;i \u003c n;i++)cin \u003e\u003e a[i]; sort(a, a + n); int ans = 0; int tmp = 0; for (int i = 0;i \u003c n;i++) { tmp += a[i]; ans += tmp; } printf(\"%.2lf\\n\", 1.0 * ans / n); } int main() { while (cin \u003e\u003e n) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:8","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-48"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 输入 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 输出 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） 样例输入 6 40 6 18 11 13 19 11 样例输出 3 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#1298-f009-放书"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 输入 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 输出 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） 样例输入 6 40 6 18 11 13 19 11 样例输出 3 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#题目描述-49"},{"categories":["在学算法的日子里"],"content":" 1298: F009 放书 题目描述周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 所有N(1\u003c=N\u003c=2000)把椅子都有一个确定的高度Hi（1\u003c=Hi\u003c=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。 输入 第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。 输出 输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1） 样例输入 6 40 6 18 11 13 19 11 样例输出 3 参考代码 #include using namespace std; typedef long long ll; const int maxn = 2010; int h[maxn]; int n, b; void solve() { for (int i = 0;i \u003c n;i++) cin \u003e\u003e h[i]; sort(h, h + n); int sum = 0, cnt = 0; for (int i = n - 1;i \u003e= 0;i--) { sum += h[i]; cnt++; if (sum \u003e= b) { cout \u003c\u003c cnt \u003c\u003c endl; return; } } cout \u003c\u003c -1 \u003c\u003c endl; } int main() { while (cin \u003e\u003e n \u003e\u003e b) solve(); return 0; } ","date":"2023-12-19","objectID":"/posts/nenuoj/:6:9","series":["题解记录"],"tags":["算法","NENUOJ"],"title":"NENU2023学年算法2例题","uri":"/posts/nenuoj/#参考代码-49"},{"categories":["关于Hugo的一些设置"],"content":"增加了一个鼠标追尾的效果 QwQ 添加文件的方式参考上一篇~指路这篇 ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#"},{"categories":["关于Hugo的一些设置"],"content":" js文件：pointerfollow.js js 原文件来源：Canva’s Magic Mouse Effect (codepen.io) （我有稍微改了一些样式 qwq，写在代码里了。 ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#js文件"},{"categories":["关于Hugo的一些设置"],"content":" css文件： .star { position: fixed; z-index: 2; color: white; font-size: 1rem; animation-duration: 1500ms; animation-fill-mode: forwards; pointer-events: none; } @keyframes fall-1 { 0% { transform: translate(0px, 0px) rotateX(45deg) rotateY(30deg) rotateZ(0deg) scale(0.25); opacity: 0; } 5% { transform: translate(10px, -10px) rotateX(45deg) rotateY(30deg) rotateZ( 0deg ) scale(1); opacity: 1; } 100% { transform: translate(25px, 200px) rotateX(180deg) rotateY(270deg) rotateZ( 90deg ) scale(1); opacity: 0; } } @keyframes fall-2 { 0% { transform: translate(0px, 0px) rotateX(-20deg) rotateY(10deg) scale(0.25); opacity: 0; } 10% { transform: translate(-10px, -5px) rotateX(-20deg) rotateY(10deg) scale(1); opacity: 1; } 100% { transform: translate(-10px, 160px) rotateX(-90deg) rotateY(45deg) scale( 0.25 ); opacity: 0; } } @keyframes fall-3 { 0% { transform: translate(0px, 0px) rotateX(0deg) rotateY(45deg) scale(0.5); opacity: 0; } 15% { transform: translate(7px, 5px) rotateX(0deg) rotateY(45deg) scale(1); opacity: 1; } 100% { transform: translate(20px, 120px) rotateX(-180deg) rotateY(-90deg) scale( 0.5 ); opacity: 0; } } ","date":"2023-12-19","objectID":"/posts/beautify_site_clickfollow/:0:0","series":null,"tags":["JavaScript","美化","CSS","光标"],"title":"【网站美化】点击特效2","uri":"/posts/beautify_site_clickfollow/#css文件"},{"categories":["关于Hugo的一些设置"],"content":"今天摸鱼把网站的点击特效做了QwQ，选用的效果是烟花（/逆飞的流星🎆🎆，主要摸索了如何在Hugo里添加JavaScript代码 ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#"},{"categories":["关于Hugo的一些设置"],"content":" 添加js文件这次用到的两个js文件在这里： anime.min.js fireworks.js 在./static/下新建一个js文件夹，文件夹下新建两个js文件，命名为anime.min.js和fireworks.js，然后将上面两个文件的内容粘贴进去。 ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#添加js文件"},{"categories":["关于Hugo的一些设置"],"content":" 引入js文件在./layouts/partials/extend_head.html中添加如下代码： \u003cstyle type=\"text/css\"\u003e .fireworks { position: fixed; top: 0; left: 0; widows: 100%; height: 100%; z-index:99999999; pointer-events:none; /*这个样式可以解决正常点击事件不响应的问题*/ } \u003c/style\u003e \u003ccanvas class=\"fireworks\"\u003e \u003c/canvas\u003e \u003cscript src=\"/js/anime.min.js\" \u003e\u003c/script\u003e \u003cscript src=\"/js/fireworks.js\" \u003e\u003c/script\u003e ","date":"2023-12-18","objectID":"/posts/beautify_site_click/:0:0","series":null,"tags":["JavaScript","美化","Hugo","Canva"],"title":"【网站美化】点击特效","uri":"/posts/beautify_site_click/#引入js文件"},{"categories":["关于Hugo的一些设置"],"content":" 简单设计assets/css/common/terms.css添加： .terms-tags{ padding-left: 0; display: flex; flex-wrap: wrap; align-items: center; justify-content: center; } ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:1:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#简单设计"},{"categories":["关于Hugo的一些设置"],"content":" 添加权重在./layouts/_default/terms.html中，找到这段代码并在a标签插入data-weight属性 \u003cul class=\"terms-tags\"\u003e {{- $type := .Type }} {{- range $key, $value := .Data.Terms.Alphabetical }} {{- $name := .Name }} {{- $count := .Count }} {{- with site.GetPage (printf \"/%s/%s\" $type $name) }} \u003cli\u003e \u003ca data-weight=\"{{$count}}\" href=\"{{ .Permalink }}\"\u003e{{ .Name }} \u003csup\u003e\u003cstrong\u003e\u003csup\u003e{{ $count }}\u003c/sup\u003e\u003c/strong\u003e\u003c/sup\u003e \u003c/a\u003e \u003c/li\u003e {{- end }} {{- end }} \u003c/ul\u003e ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:2:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#添加权重"},{"categories":["关于Hugo的一些设置"],"content":" 字体大小按权重显示assets/css/common/terms.css中设计： .terms-tags a[data-weight=\"1\"] { --size: 1; } .terms-tags a[data-weight=\"2\"] { --size: 2; } .terms-tags a[data-weight=\"3\"] { --size: 3; } .terms-tags a[data-weight=\"4\"] { --size: 4; } .terms-tags a[data-weight=\"5\"] { --size: 5; } .terms-tags a[data-weight=\"6\"] { --size: 6; } .terms-tags a[data-weight=\"7\"] { --size: 7; } .terms-tags a[data-weight=\"8\"] { --size: 8; } .terms-tags a[data-weight=\"9\"] { --size: 9; } .terms-tags a { --size: 4; font-size: calc(var(--size) * 0.25rem + 1rem); /* font-size: 1.4rem; */ display: block; padding: 3px 10px; background: var(--tertiary); border-radius: 6px; transition: transform 0.1s; } ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:3:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#字体大小按权重显示"},{"categories":["关于Hugo的一些设置"],"content":" css伪随机字体色彩assets/css/common/terms.css中 .terms-tags li:nth-child(2n+1) a {color:#f7a400;} .terms-tags li:nth-child(3n+1) a {color:#3a9efd;} .terms-tags li:nth-child(4n+1) a {color:#3e4491;} .terms-tags li:nth-child(5n+1) a {color:#3e4491;} .terms-tags li:nth-child(6n+1) a {color:#3e4491;} 当然了也可以在js里搓qwq，可以参考这篇 ","date":"2023-12-13","objectID":"/posts/beautify_site_tags/:4:0","series":null,"tags":["CSS","美化"],"title":"【网站美化】标签美化","uri":"/posts/beautify_site_tags/#css伪随机字体色彩"},{"categories":["在学算法的日子里"],"content":"前言点评：本次题目难度不高 ","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#"},{"categories":["在学算法的日子里"],"content":" A 跳石头 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#a-跳石头"},{"categories":["在学算法的日子里"],"content":" [NOIP2015 提高组] 跳石头","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#noip2015-提高组-跳石头"},{"categories":["在学算法的日子里"],"content":" 题目背景NOIP2015 Day2T1 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目背景"},{"categories":["在学算法的日子里"],"content":" 题目描述一年一度的“跳石头”比赛又要开始了！ 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N \\geq M \\geq 0$。 接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i,( 0 \u003c D_i \u003c L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式"},{"categories":["在学算法的日子里"],"content":" 输出格式一个整数，即最短跳跃距离的最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 25 5 2 2 11 14 17 21 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 4 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示"},{"categories":["在学算法的日子里"],"content":" 输入输出样例 1 说明将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入输出样例-1-说明"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于 $20%$的数据，$0 \\le M \\le N \\le 10$。 对于 $50%$ 的数据，$0 \\le M \\le N \\le 100$。 对于 $100%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \\le 10^9$。 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#数据规模与约定"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码"},{"categories":["在学算法的日子里"],"content":" B Secret Sport ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#b-secret-sport"},{"categories":["在学算法的日子里"],"content":" Secret Sport","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#secret-sport"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题面翻译"},{"categories":["在学算法的日子里"],"content":" 题目大意A,B两人玩游戏，游戏规则如下： 整场游戏有多轮，每轮游戏先胜 $X$ 局的人获胜，每场游戏先胜 $Y$ 局的人获胜。 你在场边观看了比赛，但是你忘记了 $X$ 和 $Y$ ，只记得总共比了 $1 \\le n \\le 20$ 局，和每局获胜的人，请判断谁获胜了。如果A获胜，输出 A ，如果B获胜，输出 B ，如果都有可能，输出 ? 。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目大意"},{"categories":["在学算法的日子里"],"content":" 题目描述Let’s consider a game in which two players, A and B, participate. This game is characterized by two positive integers, $ X $ and $ Y $ . The game consists of sets, and each set consists of plays. In each play, exactly one of the players, either A or B, wins. A set ends exactly when one of the players reaches $ X $ wins in the plays of that set. This player is declared the winner of the set. The players play sets until one of them reaches $ Y $ wins in the sets. After that, the game ends, and this player is declared the winner of the entire game. You have just watched a game but didn’t notice who was declared the winner. You remember that during the game, $ n $ plays were played, and you know which player won each play. However, you do not know the values of $ X $ and $ Y $ . Based on the available information, determine who won the entire game — A or B. If there is not enough information to determine the winner, you should also report it. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-1"},{"categories":["在学算法的日子里"],"content":" 输入格式Each test contains multiple test cases. The first line contains a single integer $ t $ $ (1 \\leq t \\leq 10^4) $ - the number of test cases. The description of the test cases follows. The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq 20) $ - the number of plays played during the game. The second line of each test case contains a string $ s $ of length $ n $ , consisting of characters $ \\texttt{A} $ and $ \\texttt{B} $ . If $ s_i = \\texttt{A} $ , it means that player A won the $ i $ -th play. If $ s_i = \\texttt{B} $ , it means that player B won the $ i $ -th play. It is guaranteed that the given sequence of plays corresponds to at least one valid game scenario, for some values of $ X $ and $ Y $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-1"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, output: $ \\texttt{A} $ — if player A is guaranteed to be the winner of the game. $ \\texttt{B} $ — if player B is guaranteed to be the winner of the game. $ \\texttt{?} $ — if it is impossible to determine the winner of the game. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-1"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 7 5 ABBAA 3 BBB 7 BBAAABA 20 AAAAAAAABBBAABBBBBAB 1 A 13 AAAABABBABBAB 7 BBBAAAA ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 A B A B A B A ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-1"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case, the game could have been played with parameters $ X = 3 $ , $ Y = 1 $ . The game consisted of $ 1 $ set, in which player A won, as they won the first $ 3 $ plays. In this scenario, player A is the winner. The game could also have been played with parameters $ X = 1 $ , $ Y = 3 $ . It can be shown that there are no such $ X $ and $ Y $ values for which player B would be the winner. In the second test case, player B won all the plays. It can be easily shown that in this case, player B is guaranteed to be the winner of the game. In the fourth test case, the game could have been played with parameters $ X = 3 $ , $ Y = 3 $ : In the first set, $ 3 $ plays were played: AAA. Player A is declared the winner of the set. In the second set, $ 3 $ plays were played: AAA. Player A is declared the winner of the set. In the third set, $ 5 $ plays were played: AABBB. Player B is declared the winner of the set. In the fourth set, $ 5 $ plays were played: AABBB. Player B is declared the winner of the set. In the fifth set, $ 4 $ plays were played: BBAB. Player B is declared the winner of the set. In total, player B was the first player to win $ 3 $ sets. They are declared the winner of the game. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-1"},{"categories":["在学算法的日子里"],"content":" 分析根据题意，其实每次都是赛到出现结果了才结束，所以每次的最后一局的胜负其实就是整场游戏的胜负。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-1"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 3e4 + 20; int p[maxn]; int n; string s; void solve() { cin \u003e\u003e n \u003e\u003e s; cout \u003c\u003c s.back() \u003c\u003c endl; } int main() { int t;cin \u003e\u003e t; while(t--) solve(); return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-1"},{"categories":["在学算法的日子里"],"content":" C 众数 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#c-众数"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 初赛] 众数","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-初赛-众数"},{"categories":["在学算法的日子里"],"content":" 题目描述你有若干个 $[1,n]$ 内的正整数：对于 $1 \\le i \\le n$，你有 $a_i$ 个整数 $i$。设 $S = \\sum_{i=1}^n a_i$。 对于一个序列 $p_1,p_2,\\cdots,p_l$，定义其众数 $\\text{maj}(p_1,p_2,\\cdots,p_l)$ 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。 现在你需要把这 $S$ 个数排成一个序列 $b_1,b_2,\\cdots,b_S$，使得 $\\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i)$ 最大。输出该最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-2"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行一个整数 $n$，表示值域。 接下来一行 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，表示每种数的个数。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-2"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一行一个正整数表示 $\\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i)$ 的最大值。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-2"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 1 3 2 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 17 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-2"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-2"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例解释-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#数据范围"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1一个达到最大值的序列为 $(3,2,3,1,2,2)$。 数据范围对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目来源"},{"categories":["在学算法的日子里"],"content":" 分析贪心，要让较大的数作为众数的次数最多。 构造排列时按照n~1的顺序排下去，每次先排列尽量满足上述想法的数。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-2"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 1e5 + 20; ll a[maxn], prea[maxn]; int main() { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; } ll num = 1; ll ans = 0; // prea[a[i]]:众数数量为a[i]时，当前众数i作为众数对结果的贡献 for (int i = n;i \u003e 0;i--) { while (num \u003c= a[i]) { prea[num] = prea[num - 1] + i; num++; } ans += prea[a[i]]; } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-2"},{"categories":["在学算法的日子里"],"content":" D 大纲 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#d-大纲"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 大纲","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-决赛-大纲"},{"categories":["在学算法的日子里"],"content":" 题目描述小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。 ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。 知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。依赖关系不具有传递性。 你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立： 每个知识点的难度都是非负整数； 对于每个依赖其他知识点的知识点 $x$，设 $\\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\\max_x$，否则为 $\\max_x+1$。对于不依赖其他知识点的知识点，没有其他限制。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-3"},{"categories":["在学算法的日子里"],"content":" 输入格式本题有多组测试数据。第一行一个整数 $T$ 表示测试数据组数，接下来依次读入每组测试数据。 对于每组测试数据， 第一行一个整数 $n$ 表示知识点数量。 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，描述每个知识点的难度。若 $a_i = -1$ 表示知识点 $i$ 未确定难度，否则知识点 $i$ 的难度确定为 $a_i$。 接下来 $n-1$ 行每行两个整数 $u,v$，表示依赖关系构成的外向树中的一条有向边。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-3"},{"categories":["在学算法的日子里"],"content":" 输出格式对于每组测试数据输出一行：若难度是合理的，输出 Reasonable，否则输出 Unreasonable。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-3"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 3 0 -1 0 1 2 2 3 3 0 -1 0 1 2 1 3 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 Reasonable Unreasonable ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-3"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-3"},{"categories":["在学算法的日子里"],"content":" 样例 1 解释对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。 对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-解释"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于所有测试数据，$1 \\le T \\le 10^5$，$2 \\le n \\le 10^5$，$-1 \\le a_i \\le 10^9$，$1 \\le u,v \\le n$。 保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \\times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#数据规模与约定-1"},{"categories":["在学算法的日子里"],"content":" 后记大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。 ","date":"2023-12-02","objectID":"/posts/training0/:5:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#后记"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目来源-1"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:5:5","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-3"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:5:6","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-3"},{"categories":["在学算法的日子里"],"content":" E Chip and Ribbon ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#e-chip-and-ribbon"},{"categories":["在学算法的日子里"],"content":" Chip and Ribbon","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#chip-and-ribbon"},{"categories":["在学算法的日子里"],"content":" 题面翻译每次可以在一段长度为 $n$，初始值都为 $0$ 的序列中选取一段连续区间，并将区间内所有元素加 $1$，求最少操作数使得该序列与题目所给的序列所有元素相同，输出最少操作数减 $1$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题面翻译-1"},{"categories":["在学算法的日子里"],"content":" 题目描述There is a ribbon divided into $ n $ cells, numbered from $ 1 $ to $ n $ from left to right. Initially, an integer $ 0 $ is written in each cell. Monocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the $ 1 $ -st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions: move the chip to the next cell (i. e. if the chip is in the cell $ i $ , it is moved to the cell $ i+1 $ ). This action is impossible if the chip is in the last cell; choose any cell $ x $ and teleport the chip into that cell. It is possible to choose the cell where the chip is currently located. At the end of each turn, the integer written in the cell with the chip is increased by $ 1 $ . Monocarp’s goal is to make some turns so that the $ 1 $ -st cell contains the integer $ c_1 $ , the $ 2 $ -nd cell contains the integer $ c_2 $ , …, the $ n $ -th cell contains the integer $ c_n $ . He wants to teleport the chip as few times as possible. Help Monocarp calculate the minimum number of times he has to teleport the chip. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-4"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains one integer $ t $ ( $ 1 \\le t \\le 10^4 $ ) — the number of test cases. Each test case consists of two lines: the first line contains one integer $ n $ ( $ 1 \\le n \\le 2 \\cdot 10^5 $ ); the second line contains $ n $ integers $ c_1, c_2, \\dots, c_n $ ( $ 0 \\le c_i \\le 10^9 $ ; $ c_1 \\ge 1 $ ). It can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence $ c_1, c_2, \\dots, c_n $ . Additional constraint on the input: the sum of values of $ n $ over all test cases does not exceed $ 2 \\cdot 10^5 $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-4"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, print one integer — the minimum number of times Monocarp has to teleport the chip. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-4"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 4 4 1 2 2 1 5 1 0 1 0 1 5 5 4 3 2 1 1 12 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-4"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 2 4 11 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-4"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case of the example, Monocarp can perform the turns as follows: place the chip in the $ 1 $ -st cell; the numbers in the cells are $ [1, 0, 0, 0] $ ; move the chip to the next ( $ 2 $ -nd) cell; the numbers in the cells are $ [1, 1, 0, 0] $ ; move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 1, 1, 0] $ ; teleport the chip to the $ 2 $ -nd cell; the numbers in the cells are $ [1, 2, 1, 0] $ ; move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $ [1, 2, 2, 0] $ ; move the chip to the next ( $ 4 $ -th) cell; the numbers in the cells are $ [1, 2, 2, 1] $ . ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-4"},{"categories":["在学算法的日子里"],"content":" 分析令连续的下一cell内数字加一的操作数是不限的，那么我们的目的就变成了画多少条这样的连续的“线”，能达到最终的目的，示意图如下： 在代码实现的时候，只要后一位的高度高于前一位，那么就需要增加：后一位高度-前一位高度 这么多的线，参考代码如下： ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-4"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 2e5 + 20; ll a[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; ll ans = 0; for (int i = 1;i \u003c= n;i++) { cin \u003e\u003e a[i]; if (a[i] \u003e a[i - 1]) ans += a[i] - a[i - 1]; } cout \u003c\u003c ans - 1 \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-4"},{"categories":["在学算法的日子里"],"content":" F 着色 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#f-着色"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 着色","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-决赛-着色"},{"categories":["在学算法的日子里"],"content":" 题目背景远古的笔迹，远古的乐音，远古的历史，远古的 $K_{1000}$，若无人问津，便悄然褪色…… ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目背景-1"},{"categories":["在学算法的日子里"],"content":" 题目描述给出一个 $n$ 个节点的无向完全图，你需要给每条边标上一个 $0 \\sim 9$ 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-5"},{"categories":["在学算法的日子里"],"content":" 输入格式输入仅一行一个整数 $n$ 表示图的节点数。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-5"},{"categories":["在学算法的日子里"],"content":" 输出格式如果不存在方案，输出一行一个整数 -1。否则输出 $(n-1)$ 行，第 $i$ 行 $(n-i)$ 个字符，第 $i$ 行的第 $j$ 个字符表示 $(i,i+j)$ 的标号。若有多个方案，输出任意一个即可。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-5"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 4 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-5"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 012 34 5 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-5"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-5"},{"categories":["在学算法的日子里"],"content":" 数据规模与约定对于所有测试数据，$2 \\le n \\le 1000$。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#数据规模与约定-2"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目来源-2"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-5"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-5"},{"categories":["在学算法的日子里"],"content":" G Treasure Chest ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#g-treasure-chest"},{"categories":["在学算法的日子里"],"content":" Treasure Chest","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#treasure-chest"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题面翻译-2"},{"categories":["在学算法的日子里"],"content":" 题目描述给你一个数轴，一开始你的位置为 $0$，箱子在 $x$ 处，钥匙在 $y$ 处，$x\\neq y$。你需要通过一些操作打开宝箱。 当位置为 $i$ 时，你能执行以下操作： 花费 $1$ 秒，走向 $i+1$ 或 $i-1$； 花费 $0$ 秒，拿起 $i$ 处的钥匙或箱子，如果此处有的话； 花费 $0$ 秒，在 $i$ 处放下箱子； 花费 $0$ 秒，打开宝箱，如果箱子在 $i$ 处且你拿着钥匙的话。 另外给出限制：因为箱子很重，所以在整个过程中，扛着箱子的时间不得超过 $k$ 秒（放下再拿起箱子不会使其重置）。 现在给定 $x,y,k$，请问你打开箱子的最短用时为多少？ 每个测试点采用多组数据测试。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-6"},{"categories":["在学算法的日子里"],"content":" 输入格式第一行一个整数 $t\\space(1\\le t\\le 100)$，表示数据组数。 对于每组数据：唯一一行三个整数 $x,y,k\\space(1\\le x,y\\le 100,x\\neq y,0\\le k\\le 100)$，分别表示初始时箱子的位置，钥匙的位置和你扛着箱子的最大时长。 ","date":"2023-12-02","objectID":"/posts/training0/:1:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-6"},{"categories":["在学算法的日子里"],"content":" 输出格式共 $t$ 行，第 $i$ 行一个整数表示第 $i$ 组数据的答案。 ","date":"2023-12-02","objectID":"/posts/training0/:1:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-6"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#说明提示"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#数据范围与约定"},{"categories":["在学算法的日子里"],"content":" 说明/提示 数据范围与约定$1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$ 样例解释对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。 花费 $5$ 秒走到 $5$, 花费 $0$ 秒拿起箱子， 花费 $2$ 秒走到 $7$， 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$ 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须： 花费 $5$ 秒走到 $5$ 并扛起箱子； 花费 $2$ 秒走到 $7$； 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子； 花费 $1$ 秒走到 $8$ 并捡起钥匙； 花费 $1$ 秒再走到 $7$ 并打开箱子。 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例解释"},{"categories":["在学算法的日子里"],"content":" 题目描述Monocarp has found a treasure map. The map represents the treasure location as an OX axis. Monocarp is at $ 0 $ , the treasure chest is at $ x $ , the key to the chest is at $ y $ . Obviously, Monocarp wants to open the chest. He can perform the following actions: go $ 1 $ to the left or $ 1 $ to the right (spending $ 1 $ second); pick the key or the chest up if he is in the same point as that object (spending $ 0 $ seconds); put the chest down in his current point (spending $ 0 $ seconds); open the chest if he’s in the same point as the chest and has picked the key up (spending $ 0 $ seconds). Monocarp can carry the chest, but the chest is pretty heavy. He knows that he can carry it for at most $ k $ seconds in total (putting it down and picking it back up doesn’t reset his stamina). What’s the smallest time required for Monocarp to open the chest? ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-7"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the number of testcases. The only line of each testcase contains three integers $ x, y $ and $ k $ ( $ 1 \\le x, y \\le 100 $ ; $ x \\neq y $ ; $ 0 \\le k \\le 100 $ ) — the initial point of the chest, the point where the key is located, and the maximum time Monocarp can carry the chest for. ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-7"},{"categories":["在学算法的日子里"],"content":" 输出格式For each testcase, print a single integer — the smallest time required for Monocarp to open the chest. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-7"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 5 7 2 10 5 0 5 8 2 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-6"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 7 10 9 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-6"},{"categories":["在学算法的日子里"],"content":" 提示In the first testcase, Monocarp can open the chest in $ 7 $ seconds with the following sequence of moves: go $ 5 $ times to the right ( $ 5 $ seconds); pick up the chest ( $ 0 $ seconds); go $ 2 $ times to the right ( $ 2 $ seconds); pick up the key ( $ 0 $ seconds); put the chest down ( $ 0 $ seconds); open the chest ( $ 0 $ seconds). He only carries the chest for $ 2 $ seconds, which he has the stamina for. In the second testcase, Monocarp can pick up the key on his way to the chest. In the third testcase, Monocarp can’t use the strategy from the first testcase because he would have to carry the chest for $ 3 $ seconds, while he only has the stamina for $ 2 $ seconds. Thus, he carries the chest to $ 7 $ , puts it down, moves $ 1 $ to the right to pick up the key and returns $ 1 $ left to open the chest. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-6"},{"categories":["在学算法的日子里"],"content":" 分析分类讨论，要么在向右移动的时候就能把key带到chest的位置或者把chest带到key的位置，要么就把chest向右移动k个位置(离key最近)，然后拿key再折返回到chest位置。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-6"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int main() { int t;cin \u003e\u003e t; while (t--) { int x, y, k;cin \u003e\u003e x \u003e\u003e y \u003e\u003e k; int ans; if (y \u003c= x)ans = x; else { if (y \u003c= x + k)ans = y; else { x += k; ans = y + (y - x); } } cout \u003c\u003c ans \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-6"},{"categories":["在学算法的日子里"],"content":" H 烂柯杯 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#h-烂柯杯"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 烂柯杯","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-决赛-烂柯杯"},{"categories":["在学算法的日子里"],"content":" 题目背景却说庞统迤逦前进，抬头见两山逼窄，树木丛杂；又值夏末秋初，枝叶茂盛。庞统心下甚疑，勒住马问：“此处是何地？”数内有新降军士，指道：“此处地名落凤坡。”庞统惊曰：“吾道号凤雏，此处名落凤坡，不利于吾。”令后军疾退。只听山坡前一声炮响，箭如飞蝗，只望骑白马者射来。可怜庞统竟死于乱箭之下。时年止三十六岁。后人有诗叹曰：“古岘相连紫翠堆，士元有宅傍山隈。儿童惯识呼鸠曲，闾巷曾闻展骥才。预计三分平刻削，长驱万里独徘徊。谁知天狗流星坠，不使将军衣锦回。”先是东南有童谣云：“一凤并一龙，相将到蜀中。才到半路里，凤死落坡东。风送雨，雨随风，隆汉兴时蜀道通，蜀道通时只有龙。” ——《三国演义》第六十三回：诸葛亮痛哭庞统 张翼德义释严颜 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目背景-2"},{"categories":["在学算法的日子里"],"content":" 题目描述$2023$ 年 $5$ 月 $4$ 日 $ \\sim 9$ 日，第一届“衢州烂柯杯”世界围棋公开赛本赛第一阶段的赛程在衢州顺利进行。作为疫情后第一场全程线下进行的世界围棋大赛，也是目前中国主办的唯一一项每年一届的世界围棋大赛，无疑引起了国内外广大围棋爱好者的广泛关注。 “羽客一枰无复见，青山留得烂柯名。”衢州是围棋圣地，流传着“王质遇仙”的故事，境内的烂柯山也因此闻名于天下。正因为此，“烂柯”也是围棋的别称之一，从古至今的许多围棋故事、书籍、弈谱等，也有不少化用了“烂柯”的典故，或以“烂柯”定名。 此次“烂柯杯”世界围棋大赛，是在保留原有的“烂柯杯”中国围棋冠军赛的基础上，创办的一项崭新的世界性围棋赛事，吸引了全世界围棋高手前来参加。其中，中国队派出了柯洁、辜梓豪、王星昊、丁浩、李钦诚等 $15$ 员大将参赛，韩国队 $8$ 人，日本队 $5$ 人，还有 $2$ 位棋手来自中国台湾、 $2$ 位棋手来自欧美地区。可以说，全世界最顶尖的围棋高手悉数相聚于此。 随着科技的发展，人工智能的巨大技术进步和网络传媒的全面普及，围棋这项来自中国的传统运动正在焕发出新的活力。在网络上，人们随时可以看到最新的赛事直播，以及人工智能的精准分析和各大围棋高手的细致解读。资源获取的便捷性使得人们对围棋的关注度空前上升，围棋不再是只有少部分懂棋的爱好者才能欣赏的“小众游戏”；围棋高手也不再只是一个神秘的身份，越来越多的围棋高手开始在网络上与棋迷近距离互动，普及围棋知识，讲解最新对局，赢得了一致好评。正如这次参赛的选手中，有一位棋手同时也是粉丝数达 $150$ 多万的网红主播，甚至还有一位棋手是一家网红餐厅的老板。 我们今天故事的主角正是这样一位有着传奇色彩的人物。作为一名清华大学本科在读的学生，同时也是一名顶尖围棋高手，他的一举一动无疑都会引起巨大的关注。此次他参加“烂柯杯”比赛，众人无一例外看好他的比赛前景，尤其是现在韩国围棋”第一人“申真谞九段的巅峰时期，他也被无数中国棋迷寄托以”狙击‘小申’“的重任。$5$ 月 $4$ 日抽签过后，没有任何人会怀疑他能不能赢下 $5$ 日的第一轮比赛，一些围棋高手更是直接放出了”大胜，不可能失败“的预言。 然而，$5$ 月 $5$ 日的比赛还是爆出了惊天大冷门。他在已经胜券在握，AI 胜率达到 $99%$ 的关头，接连选择了“弹幕最多的下法”，最终因为几招致命的失误葬送好局，落败于中国台湾棋手赖均辅八段。赛后，人们在震惊的同时，纷纷猜测本局失利的原因。有人说，他的状态低迷在前些年早已有所体现，“当你在 XX 的时候，小申在下棋”成了调侃他与申真谞战绩差距的一句名言；有人说，他在比赛之前的 $12$ 连胜战绩反而使他心态紧张，从而犯了优势下容易大意的老毛病；也有人拿出了“落凤坡”的典故，以证明他或许命中注定与“烂柯杯”八字不合……但或许，这样的变幻莫测和不可预料性，正是围棋的魅力所在。 请你根据以上所有信息，猜测本文的主角是谁。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-8"},{"categories":["在学算法的日子里"],"content":" 输入格式无输入。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-8"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一个由小写字母组成的字符串，表示上文中提到的主角的名字全拼。如若答案是马云，应当输出 mayun。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-8"},{"categories":["在学算法的日子里"],"content":" 提示","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-7"},{"categories":["在学算法的日子里"],"content":" 提示主角的名字在题面中已经有所提及。 题面中一些看似无厘头的信息实际上是有价值的。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-8"},{"categories":["在学算法的日子里"],"content":" 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目来源-3"},{"categories":["在学算法的日子里"],"content":" 分析是签到题，输出\"kejie\"即可。 ","date":"2023-12-02","objectID":"/posts/training0/:5:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-7"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int main() { cout \u003c\u003c \"kejie\"; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-7"},{"categories":["在学算法的日子里"],"content":" I 总投票数 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#i-总投票数"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 决赛] 总投票数","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-决赛-总投票数"},{"categories":["在学算法的日子里"],"content":" 题目背景各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家： 非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！ 现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。 停止运营相关时间表如下： …… ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目背景-3"},{"categories":["在学算法的日子里"],"content":" 题目描述在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。 作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$ 个选项的玩家比例为 $P_i$（$1\\le i\\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有 $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有 $$ P_i-\\frac{1}{2}\\times 10^{-L}\\le\\frac{D_i}{K}\u003c P_i+\\frac{1}{2}\\times 10^{-L} $$ 显然，所有的 $D_i$ 必须是非负整数，而 $K=\\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足 $D_i$ 有非负整数解的最小的总投票数 $K$。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-9"},{"categories":["在学算法的日子里"],"content":" 输入格式输入的第一行包含一个正整数 $N$，表示投票的选项总数。保证 $1\\le N\\le 100$。 接下来 $N$ 行，每行包括一个 $[0, 1]$ 中的实数 $P_i$，表示选择第 $i$ 个选项的玩家比例。保证 $\\sum_{i=1}^N P_i =1$，所有 $P_i$ 均保留到小数点后第 $L$ 位，且 $1\\le L\\le 6$。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-9"},{"categories":["在学算法的日子里"],"content":" 输出格式输出一个正整数，表示满足要求的最小总投票数 $K$。 ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-9"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 0.166667 0.333333 0.500000 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-7"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 6 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-7"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-2"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 7 0.041096 0.109589 0.109589 0.164384 0.301370 0.068493 0.205479 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-2"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 73 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-2"},{"categories":["在学算法的日子里"],"content":" 样例 #3","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-3"},{"categories":["在学算法的日子里"],"content":" 样例输入 #3 13 0.00155 0.03876 0.01584 0.05189 0.08099 0.06825 0.15658 0.10404 0.02640 0.14332 0.12941 0.15529 0.02768 ","date":"2023-12-02","objectID":"/posts/training0/:7:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-3"},{"categories":["在学算法的日子里"],"content":" 样例输出 #3 7766 ","date":"2023-12-02","objectID":"/posts/training0/:7:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-3"},{"categories":["在学算法的日子里"],"content":" 提示【样例解释 #1】 最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。 【样例解释 #2】 最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。 【样例解释 #3】 最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215$。 【数据范围】 对于所有测试数据，$1\\le N\\le 100$，$0\\le P_i\\le 1$，$\\sum_{i=1}^N P_i=1$，且 $P_i$ 最多统一保留到小数点后 $6$ 位。 【题目来源】 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:8:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-9"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:8:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-8"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:8:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-8"},{"categories":["在学算法的日子里"],"content":" J Points and Minimum Distance ","date":"2023-12-02","objectID":"/posts/training0/:9:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#j-points-and-minimum-distance"},{"categories":["在学算法的日子里"],"content":" Points and Minimum Distance","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#points-and-minimum-distance"},{"categories":["在学算法的日子里"],"content":" 题面翻译给定长度为 $2n$ 的序列 $a$，你需要把这些数分为 $n$ 对，得到 $n$ 个坐标轴上的点。$a$ 中的每个数都要是某一个点的 $x$ 或 $y$ 坐标。注意有些点可能会重合。 之后，你可以选择从一个点出发，选择一条路径走过所有 $n$ 个点至少一次，在某个点处停下。 你需要求出路径总长度的最小值。本题中两点间距离为曼哈顿距离，即 $(x_1,y_1)$ 和 $(x_2,y_2)$ 间距离为 $|x_1-x_2|+|y_1-y_2|$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题面翻译-3"},{"categories":["在学算法的日子里"],"content":" 题目描述You are given a sequence of integers $ a $ of length $ 2n $ . You have to split these $ 2n $ integers into $ n $ pairs; each pair will represent the coordinates of a point on a plane. Each number from the sequence $ a $ should become the $ x $ or $ y $ coordinate of exactly one point. Note that some points can be equal. After the points are formed, you have to choose a path $ s $ that starts from one of these points, ends at one of these points, and visits all $ n $ points at least once. The length of path $ s $ is the sum of distances between all adjacent points on the path. In this problem, the distance between two points $ (x_1, y_1) $ and $ (x_2, y_2) $ is defined as $ |x_1-x_2| + |y_1-y_2| $ . Your task is to form $ n $ points and choose a path $ s $ in such a way that the length of path $ s $ is minimized. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-10"},{"categories":["在学算法的日子里"],"content":" 输入格式The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the number of testcases. The first line of each testcase contains a single integer $ n $ ( $ 2 \\le n \\le 100 $ ) — the number of points to be formed. The next line contains $ 2n $ integers $ a_1, a_2, \\dots, a_{2n} $ ( $ 0 \\le a_i \\le 1,000 $ ) — the description of the sequence $ a $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-10"},{"categories":["在学算法的日子里"],"content":" 输出格式For each testcase, print the minimum possible length of path $ s $ in the first line. In the $ i $ -th of the following $ n $ lines, print two integers $ x_i $ and $ y_i $ — the coordinates of the point that needs to be visited at the $ i $ -th position. If there are multiple answers, print any of them. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-10"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 2 2 15 1 10 5 3 10 30 20 20 30 10 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-8"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 9 10 1 15 5 20 20 20 10 30 10 30 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-8"},{"categories":["在学算法的日子里"],"content":" 提示In the first testcase, for instance, you can form points $ (10, 1) $ and $ (15, 5) $ and start the path $ s $ from the first point and end it at the second point. Then the length of the path will be $ |10 - 15| + |1 - 5| = 5 + 4 = 9 $ . In the second testcase, you can form points $ (20, 20) $ , $ (10, 30) $ , and $ (10, 30) $ , and visit them in that exact order. Then the length of the path will be $ |20 - 10| + |20 - 30| + |10 - 10| + |30 - 30| = 10 + 10 + 0 + 0 = 20 $ . ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-10"},{"categories":["在学算法的日子里"],"content":" 分析构造题，根据题意可以推断，ans只分别与x集合的差值和、y集合差值和有关。显然，（大数-小数）+（大数-小数）的结果劣于（大数-大数）+（小数-小数）。 故此题，在进行排列后按序先分配x再分配y，直接统计x有序集合与y有序集合的差值即可（注意结果除去x，y交界的一对差）。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-9"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; int a[maxn]; int main() { int t;cin \u003e\u003e t; while (t--) { int n;cin \u003e\u003e n; for (int i = 1;i \u003c= 2 * n;i++) cin \u003e\u003e a[i]; sort(a + 1, a + 2 * n + 1); int ans = 0; for (int i = 2;i \u003c= 2 * n;i++) { ans += a[i] - a[i - 1]; } ans -= a[n + 1] - a[n]; cout \u003c\u003c ans \u003c\u003c endl; for (int i = 1;i \u003c= n;i++) cout \u003c\u003c a[i] \u003c\u003c \" \" \u003c\u003c a[2 * n + 1 - i] \u003c\u003c endl; } return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-9"},{"categories":["在学算法的日子里"],"content":" K 速战速决 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#k-速战速决"},{"categories":["在学算法的日子里"],"content":" [THUPC 2023 初赛] 速战速决","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#thupc-2023-初赛-速战速决"},{"categories":["在学算法的日子里"],"content":" 题目描述小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同： 有 $2n$ 张牌，其中对于整数 $1 \\le i \\le n$，牌面为 $i$ 的牌恰好有 $2$ 张。 游戏开始时，小 I 和小 J 各拿其中 $n$ 张牌组成双方的初始手牌。 维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作： 将手牌中的一张牌放在公共牌堆顶； 若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中； 若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。 小 J 是扑克萌新，所以会按照以下策略行动： 维护一个队列，初始将 $n$ 张手牌按照一定顺序放入队列中； 每次行动时，将队列开头的牌放在公共牌堆顶； 若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。 小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用最少的行动次数获胜，但他也是扑克萌新。所以给定小 J 队列中的 $n$ 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-11"},{"categories":["在学算法的日子里"],"content":" 输入格式每组数据的第一行一个整数 $n$ 表示牌面的种数。 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，从队头到队尾的顺序依次描述小 J 队列中的牌。 得到小 J 的 $n$ 张手牌也就得到了小 I 的 $n$ 张手牌，因此不会输入小 I 的手牌。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-11"},{"categories":["在学算法的日子里"],"content":" 输出格式如果小 I 不可能获胜，只需要输出一个整数 -1；否则第一行输出一个整数 $s$，表示你给出的策略中小 I 的行动次数。接下来一行 $s$ 个整数，依次描述每次行动时小 I 从手牌中放入公共牌堆的牌的牌面，两个数之间以一个空格分隔。注意你给出的策略要满足 $s$ 最小。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-11"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 3 1 3 3 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-9"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 3 2 1 2 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-9"},{"categories":["在学算法的日子里"],"content":" 样例 #2","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输入 #2 1 1 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-2-1"},{"categories":["在学算法的日子里"],"content":" 样例输出 #2 -1 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-2-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-11"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例解释-1-1"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#子任务"},{"categories":["在学算法的日子里"],"content":" 提示 样例解释 1 子任务对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le n$，且每个整数在序列 $a$ 中至多出现两次。 题目来源来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。 ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目来源-4"},{"categories":["在学算法的日子里"],"content":" 分析","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-10"},{"categories":["在学算法的日子里"],"content":" 参考代码 ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-10"},{"categories":["在学算法的日子里"],"content":" L 滑雪 ","date":"2023-12-02","objectID":"/posts/training0/:7:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#l-滑雪"},{"categories":["在学算法的日子里"],"content":" [SHOI2002] 滑雪","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#shoi2002-滑雪"},{"categories":["在学算法的日子里"],"content":" 题目描述Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然 $25$－$24$－$23$－$\\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。 ","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-12"},{"categories":["在学算法的日子里"],"content":" 输入格式输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。 ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-12"},{"categories":["在学算法的日子里"],"content":" 输出格式输出区域中最长滑坡的长度。 ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-12"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 5 5 1 2 3 4 5 16 17 18 19 6 15 24 25 20 7 14 23 22 21 8 13 12 11 10 9 ","date":"2023-12-02","objectID":"/posts/training0/:4:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-10"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 25 ","date":"2023-12-02","objectID":"/posts/training0/:4:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-10"},{"categories":["在学算法的日子里"],"content":" 提示对于 $100%$ 的数据，$1\\leq R,C\\leq 100$。 ","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-12"},{"categories":["在学算法的日子里"],"content":" 分析优先队列+线性dp 优先队列内排序按照高度从小到大，依次取出队首的点（高度最低的点），记为pos，更新从低处到pos的最长路径。 状态转移： $$ dp[xi][yi]=max(dp[xi][yi],dp[xi+1][yi]+1)\\ 其他三个点同理 $$ 同时记录最长的路径即可。 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-11"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long ll; const int maxn = 120; ll rec[maxn][maxn]; ll dp[maxn][maxn]; struct POS { ll height; int x, y; POS(int hi, int xi, int yi) :height(hi), x(xi), y(yi) {} bool operator\u003c(const POS\u0026 P)const { return P.height \u003c height; } }; int main() { int r, c;cin \u003e\u003e r \u003e\u003e c; priority_queue\u003cPOS\u003epos; for (int i = 1;i \u003c= r;i++) { for (int j = 1;j \u003c= c;j++) { ll h;cin \u003e\u003e h; rec[i][j] = h; pos.push(POS(h, i, j)); dp[i][j] = 1; } } ll ans = 1; while (!pos.empty()) { auto tp = pos.top(); int xi = tp.x, yi = tp.y;ll hi = tp.height;pos.pop(); if (rec[xi + 1][yi] \u003c hi) { dp[xi][yi] = max(dp[xi + 1][yi] + 1, dp[xi][yi]); } if (rec[xi - 1][yi] \u003c hi) { dp[xi][yi] = max(dp[xi - 1][yi] + 1, dp[xi][yi]); } if (rec[xi][yi + 1] \u003c hi) { dp[xi][yi] = max(dp[xi][yi + 1] + 1, dp[xi][yi]); } if (rec[xi][yi - 1] \u003c hi) { dp[xi][yi] = max(dp[xi][yi - 1] + 1, dp[xi][yi]); } ans = max(ans, dp[xi][yi]); } cout \u003c\u003c ans \u003c\u003c endl; return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-11"},{"categories":["在学算法的日子里"],"content":" M Two Out of Three ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#m-two-out-of-three"},{"categories":["在学算法的日子里"],"content":" Two Out of Three","date":"2023-12-02","objectID":"/posts/training0/:0:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#two-out-of-three"},{"categories":["在学算法的日子里"],"content":" 题面翻译","date":"2023-12-02","objectID":"/posts/training0/:1:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题面翻译-4"},{"categories":["在学算法的日子里"],"content":" 题目描述给定一个数组 $a_1, a_2, …, a_n$。你需要找到一个数组 $b_1$, $b_2$, …, $b_n$，其中包含数字 $1, 2, 3$，使得以下三个条件中恰好有两个条件被满足： 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=2$。 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=3$。 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=2,b_j=3$。 如果不存在这样的数组 $b$，请报告不可以。 ","date":"2023-12-02","objectID":"/posts/training0/:1:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-13"},{"categories":["在学算法的日子里"],"content":" 输入格式每个测试点多测。第一行输入一个整数 $t$，表示数据组数。对于每一组数据： 第一行输入一个整数 $n$ $(1\\le n\\le 100)$，表示数组 $a$ 的长度。 第二行读入 $n$ 个整数 $a_1,a_2,…,a_n$ $(1\\le a_i\\le 100)$，代表数组 $a$。 ","date":"2023-12-02","objectID":"/posts/training0/:1:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-13"},{"categories":["在学算法的日子里"],"content":" 输出格式对于每组数据输出一行。若无解，则输出 -1。否则输出一个由 $1,2,3$ 组成的数组 $b$，恰好满足两条性质。如果有多个合法数组，输出任一即可。 ","date":"2023-12-02","objectID":"/posts/training0/:1:3","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-13"},{"categories":["在学算法的日子里"],"content":" 说明/提示第一个数组 $a$，合法数组可以是 $b=[1,2,3,1,1,1]$。当 $i = 4,j = 2$ 时，满足性质一。当$i = 6,j = 3$ 时满足性质二。数组 $b$ 无法满足性质三，所以恰好满足两条，合法。 ","date":"2023-12-02","objectID":"/posts/training0/:1:4","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#说明提示-1"},{"categories":["在学算法的日子里"],"content":" 题目描述You are given an array $ a_1, a_2, \\ldots, a_n $ . You need to find an array $ b_1, b_2, \\ldots, b_n $ consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ such that exactly two out of the following three conditions are satisfied: There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 1 $ , $ b_j = 2 $ . There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 1 $ , $ b_j = 3 $ . There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i = 2 $ , $ b_j = 3 $ . If such an array does not exist, you should report it. ","date":"2023-12-02","objectID":"/posts/training0/:2:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#题目描述-14"},{"categories":["在学算法的日子里"],"content":" 输入格式Each test contains multiple test cases. The first line contains a single integer $ t $ $ (1 \\leq t \\leq 500) $ — the number of test cases. Each test case is described as follows. The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq 100) $ — the length of the array $ a $ . The second line of each test case contains $ n $ integers $ a_1, a_2, \\ldots, a_n $ $ (1 \\leq a_i \\leq 100) $ — the elements of the array $ a $ . ","date":"2023-12-02","objectID":"/posts/training0/:3:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输入格式-14"},{"categories":["在学算法的日子里"],"content":" 输出格式For each test case, print -1 if there is no solution. Otherwise, print $ b_1, b_2, \\ldots, b_n $ — an array consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ that satisfies exactly two out of three conditions. If there are multiple possible answers, you can print any of them. ","date":"2023-12-02","objectID":"/posts/training0/:4:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#输出格式-14"},{"categories":["在学算法的日子里"],"content":" 样例 #1","date":"2023-12-02","objectID":"/posts/training0/:5:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输入 #1 9 6 1 2 3 2 2 3 7 7 7 7 7 7 7 7 4 1 1 2 2 7 1 2 3 4 5 6 7 5 2 3 3 3 2 3 1 2 1 9 1 1 1 7 7 7 9 9 9 1 1 18 93 84 50 21 88 52 16 50 63 1 30 85 29 67 63 58 37 69 ","date":"2023-12-02","objectID":"/posts/training0/:5:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输入-1-11"},{"categories":["在学算法的日子里"],"content":" 样例输出 #1 1 2 3 1 1 1 -1 3 2 2 1 -1 2 1 2 1 3 -1 1 1 2 2 1 2 2 3 3 -1 3 2 1 3 3 3 3 2 2 1 1 2 3 1 3 1 1 2 ","date":"2023-12-02","objectID":"/posts/training0/:5:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#样例输出-1-11"},{"categories":["在学算法的日子里"],"content":" 提示In the first test case, $ b = [1, 2, 3, 1, 1, 1] $ satisfies condition $ 1 $ because for $ i = 4 $ , $ j = 2 $ : $ a_i = a_j $ , $ b_i = 1 $ , and $ b_j = 2 $ . It also satisfies condition $ 2 $ because for $ i = 6 $ , $ j = 3 $ : $ a_i = a_j $ , $ b_i = 1 $ , and $ b_j = 3 $ . However, it does not satisfy condition $ 3 $ . In total, exactly two out of three conditions are satisfied. ","date":"2023-12-02","objectID":"/posts/training0/:6:0","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#提示-13"},{"categories":["在学算法的日子里"],"content":" 分析构造题，根据分析，只有当数量超过2个的数的种数大于等于2，才有可能构造出符合要求的b数组。 ","date":"2023-12-02","objectID":"/posts/training0/:6:1","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#分析-12"},{"categories":["在学算法的日子里"],"content":" 参考代码 #include\u003cbits/stdc++.h\u003e using namespace std; const int maxn = 120; int a[maxn]; // int cnt[maxn]; int n; void solve() { cin \u003e\u003e n; // fill(cnt, cnt + sizeof(cnt), 0); int cnt[maxn] = {}; for (int i = 0;i \u003c n;i++) { cin \u003e\u003e a[i]; cnt[a[i]]++; } int cntn = 0; for (int i = 1;i \u003c= 101;i++) { if (cnt[i] \u003e= 2) cntn++; } if (cntn \u003c 2) { cout \u003c\u003c -1 \u003c\u003c endl; return; } bool ck[maxn] = { false }; bool f = true; for (int i = 0;i \u003c n;i++) { int x = a[i]; if (cnt[x] \u003e= 2 \u0026\u0026 !ck[x]) { if (f) { cout \u003c\u003c 2 \u003c\u003c \" \"; f = false; } else { cout \u003c\u003c 3 \u003c\u003c \" \"; } ck[x] = true; } else { cout \u003c\u003c 1 \u003c\u003c \" \"; } } cout \u003c\u003c \"\\n\"; } int main() { int t;cin \u003e\u003e t; while (t--) solve(); return 0; } ","date":"2023-12-02","objectID":"/posts/training0/:6:2","series":null,"tags":["算法"],"title":"队内拉题记录||23.11.29","uri":"/posts/training0/#参考代码-12"},{"categories":[],"content":" 你好哇，很高兴认识你，这里是 Doごみ箱。 ","date":"2023-11-28","objectID":"/about/:0:0","series":[],"tags":["关于"],"title":"🍅关于","uri":"/about/#你好哇"},{"categories":[],"content":" 🎐站长信息：昵称：哆哆啦(DODOLA) 刷新地点：杭州/长春 爱好：阅读/电影/音乐/音乐剧/Coding/小提琴/旅游/逛展/单机游戏/麻将/云二次元/猫猫虫 废话：一个标准的特立独行INTJer，不变的终身学习者，兴趣广泛，好奇泛滥，涉猎多开坑多但是会慢慢填坑的qwq，喜欢深究根本，努力不咕咕，目前就读于东北师范大学的计科(中外合作)专业，先贤有言：“教学相长也”，在写上传到本站的笔记时会注意书写逻辑，欢迎各位佬的批评指正🙇‍♀️🙇‍♀️。 最近重看之前的博客，感觉博客的废话含量还是挺多的。。 联系方式：163.com or gmail ","date":"2023-11-28","objectID":"/about/:0:1","series":[],"tags":["关于"],"title":"🍅关于","uri":"/about/#站长信息"},{"categories":[],"content":" 🪁本站信息：建站日期：2023/11/28 本站简介：本站会用来保存站长的电子笔记，涉及书评/影评/复习笔记/算法学习/前端学习/日记分享…etc，或许就是个杂七杂八的电子小仓库，欢迎您的访问！非常欢迎友链互链，相互交流！很高兴认识你~ 框架： 博客框架：Hugo v0.139.4 主题：PaperMod 2024/07 更换为DoIt 仓库：GitHub 线路信息 初始域名：florae006.github.io 主域名：dodolalorc.cn ","date":"2023-11-28","objectID":"/about/:0:2","series":[],"tags":["关于"],"title":"🍅关于","uri":"/about/#本站信息"}]